#+TITLE: My Emacs Config
#+CATEGORY: IT
#+STARTUP: overview indent
#+FILETAGS: :emacs:
#+TYP_TODO: TRY(y) TEST(t) IMPLEMENT(i) TODO(o) | DONE(d)
#+PROPERTY: header-args :tangle malb.el

* Header

#+begin_src emacs-lisp
;;; init.el --- personal emacs config file -*- lexical-binding: t ; eval: (read-only-mode 1)-*-
#+end_src

* Assumptions & Init

We assume that the following variables are defined:

- ~malb/startup-quick~ – disable some stuff to speed up startup
- ~malb/documents-dir~ - documents
- ~malb/inbox-org~ - this is where I store tasks
- ~malb/work-org~ - this is where I store tasks
- ~malb/private-org~ - this is where I store tasks
- ~malb/literature-dirs~ - PDFs of papers
- ~malb/literature-notes-dir~ - notes on papers
- ~malb/mu4e-name-replacements~ - e-mail name replacements
- ~malb/org-files-dir~ - org files go here
- ~malb/org-files~ - org files
- ~malb/org-mode-ics~ - icalendar file
- ~malb/paradox-github-token~ - github login
- ~malb/projectile-ignored-projects~ - ignored projects
- ~malb/projects-dir~ - a super-repository of which all of my projects are subprojects
- ~malb/sage-executable~ - full path of Sage executable
- ~malb/sync-dir~ - documents that are synchronised
- ~malb/deft-directory~ - where deft files live

We collect our own customisations in the =malb= group.

#+begin_src emacs-lisp
(defgroup malb nil
  "malb's personal config"
  :group 'convenience)
#+end_src

* TLS

Enable TLS cert checking ([[https://glyph.twistedmatrix.com/2015/11/editor-malware.html][source]])

#+begin_src emacs-lisp
(let ((trustfile (replace-regexp-in-string
                  "\\\\" "/" (replace-regexp-in-string
                              "\n" "" (shell-command-to-string "python -m certifi")))))
  (setq tls-program (list
                     (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                             (if (eq window-system 'w32) ".exe" "") trustfile))
        gnutls-verify-error t
        gnutls-trustfiles (list trustfile)
        tls-checktrust t))

;; (let ((bad-hosts
;;        (cl-loop for bad
;;              in `("https://wrong.host.badssl.com/"
;;                   "https://self-signed.badssl.com/")
;;              if (condition-case e
;;                     (url-retrieve
;;                      bad (lambda (retrieved) t))
;;                   (error nil))
;;              collect bad)))
;;   (if bad-hosts
;;       (error (format "tls misconfigured; retrieved %s ok"
;;                      bad-hosts))
;;     (url-retrieve "https://badssl.com"
;;                   (lambda (retrieved) t))))
#+end_src

* Utilities

Check if any regexp matches string, because OR is hard …

#+begin_src emacs-lisp
(defun malb/regexp-match-p (regexps string)
  (and string
       (catch 'matched
         (let ((inhibit-changing-match-data t))
           (dolist (regexp regexps)
             (when (string-match regexp string)
               (throw 'matched t)))))))
#+end_src

This is really nice. ([[https://github.com/hlissner/doom-emacs/blob/2d2246d7ca5ec084f4bee9a5de14256eb6828837/core/core-lib.el#L584][source]])

#+begin_src emacs-lisp
(defun malb/enlist (exp)
  "Return EXP wrapped in a list, or as-is if already a list."
  (declare (pure t) (side-effect-free t))
  (if (listp exp) exp (list exp)))

(defmacro malb/defadvice! (symbol arglist &optional docstring &rest body)
  "Define an advice called SYMBOL and add it to PLACES.
ARGLIST is as in `defun'. WHERE is a keyword as passed to `advice-add', and
PLACE is the function to which to add the advice, like in `advice-add'.
DOCSTRING and BODY are as in `defun'.
\(fn SYMBOL ARGLIST &optional DOCSTRING &rest [WHERE PLACES...] BODY\)"
  (declare (doc-string 3) (indent defun))
  (unless (stringp docstring)
    (push docstring body)
    (setq docstring nil))
  (let (where-alist)
    (while (keywordp (car body))
      (push `(cons ,(pop body) (malb/enlist ,(pop body)))
            where-alist))
    `(progn
       (defun ,symbol ,arglist ,docstring ,@body)
       (dolist (targets (list ,@(nreverse where-alist)))
         (dolist (target (cdr targets))
           (advice-add target (car targets) #',symbol))))))
#+end_src

* Package Management

#+begin_src emacs-lisp
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(setq package-archive-priorities '(("gnu" . 1)
                                   ("nongnu" . 1)
                                   ("melpa" . 2))
      package-menu-hide-low-priority nil)
#+end_src

Get the package manager going.

Use [[https://github.com/jwiegley/use-package/][use-package]] to keep our configuration readable.

#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package)
  (package-install 'use-package-ensure-system-package))

(require 'use-package)
(require 'use-package-ensure-system-package)

(setq use-package-compute-statistics t
      use-package-verbose t
      use-package-always-ensure t)
#+end_src

[[https://github.com/Bruce-Connor/paradox/][Paradox]] is a better package list

- Visit the package's homepage with =v=
- View a list of recent commits with =l=
- Shortcuts for package filtering:
  - =f r= filters by regexp (occur)
  - =f u= display only packages with upgrades
  - =f k= filters by keyword
  - =f c= clear filter
- Hit =h= to see all keys

#+begin_src emacs-lisp
(use-package paradox
  :commands (paradox-upgrade-packages paradox-list-packages)
  :config (setq paradox-execute-asynchronously t
                paradox-github-token malb/paradox-github-token
                paradox-automatically-star t))
#+end_src

[[https://github.com/quelpa/quelpa][Quelpa]] to install packages directly from source.

#+begin_src emacs-lisp
(use-package quelpa)
(use-package quelpa-use-package)
#+end_src

* Memory

We have RAM, lots of it.

#+begin_src emacs-lisp
(setq global-mark-ring-max 256
      mark-ring-max 256
      kill-ring-max 256)
#+end_src

We set =(setq gc-cons-threshold most-positive-fixnum)= in =early-init.el=, after init files are loaded we enable the [[https://github.com/emacsmirror/gcmh][garbage collector magic hack]] with something more sensible.

#+begin_src emacs-lisp
(use-package gcmh
  :demand t
  :config (progn
            (setq gcmh-high-cons-threshold (* 256 1024 1024)
                  gcmh-low-cons-threshold (* 1 1024 1024))
            (defun malb/enable-gcmh ()
              (setq gc-cons-threshold (* 256 1024 1024))
              (gcmh-mode 1))
            (add-hook 'emacs-startup-hook #'malb/enable-gcmh)))
#+end_src

* Clean Mode Line

Use [[https://github.com/raxod502/blackout][blackout]] to remove mentions of minor modes from the mode-line as we’re using a quite few of them and don’t want to waste the real estate. Most diminishing is done by the ~:blackout~ parameter to =use-package=.

#+begin_src emacs-lisp
(use-package blackout)
#+end_src

* Paths

[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]]

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :config (progn (exec-path-from-shell-initialize)
                 (exec-path-from-shell-copy-env "GOPATH")))
#+end_src

* Keyboard Shortcuts

We use ~Super~ (in our case: ~CapsLock~) as a menu of sorts:

#+begin_src emacs-lisp
(define-prefix-command 'f2-global-map)
(bind-key "<f2>" #'f2-global-map)

(defun malb/set-menu-key (char func)
  (bind-key (concat "s-" char) func)
  (bind-key char func f2-global-map))
#+end_src

** Key Chords

Key chords allow to execute actions by pressing one or two keys really fast. Sometimes we might want to use those. However, mostly, we don’t as the slight delay they introduce (to check if a key chord should be executed or the text inserted) is annoying.

#+begin_src emacs-lisp
(use-package key-chord
  :config (progn
            (setq key-chord-one-key-delay 0.2
                  key-chord-two-keys-delay 0.1)
            (key-chord-mode 1)))
#+end_src

*Note:* =key-chord= can slow down typing but it works e.g. in =vterm= buffers which is quite handy.

* Window Management

https://github.com/emacs-helm/helm/issues/1976

#+begin_src emacs-lisp
(setq x-wait-for-event-timeout 0.1)
#+end_src

** Splitting

Ilist, dired-sidebar, reftex-toc etc.

#+begin_src emacs-lisp
(defconst malb/left-side-window-width 40)
#+end_src

One side-window per direction.

#+begin_src emacs-lisp
(customize-set-variable 'window-sides-slots '(1 1 1 2))
(customize-set-variable 'window-sides-vertical t)
#+end_src

When splitting windows open the previous buffer in it.

#+begin_src  emacs-lisp
(defun malb/vsplit-last-buffer ()
  "Split the window vertically and display the previous buffer."
  (interactive)
  (split-window-vertically)
  (other-window 1 nil)
  (switch-to-next-buffer))

(defun malb/hsplit-last-buffer ()
  "Split the window horizontally and display the previous buffer."
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil)
  (switch-to-next-buffer))

(bind-key "C-x 2" #'malb/vsplit-last-buffer)
(bind-key "C-x 3" #'malb/hsplit-last-buffer)
#+end_src

Don’t split horizontally.

#+begin_src emacs-lisp
(setq split-width-threshold 70
      split-height-threshold nil)

(defun malb/split-window-sensibly (&optional window)
  (let ((side-window-width (max malb/left-side-window-width malb/right-side-window-width))
        (window (or window (selected-window))))
    ;; DIFF: prefer horizontal split
    (or (and (window-splittable-p window t)
             ;; DIFF: restrict to two windows or two windows + side-window
             ;; (or  (= (length (window-list)) 1)
             ;;      (and (= (length (window-list)) 2)
             ;;           (seq-filter (lambda (x) (<= (window-width x) 40)) (window-list))))
             (= (length (seq-filter (lambda (x) (> (window-width x) side-window-width)) (window-list))) 1)
             ;; Split window horizontally.
             (with-selected-window window
               (split-window-right)))
        (and (window-splittable-p window)
             ;; Split window vertically.
             (with-selected-window window
               (split-window-below)))
        (and (eq window (frame-root-window (window-frame window)))
             (not (window-minibuffer-p window))
             ;; If WINDOW is the only window on its frame and is not the
             ;; minibuffer window, try to split it vertically disregarding
             ;; the value of `split-height-threshold'.
             (let ((split-height-threshold 0))
               (when (window-splittable-p window)
                 (with-selected-window window
                   (split-window-below))))))))

(setq split-window-preferred-function #'malb/split-window-sensibly)
#+end_src

Resize windows to accommodate new ones.

#+begin_src emacs-lisp
(setq window-combination-resize t)
#+end_src

** Restoring Configurations

[[http://www.emacswiki.org/emacs/WinnerMode][Winner mode]] is a global minor mode. When activated, it allows to “undo” (and “redo”) changes in the window configuration.

#+begin_src emacs-lisp
(winner-mode 1)

(malb/defadvice! malb/winner-save-old-configurations (old-function &rest args)
  "This deals with `Error in post-command-hook (winner-save-old-configurations):
  (wrong-type-argument frame-live-p #<dead frame *Org Capture* …>)`"
  :around 'winner-save-old-configurations
  (ignore-errors
    (apply old-function args)))
#+end_src

[[https://github.com/louiskottmann/zygospore.el][zygospore]] lets you revert =C-x 1= =(delete-other-window)= by pressing =C-x 1= again.

#+begin_src emacs-lisp
(use-package zygospore
  :bind (("C-x 1" . malb/zygospore-toggle-delete-other-windows))
  :config (progn
            (defun malb/zygospore-toggle-delete-other-windows ()
              "Main zygospore func.
If the current frame has several windows, it will act as `delete-other-windows'.
If the current frame has one window,
	and it is the one that was last full-frame'd,
	and the buffer remained the same,
it will restore the window configuration to prior to full-framing."
              (interactive)
              (if (and (= (length (seq-filter
                                   (lambda (x)
                                     (> (window-width x) malb/left-side-window-width))
                                   (window-list)))
                          1)
                       (equal (selected-window) zygospore-last-full-frame-window)
                       (equal (current-buffer) zygospore-last-full-frame-buffer))
                  (zygospore-restore-other-windows)
                (zygospore-delete-other-window)))))
#+end_src

** Tabs

#+begin_src emacs-lisp
(use-package tab-bar
  :ensure nil
  :bind (("C-<next>" . tab-next)
         ("C-<prior>" . tab-previous))
  :custom ((tab-bar-mode t "Enable tab-bar-mode")
           (tab-bar-show nil "But don't show tabs")
           (tab-bar-new-tab-to 'rightmost "Open new tabs at the end"))
  :config (progn
            ;; https://www.rousette.org.uk/archives/using-the-tab-bar-in-emacs/
            (defun malb/name-tab-by-project-or-default ()
              "Return project name if in a project, or default tab-bar name if not.
The default tab-bar name uses the buffer name."
              (let ((project-name (projectile-project-name)))
                (if (or (= (let ((tab-bar-tab-name-function #'tab-bar-tab-name-current))
                             (if (tab-bar--current-tab-index)
                                 (tab-bar--current-tab-index)
                               0))
                           0)
                        (string= "-" project-name))
                    (tab-bar-tab-name-current)
                  (projectile-project-name))))
            (setq tab-bar-tab-name-function #'malb/name-tab-by-project-or-default)

            (defmacro malb/with-tab (name &rest body)
              `(progn
                 (if (tab-bar--tab-index-by-name ,name)
                     (tab-bar-switch-to-tab ,name)
                   (progn
                     (tab-bar-new-tab)
                     (tab-bar-rename-tab ,name)))
                 ,@body))

            (malb/defadvice! malb/switch-tab-1 (&rest arguments)
              "Switch to new tab 1."
              :before 'org-agenda
              (tab-bar-select-tab 1))

            (defun malb/switch-tab (&rest arg)
              ;; just in case someone decides to pass an argument
              (interactive)
              (let* ((tabs (mapcar (lambda (tab)
                                     (cdr (assq 'name tab)))
                                   (tab-bar-tabs)))
                     (ntabs (length tabs))
                     (current-tab (cdr (assq 'name (tab-bar--current-tab-find (tab-bar-tabs))))))
                (cond ((equal ntabs 1) t)
                      ((equal ntabs 2) (tab-bar-switch-to-tab (if (equal current-tab (car tabs))
                                                                  (cadr tabs)
                                                                (car tabs))))
                      (t (tab-switcher)))))

            (defun malb/close-remote-tabs (tab single)
              (let ((tab-name (alist-get 'name tab)))
                (when (string-prefix-p "@" tab-name)

                  (tramp-cleanup-this-connection)

                  (dolist (buffer (tramp-list-remote-buffers))
                    (when (and  (s-contains-p (substring tab-name 1)
                                              (with-current-buffer buffer default-directory))
                                (bufferp (get-buffer buffer)))
                      (kill-buffer buffer))))))

            (add-to-list 'tab-bar-tab-pre-close-functions #'malb/close-remote-tabs)))
#+end_src

** Switching
*** Ace Window

[[https://github.com/abo-abo/ace-window][ace-window]] for switching windows.

[[http://oremacs.com/download/ace-window.gif]] ([[http://oremacs.com/download/ace-window.gif][source]])

#+begin_src emacs-lisp
(use-package ace-window
  :commands ace-window
  :bind (("M-o" . ace-window)
         ("C-x o" . ace-window)
         ("C-`"  . malb/ace-window))
  :config (progn
            (setq aw-keys   '(?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8)
                  aw-dispatch-always nil
                  aw-dispatch-when-more-than 2
                  aw-dispatch-alist
                  '((?x aw-delete-window     "Ace - Delete Window")
                    (?c aw-swap-window       "Ace - Swap Window")
                    (?n aw-flip-window)
                    (?v aw-split-window-vert "Ace - Split Vert Window")
                    (?h aw-split-window-horz "Ace - Split Horz Window")
                    (?g delete-other-windows "Ace - Maximize Window")
                    (?b balance-windows)
                    (?u winner-undo)
                    (?r winner-redo)))
            (add-to-list 'aw-ignored-buffers "*Ilist*")
            (add-to-list 'aw-ignored-buffers "*toc*")
            (add-to-list 'aw-ignored-buffers 'dired-sidebar-mode)
            (defun malb/ace-window (arg)
              (interactive "P")
              (let ((aw-dispatch-when-more-than 3)
                    (aw-scope 'frame))
                (ace-window arg)))))
#+end_src

*** Back and Forth

Quickly jump back and forth between buffers ([[http://www.emacswiki.org/emacs/SwitchingBuffers#toc4][source]])

#+begin_src emacs-lisp
(defun malb/switch-to-previous-buffer ()
  "Switch to previously open buffer.

Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))
#+end_src

*** Window Numbering

Select windows using [[https://github.com/deb0ch/emacs-winum][window numbers]].

#+begin_src emacs-lisp
(use-package winum
  :init (setq winum-keymap
              (let ((map (make-sparse-keymap)))
                (bind-key "M-0" #'winum-select-window-0-or-10 map)
                (bind-key "M-1" #'winum-select-window-1 map)
                (bind-key "M-2" #'winum-select-window-2 map)
                (bind-key "M-3" #'winum-select-window-3 map)
                (bind-key "M-4" #'winum-select-window-4 map)
                (bind-key "M-5" #'winum-select-window-5 map)
                (bind-key "M-6" #'winum-select-window-6 map)
                (bind-key "M-7" #'winum-select-window-7 map)
                (bind-key "M-8" #'winum-select-window-8 map)
                (bind-key "M-9" #'winum-select-window-9 map)
                (bind-key "C-x w" #'winum-select-window-by-number map)
                map))
  :config (progn
            (defun malb/winum-assign ()
              (cond
               ((equal major-mode 'imenu-list-major-mode) 8)
               ((equal major-mode 'dired-sidebar-mode) 8)
               ((equal major-mode 'reftex-toc-mode) 8)
               (t nil)))

            (add-to-list 'winum-assign-functions #'malb/winum-assign)

            (setq winum-scope                       'frame-local
                  winum-reverse-frame-list          nil
                  winum-auto-assign-0-to-minibuffer t
                  winum-auto-setup-mode-line        nil
                  winum-ignored-buffers             '(" *which-key*"))

            (winum-mode)))
#+end_src

** Popup Windows

Some buffers should behave like pop ups, i.e. display at the bottom with small height.

#+begin_src emacs-lisp
(defvar malb/popup-windows (list (rx (seq bos "*helm flycheck*" eos))
                                 (rx (seq bos "*Flycheck errors*" eos))
                                 (rx (seq bos "*helm projectile*" eos))
                                 (rx (seq bos "*Helm all the things*" eos))
                                 (rx (seq bos "*Helm Find Files*" eos))
                                 (rx (seq bos "*ielm*" eos))
                                 (rx (seq bos "*Synonyms List*" eos))
                                 (rx (seq bos "*anaconda-doc*" eos))
                                 (rx (seq bos "*LanguageTool Errors*" eos))
                                 (rx (seq bos "*Edit footnote " (zero-or-more nonl) "*" eos))
                                 (rx (seq bos "*TeX errors" "*" eos))
                                 (rx (seq bos "*Org Export Dispatcher*" eos))
                                 (rx (seq bos "*Backtrace*" eos))
                                 (rx (seq bos "*Messages*" eos))
                                 (rx (seq bos "*Calendar*" eos))
                                 (rx (seq bos "*Go-Translate*" eos))
                                 (rx (seq bos "*lexic*" eos))
                                 (rx (seq bos "*Async Shell Command*" eos))
                                 (rx (seq bos "*LaTeXMK[" (zero-or-more nonl) "]*"))
                                 (rx (seq bos "*jupyter-error*" eos))
                                 (rx (seq bos "*jupyter-traceback*" eos))
                                 (rx (seq bos "*jupyter-repl[" (zero-or-more nonl) "]*" eos))
                                 (rx (seq bos "*tzc-times*" eos))
                                 (rx (seq bos "*batzenca*" eos))
                                 (rx (seq bos "*ggtags-global*" eos))
                                 (rx "*Org-Babel Error Output*")))
#+end_src

#+begin_src emacs-lisp
;; (setq display-buffer-alist nil)

(defvar malb/popup-window-height 0.381966011250145)
(defconst malb/right-side-window-width 80)

(defun malb/window-has-popup-height-p (window)
  (and window
       (<= (window-height window)
           (ceiling (* (frame-height) malb/popup-window-height)))))

(defun malb/display-buffer-in-popup-window (buffer alist)
  (let ((window (catch 'window
                  (dolist (window (window-list))
                    (when (and (window-parameter window 'malb/popup-window)
                               (<= (window-height window) (* (frame-height) malb/popup-window-height)))
                      (throw 'window window))))))
    (when window
      (window--display-buffer buffer window 'reuse alist))))

(defun malb/register-popup-window (buffer-name-rx &optional winum-10)
  (add-to-list 'display-buffer-alist
               `(,buffer-name-rx
                 (malb/frame-dispatch
                  display-buffer-reuse-window
                  malb/display-buffer-in-popup-window
                  display-buffer-in-direction)
                 (reusable-frames . nil)
                 (dedicated       . t)
                 (direction       . below)
                 (preserve-size   . (nil . t))
                 (window-parameters
                  (malb/popup-window . t)
                  (no-other-window . t)
                  (no-delete-other-windows . t))
                 (window-height   . ,malb/popup-window-height)))

  (if winum-10
      (add-to-list 'winum-assign-functions
                   (lambda () (when (string-match-p buffer-name-rx (buffer-name)) 10)))))

(defun malb/register-wide-popup-window (buffer-name-rx &optional winum-10)
  (add-to-list 'display-buffer-alist
               `(,buffer-name-rx
                 (malb/frame-dispatch
                  display-buffer-reuse-window
                  malb/display-buffer-in-popup-window
                  display-buffer-at-bottom)
                 (reusable-frames . nil)
                 (dedicated       . t)
                 (preserve-size   . (nil . t))
                 (window-parameters
                  (malb/popup-window . t)
                  (no-other-window . t)
                  (no-delete-other-windows . t))
                 (window-height   . ,malb/popup-window-height)))

  (if winum-10
      (add-to-list 'winum-assign-functions
                   (lambda () (when (string-match-p buffer-name-rx (buffer-name)) 10)))))

(dolist (name-rx malb/popup-windows) (malb/register-popup-window name-rx nil))
#+end_src

#+begin_src emacs-lisp
(defun malb/register-right-side-window (buffer-name-rx &optional winum-9)
  (add-to-list 'display-buffer-alist
             `(,buffer-name-rx
               (malb/frame-dispatch
                display-buffer-reuse-window
                display-buffer-in-side-window)
               (side . right)
               (slot . 0)
               (window-width . ,malb/right-side-window-width)))

  (if winum-9
      (add-to-list 'winum-assign-functions
                   (lambda () (when (string-match-p buffer-name-rx (buffer-name)) 9)))))
#+end_src

** Closing/Promoting Pop-up-style Windows

In case we just want to kill the bottom window, set a shortcut do to this.

#+begin_src emacs-lisp
(defun malb/quit-bottom-disposable-windows ()
  "Quit disposable windows of the current frame."
  (interactive)
  (let ((found))
    (dolist (window (window-at-side-list))
      (when (malb/window-has-popup-height-p window)
        (setq found t)
        (delete-window window)))
    found))

(defun malb/promote-disposable-window-or-to-frame ()
  "Promote disposable window to real window."
  (interactive)
  (if (not (eq major-mode 'vterm-mode))
      (dolist (window (window-at-side-list nil 'bottom))
        (let ((buffer (window-buffer window))
              (display-buffer-alist nil))
          ;; hack: only promote windows that don't touch the top, this is to leave side windows alone
          (when (not (member window (window-at-side-list nil 'top)))
            (delete-window window)
            (display-buffer buffer))))
    (progn
      (let* ((window (get-buffer-window))
             (buffer (window-buffer window)))
        ;; hack: only promote windows that don't touch the top, this is to leave side windows alone
        (when (not (member window (window-at-side-list nil 'top)))
          (delete-window window)
          (switch-to-buffer-other-frame buffer))))))

(key-chord-define-global "qq" #'malb/quit-bottom-disposable-windows)
(key-chord-define-global "qw" #'malb/promote-disposable-window-or-to-frame)
#+end_src

** Display Management Hammer

#+begin_src emacs-lisp
(malb/defadvice! malb/display-buffer-alist-nil (orig-function &rest args)
  "Run ORIG-FUNCTION with empty `display-buffer-alist`"
  :around #'lv-message
  (let ((display-buffer-alist nil))
    (apply orig-function args)))
#+end_src

** Compilation Window

If there was no error the window closes automatically.

#+begin_src emacs-lisp
(defun malb/compilation-exit-autoclose (status code msg)
  ;; If M-x compile exists with a 0
  (when (and (eq status 'exit) (zerop code))
    ;; and delete the *compilation* window
    (let ((compilation-window (get-buffer-window (get-buffer "*compilation*"))))

      (when (and (not (window-at-side-p compilation-window 'top))
                 (window-at-side-p compilation-window 'left)
                 (window-at-side-p compilation-window 'right))
        (delete-window compilation-window))))
  ;; Always return the anticipated result of compilation-exit-message-function
  (cons msg code))

(setq compilation-exit-message-function #'malb/compilation-exit-autoclose)
#+end_src

If you change the variable ~compilation-scroll-output~ to a ~non-nil~ value, the compilation buffer scrolls automatically to follow the output. If the value is ~first-error~, scrolling stops when the first error appears, leaving point at that error. For any other non-nil value, scrolling continues until there is no more output.

#+begin_src emacs-lisp
(setq compilation-scroll-output 'first-error)
#+end_src

** Dispatch Buffers to Frames

Separate “special” frames from others ([[https://stackoverflow.com/questions/18346785/how-to-intercept-a-file-before-it-opens-and-decide-which-frame/18371427#18371427][source]])

#+begin_src emacs-lisp
(defvar malb/special-frame-names '("\\*Minibuf-1\\*.*" ;; helm
                                   "\\*mu4e\\*"
                                   "F1" ;; daemon
                                   )
  "Special frame names")

(defun malb/frame-is-special-p (frame &optional mu4e-is-not-special)
  (let* ((is-special (or (s-equals-p (frame-parameter frame 'title) "Helm")
                         (frame-parameter frame 'malb/special-frame)
                         (seq-some
                          (lambda (name)
                            (if (eq (string-match-p name (frame-parameter frame 'name)) 0) t nil))
                          malb/special-frame-names)))
         (is-mu4e (string-match-p "\\*mu4e\\*" (frame-parameter frame 'name))))
    (if mu4e-is-not-special
        (and is-special (not is-mu4e))
      is-special)))

(defun malb/frame-is-not-special-p (frame &optional mu4e-is-not-special)
  (not (malb/frame-is-special-p frame mu4e-is-not-special)))

(defun malb/only-frame-p (frame)
  "Return t when the current frame is the only not special frame"
  (and (malb/frame-is-not-special-p frame)
       (< (length (seq-filter 'malb/frame-is-not-special-p (frame-list))) 2)))
#+end_src

Get frame by name or return passed frame.

#+begin_src emacs-lisp
(defun malb/get-frame (frame)
  "Return a frame, if any, named FRAME (a frame or a string).
If none, return nil.
If FRAME is a frame, it is returned."
  (let ((malb/get-frame-name
         (lambda (&optional frame)
           (unless frame (setq frame (selected-frame)))
           (if (framep frame)
               (cdr (assq 'name (frame-parameters frame)))
             (error "Argument not a frame: `%s'" frame)))))
    (cond ((framep frame) frame)
          ((stringp frame)
           (catch 'get-a-frame-found
             (dolist (fr (frame-list))
               (when (string= frame (funcall malb/get-frame-name fr))
                 (throw 'get-a-frame-found fr)))
             nil))
          (t
           (error "Arg neither a string nor a frame: `%s'" frame)))))
#+end_src

Find a frame not named qualified as “special” if there is any, make one otherwise.

#+begin_src emacs-lisp
(defun malb/switch-away-from-special (&optional is-okay)
  (let ((other-frame (catch 'other-frame
                       (dolist (frame (frame-list))
                         (cond
                          ;; we allow it (e.g. inline helm)
                          ((and (malb/frame-is-special-p frame)
                                is-okay)
                           (throw 'other-frame frame))
                          ;; a plain frame
                          ((malb/frame-is-not-special-p frame)
                           (throw 'other-frame frame)))))))
    (select-frame-set-input-focus (or other-frame (make-frame)))))

(defun malb/switch-away-from-special-and-tab (&optional helm-is-okay)
  (malb/switch-away-from-special helm-is-okay)
  (malb/switch-tab-1))

(defun malb/switch-away-from-special-advice (old-function &rest arguments)
  (malb/switch-away-from-special)
  (apply old-function arguments))

(defun malb/switch-away-from-special-and-tab-advice (old-function &rest arguments)
  (malb/switch-away-from-special-and-tab)
  (apply old-function arguments))
#+end_src

Main frame dispatch function:

#+begin_src emacs-lisp
(defun malb/mu4e-buffer-p(buffer &optional compose-too)
  "Return t if BUFFER is a mu4e buffer."
  (let ((major-mode (buffer-local-value 'major-mode buffer)))
    (or (memq major-mode
              '(mu4e-main-mode
                mu4e-headers-mode
                mu4e-view-mode
                mu4e-raw-view-mode))
        (and compose-too (eq major-mode 'mu4e-compose-mode)))))
#+end_src

#+begin_src emacs-lisp
(defun malb/frame-dispatch (buffer alist)
  "Assigning buffers to frames."
  (cond
   ;; target a mu4e compose buffer
   ((eq (buffer-local-value 'major-mode buffer) 'mu4e-compose-mode)
    (malb/display-mu4e-draft-buffer buffer alist)
    nil)

   ;; we are in a compose buffer
   ((eq (buffer-local-value 'major-mode (current-buffer)) 'mu4e-compose-mode)
    (malb/switch-away-from-special-and-tab (string-match-p ".*helm.*" (buffer-name buffer)))
    nil)

   ;; an mu4e buffer
   ((or (malb/mu4e-buffer-p buffer nil))
    (malb/switch-to-mu4e)
    nil)

   ;; this is not a mu4e buffer but we’re in the mu4e frame
   ((and (string-match "*mu4e*" (frame-parameter nil 'name))
         (not (malb/mu4e-buffer-p buffer nil))
         (not (malb/regexp-match-p malb/mu4e-buffer-allowed-regexps (buffer-name buffer))))
    (malb/switch-away-from-special-and-tab (string-match-p ".*helm.*" (buffer-name buffer)))
    nil)

   (t
    nil)))
#+end_src

#+begin_src emacs-lisp
(add-to-list 'display-buffer-alist '(".*" (malb/frame-dispatch)) t)
#+end_src

([[https://emacs.stackexchange.com/questions/64279/pop-to-buffer-in-other-frame-if-file-is-already-visited/69270#69270][source]])

#+begin_src emacs-lisp
(setq display-buffer-base-action '(display-buffer-reuse-window (reusable-frames . visible)))
#+end_src

#+begin_quote
By default Emacs distinguishes between automatic and manual window switching. If you effect a window switch yourself with C-x b, it’s manual — and exempt from
any display action rules you create yourself. — [[https://www.masteringemacs.org/article/demystifying-emacs-window-manager][Demystifying Emacs's Window Manager - Mastering Emacs]]
#+end_quote

#+begin_src emacs-lisp
(setq switch-to-buffer-obey-display-actions t)
#+end_src

#+begin_quote
Controls what happens if you, as a user, attempt to switch buffers in a dedicated window. (Remember, sidebars are also a form of dedicated window.)

I prefer pop to the default, as I’d rather have it pop up the buffer somewhere else than simply error out. That then goes hand-in-hand with the next variable.
— [[https://www.masteringemacs.org/article/demystifying-emacs-window-manager][Demystifying Emacs's Window Manager - Mastering Emacs]]
#+end_quote

#+begin_src emacs-lisp
(setq switch-to-buffer-in-dedicated-window 'pop)
#+end_src

We call this function when killing projectile project buffers.

#+begin_src emacs-lisp
(defun malb/filter-mu4e-buffers (buffers)
  "Remove any mu4e buffer from `buffers`"
  (seq-filter (lambda (buffer)
                (not (memq (buffer-local-value 'major-mode buffer)
                           '(mu4e-main-mode
                             mu4e-view-mode
                             mu4e-raw-view-mode
                             mu4e-headers-mode
                             mu4e-compose-mode))))
              buffers))
#+end_src

** Dedicated Mode

([[https://github.com/jwiegley/dot-emacs/blob/master/site-lisp/dedicated.el][source]])

#+begin_src emacs-lisp
(defvar dedicated-mode nil
  "Mode variable for dedicated minor mode.")

(make-variable-buffer-local 'dedicated-mode)

(defun dedicated-mode (&optional arg)
  "Dedicated minor mode."
  (interactive "P")
  (setq dedicated-mode (not dedicated-mode))
  (set-window-dedicated-p (selected-window) dedicated-mode)
  (if (not (assq 'dedicated-mode minor-mode-alist))
      (setq minor-mode-alist
	    (cons '(dedicated-mode " D")
		  minor-mode-alist))))
#+end_src

** Window Management Hydra

#+begin_src emacs-lisp
(defhydra malb/hydra-window ()
  "
^Misc^        ^Split^         ^Buffer^         ^Resize^         ^Tabs     ^^     ^Center^   ^Jumping^   ^Other^
^----^--------^-----^---------^------^---------^------^---------^---------^^-----^------^---^-------^---^--------------^
_←_ ←         _v_ertical      _H_elm-omni      _q_ X←           _[_ \\/ new      _C_enter   _j_ump      _W_ store cfg
_↓_ ↓         _h_orizontal    _p_revious buf   _w_ X↓           _;_ \\/ ←        _,_ C←     _l_ine      _J_ load cfg
_↑_ ↑         _z_ undo        _n_ext buf       _e_ X↑           _'_ \\/ →        _._ C→     ^^          _I_ imenu
_→_ →         _Z_ reset       _t_oggle buf     _r_ X→           _]_ \\/ close
^^            _d_lt this      _a_ce 1          ^ ^              _!_ \\/ rename
_SPC_ cancel  _D_lt other     _s_wap
^^            _o_nly this
"
  ("<left>" windmove-left  :color blue)
  ("<down>" windmove-down  :color blue)
  ("<up>" windmove-up  :color blue)
  ("<right>" windmove-right  :color blue)
  ("j" avy-goto-char-timer :color blue)
  ("l" avy-goto-line :color blue)
  ("q" shrink-window-horizontally)
  ("w" shrink-window)
  ("e" enlarge-window)
  ("r" enlarge-window-horizontally)
  ("H" malb/helm-omni :color blue)
  ("1" previous-buffer)
  ("2" next-buffer)
  ("p" previous-buffer)
  ("n" next-buffer)
  ("t" malb/switch-to-previous-buffer :color blue)
  ("a" (lambda () (interactive) (ace-window 1)) :color blue)
  ("v" malb/vsplit-last-buffer)
  ("h" malb/hsplit-last-buffer)
  ("s" (lambda () (interactive) (ace-window 4)) :color blue)
  ("d" delete-window)
  ("D" (lambda () (interactive) (ace-window 16)) :color blue)
  ("o" delete-other-windows :color blue)
  ("z" (progn (winner-undo) (setq this-command 'winner-undo)))
  ("Z" winner-redo)
  ("I" imenu-list-smart-toggle :color blue)
  ("[" (lambda () (interactive) (tab-new) (call-interactively #'tab-rename)) :color blue)
  (";" tab-next :color red)
  ("'" tab-previous :color red)
  ("]" tab-close :color blue)
  ("!" tab-rename :color blue)
  ("C" visual-fill-column-mode)
  ("," (lambda () (interactive) (set-fill-column (+ fill-column 2)) (visual-fill-column-adjust)) :color red)
  ("." (lambda () (interactive) (set-fill-column (- fill-column 2)) (visual-fill-column-adjust)) :color red)
  ("W" window-configuration-to-register)
  ("J" jump-to-register  :color blue)
  ("1" (lambda () (interactive)  (tab-bar-select-tab 1)) :color blue)
  ("2" (lambda () (interactive)  (tab-bar-select-tab 2)) :color blue)
  ("3" (lambda () (interactive)  (tab-bar-select-tab 3)) :color blue)
  ("4" (lambda () (interactive)  (tab-bar-select-tab 4)) :color blue)
  ("5" (lambda () (interactive)  (tab-bar-select-tab 5)) :color blue)
  ("6" (lambda () (interactive)  (tab-bar-select-tab 6)) :color blue)
  ("7" (lambda () (interactive)  (tab-bar-select-tab 7)) :color blue)
  ("8" (lambda () (interactive)  (tab-bar-select-tab 8)) :color blue)
  ("9" (lambda () (interactive)  (tab-bar-select-tab 9)) :color blue)
  ("SPC" nil)
  ("`" other-window :color blue)
  ("C-`" other-window :color blue))

;; (key-chord-define-global "\\x" #'malb/hydra-window/body)
#+end_src

** Next/Previous Buffer

([[https://www.reddit.com/r/emacs/comments/b058f8/weekly_tipstricketc_thread/][source]])

#+begin_src emacs-lisp
(use-package skip-buffers-mode
  :ensure nil
  :blackout skip-buffers-mode
  :config (skip-buffers-mode))
#+end_src

* Jumping Around

[[https://raw.githubusercontent.com/wiki/nloyola/avy/images/avy-goto-char.png]] ([[https://github.com/abo-abo/avy][source]])

See [[http://emacsrocks.com/e10.html][Emacs Rocks #10]] which is on ~ace-jump-mode~ which inspired [[https://github.com/abo-abo/avy][avy]].

#+begin_src emacs-lisp
(use-package avy
  :bind (("C-c C-<SPC>" . avy-goto-char-timer)
         ("C-c j j" . avy-goto-char-timer)
         ("M-g g" . avy-goto-line))
  :config (progn
            (setq avy-background t)))
#+end_src

** Links

#+begin_quote
Currently, to jump to a link in an =Info-mode= or =help-mode= or =woman-mode= or =org-mode= or =eww-mode= or =compilation-mode= buffer, you can tab through the links to select the one you want. This is an O(N) operation, where the N is the amount of links. This package turns this into an O(1) operation, or at least O(log(N)) if you manage to squeeze thousands of links in one screen. It does so by assigning a letter to each link using avy. ([[https://github.com/abo-abo/ace-link][source]])
#+end_quote

#+begin_src emacs-lisp
(use-package ace-link
  :config (ace-link-setup-default))
#+end_src

** Edit Points

Use [[http://www.emacswiki.org/emacs/GotoChg][goto-chg]] to jump through edit points ([[http://pragmaticemacs.com/emacs/move-through-edit-points/][source]])

#+begin_src emacs-lisp
(use-package goto-chg
  :config (setq glc-default-span 32)
  :bind (("C-c j ," . goto-last-change)
         ("C-c j ." . goto-last-change-reverse)))
#+end_src

*Tip* =C-u 0 C-c j ,= description of the change at a particular stop on your tour

** Visual Bookmarks

([[http://pragmaticemacs.com/emacs/use-visible-bookmarks-to-quickly-jump-around-a-file/][source]])

#+begin_src emacs-lisp
(use-package bm
  :bind (("C-c j b ." . bm-next)
         ("C-c j b ," . bm-previous)
         ("C-c j b SPC" . bm-toggle)))
#+end_src

* Snippets
** YaSnippet

#+begin_quote
[[https://github.com/capitaomorte/yasnippet][YASnippet]] is a template system for Emacs. It allows you to type an abbreviation and automatically expand it into function templates. ([[https://github.com/capitaomorte/yasnippet][source]])
#+end_quote

Also, see [[http://emacsrocks.com/e06.html][Emacs Rocks #06]] which is on ~yasnippet~.

You can call ~yas-decribe-tables~ to see currently defined snippets, I usually just use [[Helm YaSnippet]].

We disable yasnippet if there are no snippets. ([[https://github.com/joaotavora/yasnippet/issues/669][source]])

#+begin_src emacs-lisp
(use-package yasnippet
  :blackout yas-minor-mode
  :config (progn
            (yas-global-mode)
            (setq yas-verbosity 1)

            (defun malb/disable-yas-if-no-snippets ()
              (when (and yas-minor-mode (null (yas--get-snippet-tables)))
                (yas-minor-mode -1)))

            ;; create alias for -ts-modes
            (let (did-create)
              (dolist (mode '("c" "c++" "python"))
                (let* ((src-mode (concat mode "-mode"))
                       (dst-dir (expand-file-name  (concat mode "-ts-mode") yasnippet-snippets-dir))
                       (dst-file (expand-file-name ".yas-parents" dst-dir)))
                  (when (not (file-exists-p dst-dir))
                    (mkdir dst-dir))
                  (when (not (file-exists-p dst-file))
                    (setq did-create t)
                    (with-temp-buffer
                      (insert src-mode)
                      (insert "\n")
                      (write-file dst-file)))))
              (when did-create
                (yas-reload-all)))

            (add-hook 'yas-minor-mode-hook #'malb/disable-yas-if-no-snippets)))
#+end_src

The official yasnippet snippet collection

#+begin_src emacs-lisp
(use-package yasnippet-snippets)
#+end_src

*** Auto YASnippet

#+BEGIN_QUOTE
[[https://github.com/abo-abo/auto-yasnippet][auto-yasnippet]] is a hybrid of keyboard macros and yasnippet. You create the snippet on the go, usually to be used just in the one place. It's fast, because you're not leaving the current buffer, and all you do is enter the code you'd enter anyway, just placing ~ where you'd like yasnippet fields and mirrors to be.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package auto-yasnippet
  :bind (("C-c y c" . aya-create)
         ("C-c y e" . aya-expand)))
#+end_src

*** Auto Insert

We populate empty files with yasnippet ([[https://github.com/hlissner/.emacs.d/blob/master/core/core-autoinsert.el][source]])

#+begin_src emacs-lisp
(defun malb/auto-insert-snippet (key &optional mode)
  "Auto insert a snippet of yasnippet into new file."
  (interactive)
  (let ((is-yasnippet-on (not (cond ((functionp yas-dont-activate-functions)
                                     (funcall yas-dont-activate-functions))
                                    ((consp yas-dont-activate-functions)
                                     (some #'funcall yas-dont-activate-functions))
                                    (yas-dont-activate-functions))))
        (snippet (let ((template (cdar (mapcan #'(lambda (table) (yas--fetch table key))
                                               (yas--get-snippet-tables mode)))))
                   (if template (yas--template-content template) nil))))
    (when (and is-yasnippet-on snippet)
      (yas-expand-snippet snippet))))
#+end_src

#+begin_src emacs-lisp
(use-package autoinsert
  :after yasnippet
  :config (progn
            (setq auto-insert-query nil ; Don't prompt before insertion
                  auto-insert-alist '()) ; Tabula rasa
            (auto-insert-mode 1)))
#+end_src

*** Helm YaSnippet

[[https://github.com/emacs-jp/helm-c-yasnippet][helm-c-yasnippet]] for selecting snippets with helm. However, long-form snippets are mostly handled by [[https://github.com/Kungsgeten/yankpad][yankpad]].

#+begin_src emacs-lisp
(use-package helm-c-yasnippet
  :after (helm yasnippet)
  :commands (helm-yas-complete)
  :bind (:map yas-minor-mode-map
              ("C-c h y" .  helm-yas-complete))
  :config (progn
            (setq helm-yas-space-match-any-greedy t)))
#+end_src

** Yankpad

#+begin_quote
Let’s say that you have text snippets that you want to paste, but that yasnippet or skeleton is a bit too much when you do not need a shortcut/abbrev for your snippet. You like org-mode, so why not write your snippets there? Introducing the yankpad: — ([[https://github.com/Kungsgeten/yankpad/blob/master/README.org][source]])
#+end_quote

#+begin_src emacs-lisp
(use-package yankpad
  :after (helm yasnippet projectile)
  :init (setq yankpad-file (expand-file-name "yankpad.org" malb/org-files-dir))
  :config (progn
            (bind-key "C-c h Y" #'yankpad-insert yas-minor-mode-map)

            ;; yankpad can slow down helm by insisting on parsing the yankpad file each time, so
            ;; we disable it for helm
            (setq malb/disable-yankpad-major-modes
                  '(helm-major-mode
                    minibuffer-inactive-mode
                    dired-mode
                    dired-sidebar-mode
                    gnus-article-mode
                    mu4e-view-mode))

            (defun malb/yp-date (fmt &optional read)
              (unless yas-modified-p
                (format-time-string fmt (org-read-date nil t read))))

            (define-advice yankpad-local-category-to-major-mode
                (:around (old-function &rest args) malb/disable-yankpad-maybe)
              (if (member major-mode malb/disable-yankpad-major-modes)
                  nil
                (apply old-function args)))))
#+end_src

* Auto Completion (Company)

Use [[https://github.com/company-mode/company-mode][company-mode]] for auto-completion.

[[https://company-mode.github.io/images/company-elisp.png]] ([[https://company-mode.github.io/images/company-elisp.png][source]])

#+begin_src emacs-lisp
(use-package company
  :bind (("M-/" . company-complete)
         :map company-active-map
         ("C-n" . company-select-next)
         ("C-p" . company-select-previous)
         ("TAB" . company-complete)
         ("M-?" . company-show-doc-buffer)
         ("M-." . company-show-location))
  :custom ((company-tooltip-limit 20 "bigger popup window")
           (company-idle-delay 0.6 "delay for popup")
           (company-echo-delay 0 "remove blinking")
           (company-show-numbers t "show numbers for easy selection")
           (company-abort-on-unique-match nil)
           (company-selection-wrap-around t)
           (company-require-match nil)
           (company-dabbrev-ignore-case nil)
           (company-dabbrev-ignore-invisible t)
           (company-dabbrev-other-buffers t)
           (company-dabbrev-downcase nil)
           (company-dabbrev-code-everywhere t)
           (company-tooltip-align-annotations t)
           (company-minimum-prefix-length 1)
           (company-global-modes '(not) "company is 'always on', except for a few … exceptions")
           (company-lighter-base ""))
  :demand t
  :config (global-company-mode 1))
#+end_src

Use [[https://github.com/expez/company-quickhelp][company-quickhelp]] to display quick help.

#+begin_src emacs-lisp
(use-package company-quickhelp
  :config (company-quickhelp-mode 1))
#+end_src

** Python

For Python use [[https://github.com/proofit404/company-anaconda][company-anaconda]].

#+begin_src emacs-lisp
(use-package company-anaconda
  :config (add-to-list 'company-backends #'company-anaconda))
#+end_src

** LaTeX

For \LaTeX use [[https://github.com/alexeyr/company-auctex][company-auctex]]. We also allow unicode symbols via [[https://github.com/vspinu/company-math][company-math]], hence we manage what to add when carefully below.

#+begin_src emacs-lisp
(use-package company-math
  :config (progn
            ;; mu4e might disable it for address completion
            (defun malb/enforce-case-sensitive (orig-function &rest arguments)
              (let ((completion-ignore-case nil))
                (apply orig-function arguments)))

            (require 'math-symbol-lists)
            (setq math-symbol-list-extended
                  (remove '("mathrel" "\\coloneq" 8788 "≔") math-symbol-list-extended))
            (push '("mathrel" "\\coloneqq" 8788 "≔") math-symbol-list-extended)

            (setq company-math--symbols
                  (delete-dups
                   (append (company-math--make-candidates math-symbol-list-basic company-math-symbol-prefix)
                           (company-math--make-candidates math-symbol-list-extended company-math-symbol-prefix))))

            (advice-add #'company-math-symbols-latex :around #'malb/enforce-case-sensitive)
            (advice-add #'company-math-symbols-unicode :around #'malb/enforce-case-sensitive)))

(use-package company-auctex)
#+end_src

[[https://github.com/TheBB/company-reftex][company-refex]] is used for \LaTeX labels.

#+begin_src emacs-lisp
(use-package company-reftex)
#+end_src

BibTeX is handled by Helm BibTeX below.

** Shell

Use [[https://github.com/Ambrevar/emacs-fish-completion][fish-completion]] for =pcomplete= which is then used by =company-capf=

#+begin_src emacs-lisp
(use-package fish-completion
  :config (progn
            (global-fish-completion-mode)))
#+end_src

** Company and YaSnippet Integration

Add YasSippet support for all company backends. ([[https://github.com/syl20bnr/spacemacs/pull/179][source]])

*Note:* Do this at the very end.

#+begin_src emacs-lisp
(defvar malb/company-mode/enable-yas t
  "Enable yasnippet for all backends.")

(defun malb/company-mode/backend-with-yas (backend)
  (if (or (not malb/company-mode/enable-yas)
          (and (listp backend)
               (member 'company-yasnippet backend)))
      backend
    (append (if (consp backend) backend (list backend))
            '(:with company-yasnippet))))

(defun malb/activate-yasnippet-completion ()
  (setq company-backends
        (mapcar #'malb/company-mode/backend-with-yas company-backends)))

(add-hook 'emacs-startup-hook #'malb/activate-yasnippet-completion)
#+end_src

* Tab DWIM

1. =yas-expand= is run first and does what it has to, then it calls =malb/indent-fold-or-complete=.

2. This function then hopefully does what I want:

   1. if a region is active, just indent
   2. if we’re looking at a space after a non-whitespace character, we try some company-expansion
   3. If =hs-minor-mode= or =outline-minor-mode= is active, try those next
   4. otherwise call whatever would have been called otherwise.

([[http://emacs.stackexchange.com/q/21182/8930][source]], [[http://emacs.stackexchange.com/q/7908/8930][source]])

#+begin_src emacs-lisp
(use-package outline-magic
  :config (unbind-key "<tab>" outline-mode-map))

(defun malb/indent-fold-or-complete (&optional arg)
  (interactive "P")
  (cond
   ;; if a region is active, indent
   ((use-region-p)
    (indent-region (region-beginning)
                   (region-end)))

   ;; always fold if we're looking at an org heading
   ((and (eq major-mode 'org-mode)
         (or (org-at-drawer-p)
             (org-at-heading-p)))
    (save-excursion (org-cycle)))

   ;; always use table actions in org tables
   ((and (eq major-mode 'org-mode) (org-table-p))
    (save-excursion (call-interactively 'orgtbl-tab)))

   ;; leave the math env
   ((and (or (and (eq major-mode 'org-mode) (bound-and-true-p org-cdlatex-mode))
             (and (eq major-mode 'LaTeX-mode) (bound-and-true-p cdlatex-mode)))
         (texmathp)
         ;; (or (looking-at "\\\\)")
         ;;     (looking-at "\\]")
         ;;     (looking-at "}"))
         )
    (cdlatex-tab))

   ;; arg triggers cdlatex
   ((or
     (and (eq major-mode 'org-mode) (bound-and-true-p org-cdlatex-mode) arg)
     (and (eq major-mode 'LaTeX-mode) (bound-and-true-p cdlatex-mode) arg))
    (cdlatex-tab))

   ;; if the next char is space or eol, but prev char not whitespace
   ((and (not (active-minibuffer-window))
         (or (looking-at " ")
             (looking-at "$"))
         (looking-back "[^[:space:]]" nil)
         (not (and (eq major-mode 'org-mode) (looking-back "<[a-z]+" nil)))
         (not (looking-back "^" nil)))
    (company-complete-common))

   ;; no whitespace anywhere
   ((and (not (active-minibuffer-window))
         (looking-at "[^[:space:]]")
         (looking-back "[^[:space:]]" nil)
         (not (looking-back "^" nil)))
    (cond ((bound-and-true-p cdlatex-mode) (cdlatex-tab))
          ((bound-and-true-p hs-minor-mode) (save-excursion (end-of-line) (hs-toggle-hiding)))
          ((bound-and-true-p outline-minor-mode) (save-excursion (outline-cycle)))))

   ;; by default just call whatever was bound
   (t
    (let ((fn (or (lookup-key (current-local-map) (kbd "TAB"))
                  'indent-for-tab-command)))
      (if (not (called-interactively-p 'any))
          (fn arg)
        (setq this-command fn)
        (call-interactively fn))))))

(bind-key "TAB" #'malb/indent-fold-or-complete)
#+end_src

Sometimes, you just want to fold.

#+begin_src emacs-lisp
(defun malb/toggle-fold ()
  (interactive)
  (cond ((eq major-mode 'org-mode)
         (org-force-cycle-archived))
        ((bound-and-true-p hs-minor-mode)
         (save-excursion
           (end-of-line)
           (hs-toggle-hiding)))

        ((bound-and-true-p outline-minor-mode)
         (save-excursion
           (outline-cycle)))))

(bind-key "C-<tab>" #'malb/toggle-fold)
#+end_src

* Helm

[[https://github.com/emacs-helm/helm][Helm]] is incremental completion and selection narrowing framework for Emacs.

[[https://tuhdo.github.io/static/helm_projectile.gif]] ([[https://tuhdo.github.io/helm-intro.html][source]])

See [[https://tuhdo.github.io/helm-intro.html][A Package in a league of its own: Helm]] for a nice introduction.

** General, Buffers, Files

Don’t use the vanilla =helm-buffers= command for =C-x C-b= but combine many sources to create =malb/helm-omni.= ([[http://stackoverflow.com/a/19284509][source]])

*Tip:* Use =@foo= to search for content =foo= in buffers when in =helm-omni=. Use =*lisp= to search for buffers in ~lisp-mode~. Use =*!list= to search for buffers not in ~lisp-mode~.

#+begin_src emacs-lisp
(defun malb/helm-omni (&rest arg)
  ;; just in case someone decides to pass an argument, helm-omni won't fail.
  (interactive)
  (unless helm-source-buffers-list
    (setq helm-source-buffers-list
          (helm-make-source "Buffers" 'helm-source-buffers)))
  (let ((helm-display-function #'helm-display-buffer-in-own-frame))
    (helm-other-buffer
     (append

      (if (projectile-project-p)
          '(helm-source-projectile-buffers-list
            helm-source-files-in-current-dir
            helm-source-projectile-recentf-list)
        '(helm-source-buffers-list
          helm-source-files-in-current-dir
          helm-source-recentf)) ;; list of all open buffers

      `(((name . "Tabs")
         (candidates . ,(mapcar (lambda (tab)
                                  (cdr (assq 'name tab)))
                                (tab-bar-tabs)))
         (action . (lambda (candidate)
                     (tab-bar-switch-to-tab candidate)))))

      '(helm-source-bookmarks)

      (when (projectile-project-p)
        '(helm-source-buffers-list
          helm-source-recentf))

      '(helm-source-buffer-not-found) ;; ask to create a buffer otherwise
      )

     "*Helm all the things*")))
#+end_src

Use helm for switching buffers, opening files, calling interactive functions.

The default ~C-x c~ is quite close to =C-x C-c=, which quits Emacs. Changed to =C-c h=. We must set =C-c h= globally, because we cannot change =helm-command-prefix-key= once =helm-autoloads= is loaded. ([[https://github.com/tuhdo/emacs-c-ide-demo/blob/master/custom/setup-helm.el][source]])

We also use ~(helm-all-mark-rings)~ to jump around marks (set with =C-SPC C-SPC= et al.).

#+begin_src emacs-lisp
(use-package helm
  :blackout helm-mode
  :bind (("M-x"       . helm-M-x)
         ("C-x C-b"   . malb/helm-omni)
         ("C-x b"     . malb/helm-omni)
         ("C-x C-f"   . helm-find-files)
         ("C-c <SPC>" . helm-all-mark-rings)
         ("C-c h"     . helm-command-prefix)

         :map helm-map
         ("TAB" . helm-execute-persistent-action) ;; rebind tab to do persistent action
         ("C-i"   . helm-execute-persistent-action) ;; make TAB works in terminal
         ("C-z"   . helm-select-action)             ;; list actions using C-z
         ("C-<right>" . helm-next-source)
         ("C-<left>" . helm-previous-source))

  :custom
  (helm-ff-keep-cached-candidates nil) ;; https://issues.guix.gnu.org/43406
  (helm-completion-style 'emacs)
  ;; (helm-external-programs-associations '(("pdf" . "okular")
  ;;                                        ("docx" . "libreoffice")))

  :config (progn
            (require 'helm-for-files)
            (require 'helm-bookmark)
            (unbind-key "C-x c")

            (setq helm-adaptive-mode t
                  helm-bookmark-show-location t
                  helm-buffers-maybe-switch-to-tab t
                  helm-buffer-max-length 48
                  helm-display-header-line t
                  helm-ff-skip-boring-files t
                  helm-find-files-ignore-thing-at-point t
                  helm-input-idle-delay 0.01
                  helm-window-prefer-horizontal-split t
                  helm-quick-update t
                  helm-split-window-inside-p t
                  helm-truncate-lines nil
                  helm-ff-auto-update-initial-value nil
                  helm-grep-default-command "ag --vimgrep -z %p %f"
                  helm-grep-default-recurse-command "ag --vimgrep -z %p %f"

                  helm-use-frame-when-more-than-two-windows nil
                  helm-display-buffer-reuse-frame t ;; https://github.com/emacs-helm/helm/issues/2416
                  helm-display-function #'helm-default-display-buffer
                  helm-display-buffer-width 180
                  helm-display-buffer-height (ceiling (/ (alist-get 'height default-frame-alist) 1.61))
                  helm-use-undecorated-frame-option nil
                  helm-file-cache-fuzzy-match t
                  helm-projectile-fuzzy-match nil
                  helm-locate-fuzzy-match     nil
                  helm-imenu-fuzzy-match      t
                  helm-recentf-fuzzy-match    nil)

            (when (executable-find "curl")
              (setq helm-net-prefer-curl t))

            (helm-mode t)

            ;; manipulating these lists must happen after helm-mode was called
            (add-to-list 'helm-boring-buffer-regexp-list "\\*CEDET Global\\*")

            (delete "\\.bbl$" helm-boring-file-regexp-list)
            (add-to-list 'helm-boring-file-regexp-list "\\.nav" t)
            (add-to-list 'helm-boring-file-regexp-list "\\.out" t)
            (add-to-list 'helm-boring-file-regexp-list "\\.snm" t)
            (add-to-list 'helm-boring-file-regexp-list "\\.synctex.gz" t)
            (add-to-list 'helm-boring-file-regexp-list "\\.fdb_latexmk" t)
            (add-to-list 'helm-boring-file-regexp-list "\\.fls" t)
            (add-to-list 'helm-boring-file-regexp-list "-blx\\.bib" t)
            (add-to-list 'helm-boring-file-regexp-list "texput\\.log" t)

            ;; see https://github.com/emacs-helm/helm/commit/1de1701c73b15a86e99ab1c5c53bd0e8659d8ede
            (assq-delete-all 'find-file helm-completing-read-handlers-alist)

            (add-to-list 'helm-commands-using-frame #'helm-bookmarks)

            (defun malb/back-to-current-frame-advice (old-function &rest arguments)
              (let* ((current-frame (selected-frame))
                     (current-frame-list (frame-list)))
                (cl-letf (((symbol-function 'frame-list)
                           (lambda () (cons current-frame
                                            (remove current-frame current-frame-list)))))
                  (apply old-function arguments))))))
#+end_src

Actions for attaching files to e-mails and for sending them with [[https://transfer.sh/][transfer.sh]].

#+begin_src emacs-lisp
(use-package helm-utils
  :ensure nil
  :after transfer-sh
  :config (progn
            (defun malb/helm-mml-attach-files (_candidate)
              "Attach all selected files"
              (let* ((files (helm-marked-candidates)))
                (mapcar 'mml-attach-file files)))

            (defun malb/helmified-mml-attach-files ()
              (interactive)
              (with-helm-alive-p
                (helm-exit-and-execute-action 'malb/helm-mml-attach-files)))

            (defun malb/helm-transfer-sh-files (_candidate)
              "Transfer.sh all selected files"
              (let* ((files (helm-marked-candidates)))
                (mapcar (lambda (file)
                          (transfer-sh-upload-file-async file (file-name-nondirectory file)))
                        files)))

            (defun malb/helmified-transfer-sh-files ()
              (interactive)
              (with-helm-alive-p
                (helm-exit-and-execute-action 'malb/helm-transfer-sh-files)))

            ;; (helm-add-action-to-source "Attach to E-mail" #'malb/helm-mml-attach-files helm-source-find-files)
            ;; (helm-add-action-to-source "Transfer.sh"      #'malb/helm-transfer-sh-files helm-source-find-files)
            ))
#+end_src

** Helm Ring

=helm-ring= makes the kill ring actually useful, let’s use it.

#+begin_src emacs-lisp
(use-package helm-ring
  :ensure nil
  :bind (("C-c j /" . helm-global-mark-ring)
         ("M-y" . helm-show-kill-ring)))
#+end_src

** Helm Swoop

[[https://github.com/ShingoFukuyama/helm-swoop][helm-swoop]] for buffer searching.

[[https://raw.githubusercontent.com/ShingoFukuyama/images/master/helm-swoop.gif]] ([[https://github.com/ShingoFukuyama/helm-swoop][source]])

*Tip*: You can edit =helm-swoop= buffers by pressing =C-c C-e=.

#+begin_src emacs-lisp
(use-package helm-swoop
  :bind (("C-c o" . helm-multi-swoop-org)
         ("C-s"   . malb/swoop-or-search))
  :config (progn

            (setq malb/helm-swoop-ignore-major-mode
                  '(dired-mode
                    paradox-menu-mode
                    doc-view-mode
                    pdf-view-mode
                    mu4e-headers-mode
                    org-mode
                    Man-mode
                    helpful-mode
                    markdown-mode
                    LaTeX-mode
                    sage-shell-mode
                    inferior-python-mode
                    ein:notebook-multilang-mode
                    imenu-list-major-mode
                    messages-buffer-mode
                    nov-mode
                    ollama-shell-mode
                    comint-mode))

            ;; I’m going back and forth what I prefer
            (setq helm-swoop-pre-input-function  #'malb/helm-swoop-pre-fill
                  helm-swoop-split-with-multiple-windows t
                  helm-swoop-speed-or-color t)

            (defun malb/helm-swoop-pre-fill ()
              ;; (thing-at-point 'symbol)
              )

            (defun malb/swoop-or-search ()
              (interactive)
              (if (or (> (buffer-size) 1048576) ;; helm-swoop can be slow on big buffers
                      (memq major-mode malb/helm-swoop-ignore-major-mode))
                  (call-interactively #'isearch-forward-regexp)
                (helm-swoop)))

            ;; https://emacs.stackexchange.com/questions/28790/helm-swoop-how-to-make-it-behave-more-like-isearch
            (defun malb/helm-swoop-C-s ()
              (interactive)
              (if (boundp 'helm-swoop-pattern)
                  (if (equal helm-swoop-pattern "")
                      (previous-history-element 1)
                    (helm-next-line))
                (helm-next-line)))

            (bind-key "M-i" #'helm-swoop-from-isearch isearch-mode-map)
            (bind-key "M-i" #'helm-multi-swoop-all-from-helm-swoop helm-swoop-map)
            (bind-key "C-r"   #'helm-previous-line helm-swoop-map)
            (bind-key "C-s"   #'malb/helm-swoop-C-s helm-swoop-map)
            (bind-key "C-r"   #'helm-previous-line helm-multi-swoop-map)
            (bind-key "C-s"   #'malb/helm-swoop-C-s helm-multi-swoop-map)))
#+end_src

** Helm Ag

[[http://beyondgrep.com][Ack]] is “a tool like grep, optimized for programmers“. [[https://github.com/ggreer/the_silver_searcher][Ag]] is like =ack=, but faster. [[https://github.com/syohex/emacs-helm-ag][Helm-ag]] is a helm interface to =ag=. We use =helm-ag= mainly via =helm-projectile-ag=, which allows us to =grep= through all project files quickly.

[[https://raw.githubusercontent.com/syohex/emacs-helm-ag/master/image/helm-do-ag.gif]] ([[https://raw.githubusercontent.com/syohex/emacs-helm-ag/master/image/helm-do-ag.gif][source]])

*Note:* You can switch to edit mode with =C-c C-e=.

*Passing command line options and pattern*

#+begin_src
Pattern: -Gmd$ search_pattern
#+end_src

Command line options is =-Gmd$= and search pattern is =search_pattern=. =helm-ag= treats words which starts with =-=  as command line option.

*Pattern contains space (=helm-do-ag=)*

#+begin_src
Pattern: foo\ bar\ baz

#+end_src

Search pattern is =foo\ bar\ baz= . You need to escape spaces with backslash.

In =helm-ag=, you need not to escape spaces.

*Pattern starts with =-=*

#+begin_src
Pattern: -- --count
#+end_src

Search pattern is =--count=. =helm-ag= treats words after =--=  as search pattern.

*Search meta characters as literal*

=ag= ( =ack=, =pt= ) takes Perl compatible PCRE so that you need to escape meta characters likes brackets, braces, asterisk, when you search them as literals.

*Use short option*

Don't use space between option and its value. For example =-tcpp= is ok, =-t cpp=  is not ok.

*Use long option*

Please always use ~=~ separator for using long option. Don't use space as separator. For example ~--ignore=pattern~ is ok, =--ignore pattern=  is not ok.

#+begin_src emacs-lisp
(use-package helm-ag
  :commands (helm-ag helm-do-ag malb/helm-ag-projects malb/helm-ag-literature malb/helm-ag)
  :ensure-system-package ((ag . silversearcher-ag)
                          (rg . ripgrep))
  :config (progn
            (setq helm-ag-base-command "ag --nocolor --nogroup"
                  helm-ag-command-option nil
                  helm-ag-insert-at-point 'symbol
                  helm-ag-fuzzy-match t
                  helm-ag-use-temp-buffer t
                  helm-ag-use-grep-ignore-list t
                  helm-ag-use-agignore t)

            (defun malb/helm-ag (dir)
              "run helm-ag in DIR."
              (let* ((ignored (mapconcat (lambda (i)
                                           (if (string-prefix-p "ag" helm-ag-base-command)
                                               (concat "--ignore " i)
                                             (concat "-g !" i)))
                                         (append grep-find-ignored-files grep-find-ignored-directories)
                                         " "))
                     (helm-ag-base-command (concat helm-ag-base-command " " ignored)))
                (helm-do-ag (file-name-as-directory dir))))

            (defun malb/helm-ag-projects ()
              "run helm-ag in projects directory."
              (interactive)
              (malb/helm-ag malb/projects-dir))

            (defun malb/helm-ag-literature ()
              "run helm-ag in projects directory"
              (interactive)
              (malb/helm-ag (file-name-as-directory (car malb/literature-dirs))))))
#+end_src

** Helm Descbinds

#+begin_src emacs-lisp
(use-package helm-descbinds
  :bind ("C-h b" . helm-descbinds)
  :init (fset 'describe-bindings 'helm-descbinds))
#+end_src

** Helm Locate

#+begin_src emacs-lisp
(use-package helm-locate
  :ensure nil
  :after (helm helm-utils)
  :commands helm-locate
  :bind (:map helm-generic-files-map
              ("C-c C-a" . malb/helmified-mml-attach-files)
              ("C-c C-t" . malb/helmified-transfer-sh-files))
  :config (progn
            (add-to-list 'helm-commands-using-frame 'helm-locate)
            (helm-add-action-to-source "Attach to E-mail" #'malb/helm-mml-attach-files helm-source-locate)
            (helm-add-action-to-source "Transfer.sh"      #'malb/helm-transfer-sh-files helm-source-locate)))
#+end_src

** Helm Org

[[https://github.com/alphapapa/org-ql][org-ql]]

#+begin_src emacs-lisp
(use-package helm-org
  :after org-agenda
  :config (progn
            (setq helm-org-headings-fontify t)

            (defun malb/helm-in-buffer ()
              "The right kind™ of buffer menu."
              (interactive)

              (push-mark)

              (cond ((eq major-mode 'org-mode)
                     (call-interactively #'helm-org-in-buffer-headings))
                    ((bound-and-true-p lsp-mode)
                     (call-interactively #'helm-lsp-workspace-symbol))
                    (t
                     (call-interactively #'helm-semantic-or-imenu))))

            (add-to-list 'helm-commands-using-frame 'helm-org-in-buffer-headings)
            ;; TODO advice malb/helm-in-buffer
            (advice-add #'helm-org-in-buffer-headings :around #'malb/back-to-current-frame-advice)
            (advice-add #'helm-lsp-workspace-symbol :around #'malb/back-to-current-frame-advice)
            (advice-add #'helm-semantic-or-imenu :around #'malb/back-to-current-frame-advice)

            (add-to-list 'helm-commands-using-frame 'helm-semantic-or-imenu)
            (add-to-list 'helm-commands-using-frame 'helm-org-agenda-files-headings)

            (add-to-list 'helm-completing-read-handlers-alist '(org-capture . helm-org-completing-read-tags))
            (add-to-list 'helm-completing-read-handlers-alist '(org-set-tags . helm-org-completing-read-tags))))
#+end_src

#+begin_src emacs-lisp
(use-package helm-org-ql
  :after helm-org
  :config (progn
            (defun malb/helm-org-ql-agenda-files (arg)
              (interactive "p")

              (push-mark)

              (let ((current-prefix-arg nil))
                (cond
                 ((equal arg 4) (call-interactively #'helm-org-ql-agenda-files nil))
                 (t (helm-org-agenda-files-headings)))))

            (advice-add #'helm-org-agenda-files-headings :around #'malb/back-to-current-frame-advice)

            (add-to-list 'helm-commands-using-frame 'helm-org-ql)
            (add-to-list 'helm-commands-using-frame 'helm-org-ql-agenda-files)))
#+end_src

** Helm DuckDuckGo

[[./local/helm-ddgr.el][helm-ddgr]] for doing [[https://github.com/jarun/ddgr][ddgr]] based DuckDuckGo searches.

#+begin_src emacs-lisp
(use-package helm-ddgr
  :ensure nil
  :after helm
  :commands helm-ddgr-return
  :bind ("C-c h g" . helm-ddgr))
#+end_src

** Helm XRef

[[https://github.com/brotzeit/helm-xref][Helm interface for xref results]]

#+begin_src emacs-lisp
(use-package helm-xref)
#+end_src

** Helm KDE Desktop Search with Baloo

[[https://community.kde.org/Baloo][Baloo]] is KDE’s desktop search. Below, we implement a tiny helm interface for it.

#+begin_src emacs-lisp
(use-package helm-baloo
  :ensure nil
  :ensure-system-package ((baloosearch . baloo-kf5))
  :config (progn
            (add-to-list 'helm-commands-using-frame 'helm-baloo-no-directory)
            (add-to-list 'helm-commands-using-frame 'helm-baloo-in-directory)))
#+end_src

** Tips

| *Key Binding* | *Action*                                 |
|---------------+------------------------------------------|
| ~C-c <tab>~   | =helm-copy-to-buffer=                    |
| ~C-u C-c C-k~ | =helm-kill-selection-and-quit=           |
| ~C-w~         | yank thing-at-point/word into minibuffer |

* History
** Recent Files

Don’t include boring or remote stuff in list of recently visited files.

#+begin_src emacs-lisp
(use-package recentf
  :after helm
  :config  (progn
             (setq recentf-max-saved-items 64
                   recentf-exclude (list "COMMIT_EDITMSG"
                                         "~$"
                                         "/tmp/"
                                         "/ssh:"
                                         "/sudo:"
                                         malb/maildir-path
                                         "/scp:"))
             (cl-loop for ext in helm-boring-file-regexp-list
                      do (add-to-list 'recentf-exclude ext t))))
#+end_src

** Saveplace

#+begin_src emacs-lisp
(save-place-mode 1)
#+end_src

** Commands

Make command history persistent ([[http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html][source]])

#+begin_src emacs-lisp
(setq history-length 1024
      history-delete-duplicates t
      savehist-save-minibuffer-history nil
      savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
(savehist-mode t)
#+end_src


** Bookmarks

#+begin_src emacs-lisp
(use-package bookmark
  :ensure nil
  :defer nil
  :init (setq bookmark-save-flag 1
              bookmark-fontify nil
              bookmark-set-fringe-mark nil)
  :config (progn
            (malb/defadvice! malb/open-bookmarks-in-tab (orig-function bookmark &optional display-func)
              :around #'bookmark-jump
              (let ((tab-created nil)
                    (tab-name (or (cdr (assoc bookmark malb/switch-tab-bookmark-names))
                                  bookmark)))
                (if (member tab-name (mapcar (lambda (tab) (cdr (assq 'name tab)))
                                             (tab-bar-tabs)))
                    (tab-bar-switch-to-tab tab-name)
                  (progn
                    (tab-new)
                    (setq tab-created t)
                    (tab-rename tab-name)))

                (apply orig-function bookmark display-func)

                (when tab-created
                  (delete-other-windows))))

            (require 'dash)
            (malb/defadvice! malb/kill-bookmark-tab-maybe (orig-function &optional buffer-or-name)
              :around #'kill-buffer
              ;; record state
              (let ((pre-buffers (mapcar #'buffer-file-name (buffer-list))))
                ;; call it
                (apply orig-function (list buffer-or-name))
                ;; did we call it directly?
                (when (called-interactively-p 'interactive)
                  ;; record state
                  (let ((-compare-fn (lambda (x y) (string= x y)))
                        (post-buffers (mapcar #'buffer-file-name (buffer-list))))
                    ;; for all buffers that were closed
                    (dolist (buf-file-name (-difference pre-buffers post-buffers))
                      ;; check if they are in the bookmark list
                      (dolist (bm bookmark-alist)
                        (let ((bm-name (car bm))
                              (bm-file-name (expand-file-name (alist-get 'filename (cdr bm)))))
                          (when (string-equal bm-file-name buf-file-name)
                            ;; find out what tab-name they'd have
                            (let ((tab-name (or (cdr (assoc bm-name malb/switch-tab-bookmark-names))
                                                bm-name)))
                              (when (member tab-name (mapcar (lambda (tab) (cdr (assq 'name tab)))
                                                             (tab-bar-tabs)))
                                (tab-close (tab-bar--tab-index-by-name tab-name))
                                ))))))))))
            ))
#+end_src

* IMenu

Make sure to auto automatically rescan for imenu change.

#+begin_src emacs-lisp
(set-default 'imenu-auto-rescan t)
#+end_src

[[https://github.com/vspinu/imenu-anywhere][IMenu items for all buffers]] with the same major mode as the current one.

#+begin_src emacs-lisp
(use-package imenu-anywhere
  :config (progn
            (defun malb/imenu-anywhere (arg)
              "Call `helm-imenu-anywhere'

- With no prefix, call with default configuration,
- with one prefix argument, call `helm-imenu-anywhere' on all programming mode buffers regardless of project,
- with two prefix arguments, call `helm-imenu-anywhere' on all buffers."
              (interactive "p")
              (cond
               ((equal arg 4)
                (let ((imenu-anywhere-buffer-filter-functions
                       `((lambda (current other)
                           (let ((parent (buffer-local-value 'major-mode other)))
                             (while (and (not (memq parent '(prog-mode c-mode c-ts-mode c++-mode c++-ts-mode)))
                                         (setq parent (get parent 'derived-mode-parent))))
                             parent)))))
                  (call-interactively #'helm-imenu-anywhere)))

               ((equal arg 16)
                (let ((imenu-anywhere-buffer-filter-functions '((lambda (current other) t))))
                  (call-interactively #'helm-imenu-anywhere)))

               (t (call-interactively #'helm-imenu-anywhere))))
            (add-to-list 'helm-commands-using-frame 'helm-imenu-anywhere)))
#+end_src

[[https://github.com/bmag/imenu-list][imenu-list]] can be useful, =C-x t i=

#+begin_src emacs-lisp
(use-package imenu-list
  :after latex
  :init (progn
          ;; https://github.com/dsedivec/dot-emacs-d/blob/ddc3fec6a2a884ce4adf730a2eb255dab97834b7/recipes/imenu-list-in-side-buffer.el
          (defun malb/imenu-list-install-display-buffer ()
            "Put imenu-list buffer on a dedicated side window with a preserved size."
            (let* ((side (cl-ecase imenu-list-position
                           (above 'top)
                           (below 'bottom)
                           ((left right) imenu-list-position)))
                   (preserve-dimen (if (memq side '(left right))
                                       'window-width
                                     'window-height)))
              (setf (alist-get (concat "^" (regexp-quote imenu-list-buffer-name) "$")
                               display-buffer-alist nil nil #'equal)
                    `(display-buffer-in-side-window
                      (window-parameters  . ((no-other-window . t)
                                             (no-delete-other-windows . t)))
                      (side . ,side)
                      ;; It is not totally clear to me if `imenu-list-size' is
                      ;; supposed to be the window's body height/width or the
                      ;; window's total height/width.  The way we're using it
                      ;; here it is definitely the total, not the body.
                      ;;
                      ;; If it's supposed to be the body height/width then I
                      ;; think it might be best to pass a function as the value
                      ;; for the `window-height'/`window-width' here, and then
                      ;; have the function compute it once the imenu-list window
                      ;; has come into existence.  (See documentation for those
                      ;; alist entries in the docstring for `display-buffer'.)
                      (,preserve-dimen . ,imenu-list-size)
                      (preserve-size . ,(if (eq preserve-dimen 'window-width)
                                            '(t . nil)
                                          '(nil . t)))
                      (dedicated . t))))))
  :custom (imenu-list-idle-update-delay 0.5)
  :config (progn
            (setq imenu-list-position 'left
                  imenu-list-size 0.15
                  imenu-list-auto-resize nil
                  imenu-list-focus-after-activation nil
                  imenu-list-after-jump-hook nil)

            (malb/imenu-list-install-display-buffer)

            (malb/defadvice! malb/LaTeX-imenu-create-index-function (old-function &rest args)
              "Postprocess AucTeX's imenu list."
              :around 'LaTeX-imenu-create-index-function
              (let* ((input-list (apply old-function args))
                     (output-list '()))
                (while input-list
                  (let* ((entry (car input-list))
                         (tail  (cdr input-list))
                         (label (car entry))
                         (marker (cdr entry))
                         (prefix-len))
                    (string-match "^ *" label)
                    (setq prefix-len (match-end 0))
                    (when (not (s-equals-p label "document"))
                      (if (<= prefix-len 2)
                          (progn
                            (add-to-list 'output-list (cons (s-trim label) '()) t)
                            (setf (cdar (last output-list))
                                  (append (cdar (last output-list))
                                          (list (cons "<go to>" marker)))))
                        (setf (cdar (last output-list))
                              (append (cdar (last output-list))
                                      (list (cons (substring label (/ (+ prefix-len 4) 2)) marker))))))

                    (setq input-list tail)))
                output-list))))
#+end_src

* Parenthesis

See [[https://ebzzry.github.io/emacs-pairs.html][here]] for an introduction to [[https://github.com/Fuco1/smartparens][smartparens]].

Some of the config below is stolen from hlissner’s [[https://github.com/hlissner/.emacs.d/blob/master/core/core-editor.el][emacs.d]].

#+begin_src emacs-lisp
(use-package smartparens
  :blackout smartparens-mode
  :bind (:map smartparens-mode-map
         ("C-M-f" . sp-forward-sexp)
         ("C-M-b" . sp-backward-sexp)
         ("C-M-n" . sp-next-sexp)
         ("C-M-p" . sp-previous-sexp)
         ("C-M-d" . sp-down-sexp)
         ("C-M-u" . sp-backward-up-sexp)
         ("C-M-a" . sp-beginning-of-sexp)
         ("C-M-e" . sp-end-of-sexp)
         ("C-M-k" . sp-kill-sexp)
         ("C-M-w" . sp-copy-sexp)
         ("C-M-t" . sp-transpose-sexp)
         ("C-M-s" . sp-split-sexp)
         ("C-M-j" . sp-join-sexp)
         ("C-<right>" . sp-forward-slurp-sexp)
         ("C-<left>"  . sp-forward-barf-sexp)
         ("M-S-<backspace>" . sp-backward-unwrap-sexp)
         ("C-M-<backspace>" . sp-splice-sexp-killing-backward)
         ("C-S-<backspace>" . sp-splice-sexp-killing-around))
  :config (progn
            (require 'smartparens-config)
            (require 'smartparens-latex)
            (require 'smartparens-html)
            (require 'smartparens-python)

            (smartparens-global-mode t)
            (setq sp-autodelete-wrap t
                  sp-cancel-autoskip-on-backward-movement nil)

            (setq-default sp-autoskip-closing-pair t)

            (defun malb/sp-point-is-template-p (id action context)
              (and (sp-in-code-p id action context)
                   (sp-point-after-word-p id action context)))

            (defun malb/sp-point-after-include-p (id action context)
              (and (sp-in-code-p id action context)
                   (save-excursion
                     (goto-char (line-beginning-position))
                     (looking-at-p "[ 	]*#include[^<]+"))))

            (sp-with-modes '(c-mode c-ts-mode c++-mode c++-ts-mode)
              (sp-local-pair "<" ">"    :when '(malb/sp-point-is-template-p malb/sp-point-after-include-p))
              (sp-local-pair "/*" "*/"  :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
              (sp-local-pair "/**" "*/" :post-handlers '(("||\n[i]" "RET") ("||\n[i]" "SPC")))
              (sp-local-pair "/*!" "*/" :post-handlers '(("||\n[i]" "RET") ("[d-1]< | " "SPC"))))

            (sp-pair "\"" nil)
            (sp-pair "{"  nil :post-handlers '(("||\n[i]" "RET") ("| " " ")) :wrap "C-{")
            (sp-pair "("  nil :post-handlers '(("||\n[i]" "RET") ("| " " ")) :wrap "C-(")
            (sp-pair "["  nil :post-handlers '(("| " " ")))
            (sp-local-pair '(sh-mode markdown-mode python-mode python-ts-mode cython-mode) "`" nil)

            ;; https://github.com/Fuco1/smartparens/issues/652#issuecomment-250518705
            (defun malb/latex-replace-dollar (_id action _context)
              (when (eq action 'wrap)
                (sp-get sp-last-wrapped-region
                  (let ((at-beg (= (point) :beg-in)))
                    (save-excursion
                      (goto-char :beg)
                      (delete-char :op-l)
                      (insert "\\("))
                    (save-excursion
                      (goto-char :end-in)
                      (delete-char :cl-l)
                      (insert "\\)"))
                    (setq sp-last-wrapped-region
                          (sp--get-last-wraped-region
                           :beg :end "\\(" "\\)"))
                    (goto-char (if at-beg (1+ :beg-in) :end))))))

            (defun malb/sp-org-special-p (_id action _context)
              "Return t when point is in a special org environment."
              (when (eq action 'insert)
                (when (eq major-mode 'org-mode)
                  (org-in-block-p '("src" "example")))))

            (let ((bracket-qualifiers '(sp-point-before-word-p
                                        sp-point-before-same-p
                                        sp-latex-point-after-backslash)))
              (sp-with-modes '(tex-mode plain-tex-mode latex-mode LaTeX-mode)
                (sp-local-pair "\\(" "\\)" :unless bracket-qualifiers
                               :trigger-wrap "\$" :trigger "\$"
                               )
                (sp-local-pair  "$" "$" :unless bracket-qualifiers
                                :post-handlers '(:add malb/latex-replace-dollar))

                (sp-local-pair "\\[" "\\]" :unless bracket-qualifiers)))

            (let ((bracket-qualifiers '(sp-point-before-word-p
                                        sp-point-before-same-p
                                        sp-latex-point-after-backslash
                                        malb/sp-org-special-p)))
              (sp-with-modes '(org-mode)
                (sp-local-pair "\\(" "\\)" :unless bracket-qualifiers
                               :trigger-wrap "\$"
                               :trigger "\$"
                               )
                (sp-local-pair  "$" "$" :unless bracket-qualifiers
                                :post-handlers '(:add malb/latex-replace-dollar))

                (sp-local-pair "\\[" "\\]" :unless bracket-qualifiers)

                (sp-local-pair "_" "_"    :actions nil)
                (sp-local-pair "\"" "\""  :actions nil)
                (sp-local-pair "(" ")"    :unless bracket-qualifiers)
                (sp-local-pair "[" "]"    :unless bracket-qualifiers)
                (sp-local-pair "/" "/"    :actions nil)
                (sp-local-pair "*" "*"    :actions nil)
                (sp-local-pair "=" "="    :actions nil)
                (sp-local-pair "\"" "\""  :actions nil)
                (sp-local-pair "~" "~"    :actions nil)
                (sp-local-pair "'" "'"    :actions nil)))

            (let ((bracket-qualifiers '(sp-point-before-word-p
                                        sp-point-before-same-p)))
              (sp-with-modes '(python-mode python-ts-mode)
                (sp-local-pair  "(" ")" :unless bracket-qualifiers)
                (sp-local-pair  "[" "]" :unless bracket-qualifiers)))

            ;; https://github.com/millejoh/emacs-ipython-notebook/issues/172
            (add-to-list 'sp-ignore-modes-list 'ein:notebook-multilang-mode)
            (add-to-list 'sp-ignore-modes-list 'markdown-mode)
            (add-to-list 'sp-ignore-modes-list 'hotcrp-mode)
            (add-to-list 'sp-ignore-modes-list 'slack-message-buffer-mode)
            (add-to-list 'sp-ignore-modes-list 'sage-shell-mode)
            (add-to-list 'sp-ignore-modes-list 'jupyter-repl-mode)))
#+end_src

Automatically insert [[https://github.com/emacs-berlin/syntactic-close][closing delimiter]]

#+begin_src emacs-lisp
(use-package syntactic-close
  :bind ("C-)" . syntactic-close))
#+end_src

Use the built-in ~show-paren-mode~ to highlight matching parentheses.

#+begin_src emacs-lisp
(use-package paren
  :ensure nil
  :custom ((show-paren-style 'expression)
           (show-paren-when-point-in-periphery nil)
           (show-paren-when-point-inside-paren t)
           (show-paren-delay 0.2))
  :config (show-paren-mode 1))
#+end_src

* Editing
** Dragging Lines Around

([[https://github.com/rejeep/drag-stuff.el][source]])

#+begin_src emacs-lisp
(use-package drag-stuff
  :blackout drag-stuff-mode
  :config (progn
            (defhydra malb/hydra-drag-stuff (:color red)
              "drag stuff"
              ("<up>" drag-stuff-up "↑")
              ("<down>" drag-stuff-down "↓")
              ("SPC" nil)
              ("q" nil))
            (bind-key "C-c d" #'malb/hydra-drag-stuff/body)))
#+end_src

** Reverting Buffers

Automatically revert buffers.

#+begin_src emacs-lisp
(setq global-auto-revert-non-file-buffers t
      global-auto-revert-ignore-modes '(pdf-view-mode)
      auto-revert-verbose nil)

(global-auto-revert-mode 1)
#+end_src

** Save Buffer when Loosing Focus

[[https://github.com/Vifon/focus-autosave-mode.el][Automatically loosing focus]] can be dangerous, so only enable on per project basis, e.g.

#+begin_src emacs-lisp :tangle no
((markdown-mode . ((eval . (focus-autosave-local-mode 1)))))
#+end_src

#+begin_src emacs-lisp
(use-package focus-autosave-mode
  :blackout (focus-autosave-local-mode . " ♻"))
#+end_src

** Regular Expressions

Use [[https://github.com/benma/visual-regexp.el][visual-regexp]] for visual regular expressions. This makes Emacs regexp actually usable for me.

#+begin_src emacs-lisp
(use-package visual-regexp
  :bind (("C-c m" . vr/mc-mark)
         ("M-%" . vr/query-replace)
         ("C-%" . query-replace)
         ("C-S-s" . isearch-forward-regexp)
         ("C-S-r" . isearch-backward-regexp)))
#+end_src

([[http://howardism.org/Technical/Emacs/eshell-why.html][source]])

#+begin_src emacs-lisp
(use-package pcre2el
  :config
  (defmacro prx (&rest expressions)
    "Convert the rx-compatible regular EXPRESSIONS to PCRE.
  Most shell applications accept Perl Compatible Regular Expressions."
    `(rx-let ((integer (1+ digit))
              (float   (seq integer "." integer))
              (b256    (seq (optional (or "1" "2"))
                            (regexp "[0-9]\\{1,2\\}")))
              (ipaddr  (seq b256 "." b256 "." b256 "." b256))
              (time    (seq digit (optional digit) ":" (= 2 digit) (optional ":" (= 2 digit))))
              (email   (seq (1+ (regexp "[^,< ]")) "@" (1+ (seq (1+ (any alnum "-"))) ".") (1+ alnum)))
              (date    (seq (= 2 digit) (or "/" "-") (= 2 digit) (or "/" "-") (= 4 digit)))
              (ymd     (seq (= 4 digit) (or "/" "-") (= 2 digit) (or "/" "-") (= 2 digit)))
              (uuid    (seq (= 8 hex) "-" (= 3 (seq (= 4 hex) "-")) (= 12 hex)))
              (guid    (seq uuid)))
       (rxt-elisp-to-pcre (rx ,@expressions)))))
#+end_src

Inverse of =rx=.

#+begin_src emacs-lisp
(use-package xr)
#+end_src

** Undo

#+begin_src emacs-lisp
(use-package undo-tree
  :init (global-undo-tree-mode)
  :config (progn
            (unbind-key "C-M-_")
            (setq undo-tree-auto-save-history nil
                  undo-tree-enable-undo-in-region t
                  undo-tree-history-directory-alist
                  `(("." . ,(locate-user-emacs-file "undo-tree-cache"))))))
#+end_src

** Multiple Cursors

[[https://github.com/magnars/multiple-cursors.el][Multiple cursors]] are awesome.

[[http://i0.wp.com/pragmaticemacs.com/wp-content/uploads/2015/06/wpid-emacs-mc2.gif]] ([[http://i0.wp.com/pragmaticemacs.com/wp-content/uploads/2015/06/wpid-emacs-mc2.gif?zoom=2&w=620][source]])

Also see [[http://emacsrocks.com/e13.html][Emacs Rocks #13]], which is on ~multiple-cursors~.

([[http://endlessparentheses.com/multiple-cursors-keybinds.html?source=rss][keybinding source]])

Commands are bound to =C-x m …=

#+begin_src emacs-lisp
(use-package multiple-cursors
  :config (progn
            (defun malb/mc-typo-mode ()
              (add-to-list 'mc/unsupported-minor-modes 'typo-mode))
            (add-hook 'multiple-cursors-mode-hook #'malb/mc-typo-mode)

            (defhydra malb/hydra-multiple-cursors (:hint nil)
              "
 Up^^             Down^^           Miscellaneous           % 2(mc/num-cursors) cursor%s(if (> (mc/num-cursors) 1) \"s\" \"\")
------------------------------------------------------------------
 [_p_]   Next     [_n_]   Next     [_l_] Edit lines  [_0_] Insert numbers
 [_P_]   Skip     [_N_]   Skip     [_a_] Mark all    [_A_] Insert letters
 [_M-p_] Unmark   [_M-n_] Unmark   [_s_] Search
 [Click] Cursor at point       [_q_] Quit"
              ("l" mc/edit-lines :exit t)
              ("a" mc/mark-all-like-this :exit t)
              ("n" mc/mark-next-like-this)
              ("N" mc/skip-to-next-like-this)
              ("M-n" mc/unmark-next-like-this)
              ("p" mc/mark-previous-like-this)
              ("P" mc/skip-to-previous-like-this)
              ("M-p" mc/unmark-previous-like-this)
              ("s" mc/mark-all-in-region-regexp :exit t)
              ("0" mc/insert-numbers :exit t)
              ("A" mc/insert-letters :exit t)
              ("<mouse-1>" mc/add-cursor-on-click)
              ;; Help with click recognition in this hydra
              ("<down-mouse-1>" ignore)
              ("<drag-mouse-1>" ignore)
              ("q" nil))

            (bind-key "C-x m" #'malb/hydra-multiple-cursors/body)))
#+end_src

** Recursively Narrow

#+begin_src emacs-lisp
(use-package recursive-narrow
  :config (progn
            (defun malb/recursive-narrow-dwim-org ()
              (if (derived-mode-p 'org-mode)
                  (cond ((or (org-at-block-p) (org-in-src-block-p)) (org-narrow-to-block))
                        (t (org-narrow-to-subtree))))
              )
            (add-hook 'recursive-narrow-dwim-functions 'malb/recursive-narrow-dwim-org))
  :bind (("C-x n w" . recursive-widen)
         ("C-x n n" . recursive-narrow-or-widen-dwim)))
#+end_src

** Expand Region

See [[http://emacsrocks.com/e09.html][Emacs Rocks #9]] for an intro to [[https://github.com/magnars/expand-region.el][expand-region]]

#+begin_src emacs-lisp
(use-package expand-region
  :after (org)
  :bind ("C-\\" . er/expand-region)
  :init (setq expand-region-fast-keys-enabled nil)
  :config (progn
            (defun malb/mark-org-LaTeX-math ()
              "Mark current math environment in org-mode."
              (interactive)
              (when (texmathp)
                (let* ((pos (save-excursion
                              (+ (re-search-backward texmathp-onoff-regexp) 1))))
                  (re-search-forward texmathp-onoff-regexp)
                  (set-mark pos)
                  (exchange-point-and-mark))))

            (defun malb/mark-org-inside-LaTeX-math ()
              "Mark current math environment in org-mode."
              (interactive)
              (when (texmathp)
                (let* ((pos (save-excursion (re-search-backward texmathp-onoff-regexp)
                                            (re-search-forward texmathp-onoff-regexp))))
                  (re-search-forward texmathp-onoff-regexp)
                  (re-search-backward texmathp-onoff-regexp)
                  (forward-char)
                  (set-mark pos)
                  (exchange-point-and-mark))))

            (defun malb/add-org-mode-expansions ()
              (make-variable-buffer-local 'er/try-expand-list)
              (setq er/try-expand-list (append
                                        er/try-expand-list
                                        '(malb/mark-org-inside-LaTeX-math malb/mark-org-LaTeX-math))))
            (add-hook 'org-mode-hook #'malb/add-org-mode-expansions)))
#+end_src

Alternatively, consider

1. ~M-@~ marks a word
2. ~M-h~ marks a paragraph
3. ~C-M-@~ marks a balanced expression or s-expression
4. ~C-M-h~ marks a defun (top-level-definition)
5. ~C-x h~ marks the whole buffer

** Embrace

[[https://raw.githubusercontent.com/cute-jumper/embrace.el/master/screencasts/embrace.gif]]

https://github.com/cute-jumper/embrace.el

#+begin_src emacs-lisp
(use-package embrace
  :config (progn

            (defun malb/embrace-latex-mode-hook ()
              (embrace-add-pair ?\( "\\(" "\\)")
              (embrace-add-pair ?\[ "\\[" "\\]")
              (embrace-add-pair ?\) "(" ")")
              (embrace-add-pair ?\] "[" "]")
              (embrace-add-pair ?$  "$" "$")
              (embrace-add-pair ?£  "$$" "$$"))

            (bind-key "M-\\" #'embrace-commander)
            (add-hook 'org-mode-hook #'embrace-org-mode-hook)
            (add-hook 'LaTeX-mode-hook #'malb/embrace-latex-mode-hook)
            (add-hook 'org-mode-hook #'malb/embrace-latex-mode-hook)))
#+end_src

** Wrap Region

[[https://github.com/rejeep/wrap-region.el][Wrap Region]] is a minor mode for Emacs that wraps a region with punctuations. For "tagged" markup modes, such as HTML and XML, it wraps with tags.

([[http://pragmaticemacs.com/emacs/wrap-text-in-custom-characters/][source]])

#+begin_src emacs-lisp
(use-package wrap-region
  :blackout wrap-region-mode
  :config (wrap-region-add-wrappers
           '(("*" "*" nil org-mode)
             ("~" "~" nil org-mode)
             ("/" "/" nil org-mode)
             ("=" "=" nil org-mode)
             ("_" "_" nil org-mode)
             ("\\(" "\\)" "$" org-mode)
             ("\\[" "\\]" "£" org-mode)
             ("#+begin_quote\n" "#+end_quote\n" "q" org-mode)
             ("#+begin_src \n" "\n#+end_src" "s" org-mode)
             ("#+begin_src \n" "\n#+end_src" "s" org-mode)
             ("#+begin_center \n" "\n#+end_center" "c" org-mode)
             ("#+begin_export latex\n" "\n#+end_export" "l" org-mode)))
  (add-hook 'org-mode-hook 'wrap-region-mode))
#+end_src

** Folding

#+begin_src emacs-lisp
(use-package bicycle
  :after outline
  :bind (:map outline-minor-mode-map
         ([C-tab] . bicycle-cycle)
         ([S-tab] . bicycle-cycle-global)))
#+end_src

** Beginning of …

A better ~C-a~. ([[http://www.wilfred.me.uk/.emacs.d/init.html][source]])

#+begin_src emacs-lisp
(defun malb/beginning-of-line-dwim ()
  "Toggles between moving point to the first non-whitespace character, and
  the start of the line."
  (interactive)

  (if (and (eq major-mode 'org-mode)
           (org-at-heading-or-item-p))
      (org-beginning-of-line)
    (let ((start-position (point)))
      ;; Move to the first non-whitespace character.
      (back-to-indentation)

      ;; If we haven't moved position, go to start of the line.
      (when (= (point) start-position)
        (move-beginning-of-line nil)))))

(bind-key "C-a" #'malb/beginning-of-line-dwim)
(bind-key "<home>"  #'malb/beginning-of-line-dwim lisp-mode-map)
#+end_src

Redefine =M-<= and =M->=. The real beginning and end of buffers (i.e., =point-min= and =point-max=) are still accessible by pressing the same key again. ([[https://github.com/DamienCassou/beginend][source]])

#+begin_src emacs-lisp
(use-package beginend
  :blackout beginend-global-mode
  :config (progn
            (beginend-global-mode)
            (dolist (mode beginend-modes)
              (blackout (cdr mode)))))
#+end_src

* Help
** Helpful

#+BEGIN_QUOTE
Helpful is an alternative to the built-in Emacs help that provides much more contextual information. — [[https://github.com/Wilfred/helpful][helpful]]
#+END_QUOTE

#+begin_src emacs-lisp
(use-package helpful
  :bind (("C-h f" . helpful-callable)
         ("C-h v" . helpful-variable)
         ("C-h k" . helpful-key)
         ("C-h ," . helpful-at-point))
  :config (progn
            (malb/register-right-side-window (rx "*helpful") t)
            (malb/register-right-side-window (rx (seq bos "*Help*" eos)) t) ; sometimes Help is called
            (malb/defadvice! malb/helpful-go-back (orig-function button)
              :before #'helpful--follow-link
              (push-mark))))
#+end_src

** Refine

#+BEGIN_QUOTE
Refine provides a convenient UI for editing variables. Refine is not for editing files, but for changing elisp variables, particularly lists. — [[https://github.com/Wilfred/refine][refine]]
#+END_QUOTE

#+begin_src emacs-lisp
(use-package refine)
#+end_src

* Projects (Projectile)

#+BEGIN_QUOTE
[[https://github.com/bbatsov/projectile][Projectile]] is a project interaction library for Emacs. […]

This library provides easy project management and navigation. The concept of a project is pretty basic – just a folder containing special file. Currently git, mercurial, darcs and bazaar repos are considered projects by default. So are lein, maven, sbt, scons, rebar and bundler projects. If you want to mark a folder manually as a project just create an empty =.projectile= file in it. Some of Projectile's features:

- jump to a file in project
- jump to files at point in project
- jump to a directory in project
- jump to a file in a directory
- jump to a project buffer
- jump to a test in project
- toggle between files with same names but different extensions (e.g. =.h= <-> =.c/.cpp=, =Gemfile= <-> =Gemfile.lock=)
- toggle between code and its test (e.g. =main.service.js= <-> =main.service.spec.js=)
- jump to recently visited files in the project
- switch between projects you have worked on
- kill all project buffers
- replace in project
- =multi-occur= in project buffers
- grep in project
- regenerate project =etags= or =gtags= (requires =ggtags=).
- visit project in =dired=
- run make in a project with a single key chord
#+END_QUOTE

[[https://raw.githubusercontent.com/bbatsov/projectile/master/screenshots/projectile.png]] ([[https://github.com/bbatsov/projectile/blob/master/screenshots/projectile.png][source]])

*Commands:*

- =C-c p D=   ~projectile-dired~
- =C-c p F=   ~helm-projectile-find-file-in-known-projects~
- =C-c p P=   ~projectile-test-project~
- =C-c p S=   ~projectile-save-project-buffers~
- =C-c p b=   ~helm-projectile-switch-to-buffer~
- =C-c p f=   ~helm-projectile-find-file~
- =C-c p g=   ~helm-projectile-find-file-dwim~
- =C-c p h=   ~helm-projectile~
- =C-c p p=   ~helm-projectile-switch-project~
- =C-c p r=   ~projectile-replace~
- =C-c p s s= ~helm-projectile-ag~
- =C-c p x=   ~projectile-run-term~ etc.

*When switching projects:*

- ~C-d~ open Dired in project's directory
- ~M-g~ open project root in vc-dir or magit
- ~M-e~ switch to Eshell: Open a project in Eshell.
- ~C-s~ grep in projects (add prefix C-u to recursive grep)
- ~C-c~ Compile project: Run a compile command at the project root.
- ~M-D~ Remove project(s): Delete marked projects from the list of known projects.
- ~C-c @~ insert the current file that highlight bar is on as an org link.

*Note*: =next-error= has nothing to do with projectile, but =<f5>= and =<f6>= kind of go together. ~previous-error~ is bound to =M-g p=.

#+begin_src emacs-lisp
(use-package projectile
  :after (tab-bar)
  :defer nil
  :bind (("<f5>" . projectile-compile-project)
         ("<f6>" . next-error)
         :map projectile-command-map
         ("#" . #'malb/projectile-repl))
  :init  (setq projectile-keymap-prefix (kbd "C-c p"))
  :config (progn
            (setq projectile-indexing-method 'hybrid
                  projectile-make-test-cmd "make check"
                  projectile-ignored-projects malb/projectile-ignored-projects
                  projectile-ignored-project-function #'malb/projectile-ignore-projects
                  projectile-globally-unignored-files '(".dir-locals.el")
                  projectile-buffers-filter-function #'malb/filter-mu4e-buffers
                  projectile-mode-line '(:eval (format "{%s}" (projectile-project-name))))

            (defun malb/projectile-ignore-projects (project-root)
              (progn
                (or (file-remote-p project-root)
                    ;; don't litter project list with cryptobib subprojects
                    (and  (string-match (rx-to-string `(: "cryptobib/" eos) t) project-root) t)
                    (and  (string-match (rx-to-string `(: bos "/tmp/" ) t) project-root) t))))

            (defun malb/projectile-repl ()
              (interactive)
              (let ((default-directory (projectile-project-root)))
                (if (boundp 'malb/projectile-repl)
                    (funcall malb/projectile-repl)
                  (malb/toggle-eshell))))

            (when (not (boundp 'malb/projectile-switch-tab-project-names))
              (defvar malb/projectile-switch-tab-project-names nil))

            (when (not (boundp 'malb/projectile-switch-tab-project-deny-list))
              (defvar malb/projectile-switch-tab-project-deny-list nil))

            (malb/defadvice! malb/projectile-switch-tab (old-function project-to-switch &rest args)
              "Switch to new tab if project is in `malb/projectile-switch-tab-projects'."
              :around 'projectile-switch-project-by-name
              :around 'helm-projectile-vc
              :around 'helm-projectile-switch-to-shell

              (let* ((project-name (projectile-project-name project-to-switch))
                     (project-short-name (or (cdr (assoc project-name malb/projectile-switch-tab-project-names))
                                             project-name))
                     (tab-created nil))

                (cond
                 ;; if tab exists
                 ((member project-short-name (mapcar (lambda (tab) (cdr (assq 'name tab)))
                                                     (tab-bar-tabs)))
                  (tab-bar-switch-to-tab project-short-name))

                 ;; not in deny list and no tab exists
                 ((not (assoc project-name malb/projectile-switch-tab-project-deny-list))
                  (progn
                    (tab-new)
                    (setq tab-created t)
                    (tab-rename project-short-name)))

                 ;; this is in the deny list
                 ((assoc project-name malb/projectile-switch-tab-project-deny-list)
                  (tab-bar-select-tab 1))
                 (t nil))

                (apply old-function (push project-to-switch args))

                (when tab-created
                  (delete-other-windows))))

            (malb/defadvice! malb/projectile-kill-tab ()
              "Kill tab too if it's not the first."
              :after 'projectile-kill-buffers
              (when (> (tab-bar--current-tab-index) 0)
                (tab-bar-close-tab nil 1)))

            (projectile-mode)
            (helm-projectile-on)))
#+end_src

[[https://tuhdo.github.io/helm-projectile.html][Helm]] integration

*Commands:*

- =C-c p h= for =helm-projectile= which combines buffer, file and project switching
- =C-c p F= for =helm-projectile-find-file-in-known-projects=

We add a “Create file“ action ([[https://www.reddit.com/r/emacs/comments/3m8i5r/helmprojectile_quickly_findcreate_new_file_in/][source]]) and replace =grep= by =ag=.

#+begin_src emacs-lisp
(use-package helm-projectile
  :after (projectile)
  :init (setq helm-projectile-fuzzy-match nil)
  :commands (helm-projectile-on helm-projectile-switch-project)
  :config (progn
            (defvar malb/helm-source-file-not-found
              (helm-build-dummy-source "Create file" :action 'find-file))
            (add-to-list 'helm-projectile-sources-list malb/helm-source-file-not-found t)
            (add-to-list 'helm-commands-using-frame #'helm-projectile-switch-project)
            (setq projectile-switch-project-action 'helm-projectile)))
#+end_src

* Git
** Magit

[[http://magit.vc][Magit]] is a very nice Git interface.

[[https://magit.vc/screenshots/status.png]] ([[http://magit.vc][source]])


#+begin_src emacs-lisp
(use-package magit
  :commands (magit-status
             magit-diff
             magit-commit
             magit-log
             magit-push
             magit-stage-file
             magit-unstage-file
             malb/expand-org-mode-entry)
  :hook ((magit-diff-visit-file . malb/expand-org-mode-entry)
         (magit-status-mode . visual-fill-column-mode))
  :bind (("S-<f7>" . magit-status)
         ("<f7>" . magit-dispatch))
  :config (progn
            ;; source: https://www.reddit.com/r/emacs/comments/ayjgpu/magit_orgmode_unfold_containing_headlines_when/
            (defun malb/expand-org-mode-entry ()
              "When opening an org-mode file, show the current entry and all headings that it is contained in."
              ;; invoke org-reveal with a single prefix arg, as that expands ;; the entry containing
              ;; (point), all sibling entries and all ;; parent entries and their siblings.
              (when (derived-mode-p 'org-mode)
                (org-reveal '(4))))

            (setq magit-push-always-verify nil
                  magit-last-seen-setup-instructions "2.1.0"
                  magit-define-global-key-bindings t)

            (setq-default magit-diff-refine-hunk t)))
#+end_src

*Notes*

- try =git config status.showUntrackedFiles all= ([[https://emacs.stackexchange.com/questions/13729/choose-files-to-stage-of-a-new-directory-with-magit][source]])

*** Magit SVN

We enable [[https://github.com/magit/magit-svn][magit-svn]] whenever necessary.

#+begin_src emacs-lisp
(use-package magit-svn
  :after magit
  :config (progn
            (defun malb/magit-svn ()
              (if (file-exists-p (magit-git-dir "svn"))
                  (magit-svn-mode)))
            (add-hook 'magit-mode-hook #'malb/magit-svn)))
#+end_src

*** GitHub


#+begin_src emacs-lisp
(use-package forge
  :after magit
  :config (setq ghub-use-workaround-for-emacs-bug 'force))
#+end_src

*** Org Links for Magit Buffers

[[https://github.com/magit/orgit][orgit]]

#+begin_src emacs-lisp
(use-package orgit)
#+end_src

[[https://github.com/magit/orgit-forge/][orgit-forge]]

#+begin_src emacs-lisp
(use-package orgit-forge)
#+end_src

** Git Timemachine

I don’t often use [[https://github.com/pidu/git-timemachine#start-of-content][git-timemachine]] but when I do …

#+begin_src emacs-lisp
(use-package git-timemachine)
#+end_src

** Snapper Timemachine

[[https://github.com/mrBliss/snapshot-timemachine][snapshot-timemachine: Emacs-mode to step through (Btrfs, ZFS, ...) snapshots of files]]

#+begin_src emacs-lisp
(use-package snapshot-timemachine :ensure nil)
#+end_src

** Git Link

[[https://github.com/sshaw/git-link][git-link]]:

#+BEGIN_QUOTE
functions that create URLs for files and commits in GitHub/Bitbucket/GitLab/... repositories. =git-link= returns the URL for the current buffer's file location at the current line number or active region. =git-link-commit= returns the URL for a commit. URLs are added to the kill ring.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package git-link
  :bind (("C-c g" . git-link)))
#+end_src

** Git Autocommit

[[https://github.com/ryuslash/git-auto-commit-mode][git-auto-commit-mode]] for committing … automatically.

#+begin_src emacs-lisp
(use-package git-auto-commit-mode)
#+end_src

** Git Annex

Dired additions for git-annex.

#+begin_src emacs-lisp
(use-package git-annex
  :demand
  :bind (:map git-annex-dired-map
         ("s" . git-annex-dired-sync)
         ("D" . git-annex-dired-hard-delete-files))
  :config (progn
            (defun git-annex-dired-sync ()
              (interactive)
              (call-process "git" nil nil nil "annex" "sync")
              (message "Sync done."))


            (defun git-annex-dired-hard-delete-files (file-list)
              (interactive
               (let ((files (dired-get-marked-files t current-prefix-arg)))
                 (list files)))
              (let ((here (point)))
                (unwind-protect
                    (mapc #'(lambda (file)
                              (call-process "git" nil nil nil "rm" file))
                          file-list)
                  (goto-char here)))
              (message (format "Deleted %d file(s)." (length file-list))))

            (malb/defadvice! malb/git-annex-dired-drop-files (file-list &optional arg)
              :override #'git-annex-dired-drop-files
              (interactive (let ((files (dired-get-marked-files t current-prefix-arg)))
                             (list files current-prefix-arg)))
              (let ((here (point)))
                (unwind-protect
                    (mapc #'(lambda (file)
                              (git-annex "drop" "--force" file)
                              (dired-relist-file (expand-file-name file)))
                          file-list)
                  (goto-char here)))
              (message (format "Annex: dropped %d file(s)" (length file-list))))

            (malb/defadvice! malb/git-annex-dired-get-files (file-list &optional arg)
              :override #'git-annex-dired-get-files
              (interactive (let ((files (dired-get-marked-files t current-prefix-arg)))
                             (list files current-prefix-arg)))
              (async-start
               `(lambda ()
                  (package-initialize)
                  (require 'git-annex)
                  (require 'dired-aux)
                  ,(async-inject-variables "file-list")
                  (git-annex-dired--apply "get" file-list)
                  file-list)
               (lambda (file-list)
                 (let ((here (point)))
                   (unwind-protect
                       (mapc #'(lambda (file)
                                 (dired-relist-file (expand-file-name file)))
                             file-list)
                     (goto-char here)))
                 (message (format "Annex: got %d file(s)" (length file-list))))))))
#+end_src

* Org-mode all the things!

See [[http://orgmode.org/guide/Introduction.html][here]] for an introduction to [[http://orgmode.org/][org-mode]].

*Note:* Ideally, we’d want to put all org-mode stuff into one big =:config= blog, but that makes it harder to read/explain.

#+begin_src emacs-lisp
(use-package org
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda)
         :map org-mode-map
         ("C-c [" . nil)
         ("C-c ;" . nil)
         ("M-/" . company-complete-common)) ;; I keep pressing it by accident, clumsy me
  :mode ("\\.org$" . org-mode)
  :blackout (orgtbl-mode)
  :custom ((org-export-backends '(md odt latex icalendar html ascii))))
#+end_src

#+begin_src emacs-lisp
(defun malb/org-hidden-link-ignore-isearch ()
  "Do not match hidden parts of links during isearch."
  (org-fold-core-set-folding-spec-property 'org-link :isearch-open nil))

(add-hook 'org-mode-hook #'malb/org-hidden-link-ignore-isearch)
(add-hook 'org-cycle-hook #'org-cycle-hide-drawers)
#+end_src

#+begin_src emacs-lisp
(use-package org-contrib)
#+end_src

** Files

#+begin_src emacs-lisp
(setq org-directory malb/org-files-dir
      org-agenda-files malb/org-files
      org-default-notes-file malb/inbox-org)
#+end_src

** Options

#+begin_src emacs-lisp
(setq org-enforce-todo-dependencies nil ; enforce todo dependencies
      org-habit-graph-column 117
      org-use-speed-commands t
      org-catch-invisible-edits 'smart
      org-adapt-indentation nil         ; Non-nil means adapt indentation to outline node level.
      org-tags-column -120
      org-startup-folded 'fold
      org-log-into-drawer t
      org-log-done 'time
      org-return-follows-link nil       ; don’t follow links by pressing ENTER
      org-clock-persist 'history
      org-special-ctrl-a/e t             ; begin/end of line to skip starts …
      org-special-ctrl-k t               ; special keys for killing a headline
      org-edit-src-content-indentation 0 ; don't indent source code
      org-src-preserve-indentation t     ; preserve indentation in code
      org-src-window-setup 'plain        ; when hitting C-c '
      org-reverse-note-order t
      org-footnote-auto-adjust t          ; renumber footnotes automagically
      org-link-elisp-confirm-function nil ;
      org-hidden-keywords nil
      org-list-demote-modify-bullet  '(("+" . "-") ("-" . "+") ("*" . "+"))
      org-list-allow-alphabetical t
      org-outline-path-complete-in-steps nil
      org-M-RET-may-split-line '((default . t) (headline . nil))
      org-blank-before-new-entry (quote ((heading . auto)
                                         (plain-list-item . nil)))
      org-yank-adjusted-subtrees nil
      org-treat-S-cursor-todo-selection-as-state-change nil
      org-extend-today-until 3
      org-show-context-detail '((agenda . canonical) ;; instead of "local"
                                (bookmark-jump . lineage)
                                (isearch . lineage)
                                (default . ancestors))
      org-format-latex-options (plist-put org-format-latex-options :scale 2.0))

(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
(add-hook 'org-agenda-mode-hook (lambda () (toggle-truncate-lines 1)))
(add-hook 'org-agenda-mode-hook (lambda ()
                                  (setq-local imenu-generic-expression
                                              '((nil "^\\([a-zA-Z]+ +[0-9]+ [a-zA-Z]+ 20[0-9][0-9]\\)$" 1)))))

(bind-key "<home>" #'org-beginning-of-line org-mode-map)
(bind-key "<end>" #'org-end-of-line org-mode-map)
(bind-key "C-c C-." #'org-time-stamp org-mode-map) ; ede binds C-c . too
(bind-key "C-c C-," #'org-time-stamp-inactive org-mode-map) ; fylcheck binds C-c !
#+end_src

** Agenda

#+begin_src emacs-lisp
(use-package org-agenda
  :ensure nil
  :defer nil
  :after org
  :bind (("C-c a" . org-agenda)
         :map org-agenda-keymap
         ("C-_" . org-agenda-undo))
  :config
  (setq org-agenda-tags-column -127
        org-agenda-include-diary nil
        org-agenda-dim-blocked-tasks t
        org-agenda-default-appointment-duration 60
        org-agenda-skip-additional-timestamps-same-entry nil
        org-agenda-skip-timestamp-if-deadline-is-shown t
        org-agenda-skip-deadline-prewarning-if-scheduled t
        ;; org-agenda-ignore-properties '(effort appt category)
        org-agenda-window-setup 'current-window ; Current window gets agenda
        org-agenda-sticky t                     ; Use sticky agenda's so they persist
        org-agenda-compact-blocks nil           ; Don't compact the block agenda view
        org-agenda-block-separator 32           ; empty line
        org-agenda-span 14                      ; span 14 days of agenda
        org-agenda-start-on-weekday 1           ; start on Monday
        )

  (add-hook 'org-agenda-finalize-hook 'hl-line-mode)

  (setq org-agenda-custom-commands
        '(("n" "Agenda and all TODOs"
           ((org-ql-block '(and (priority "A")
                                (todo))
                          ((org-ql-block-header "PRIORITIES\n")))
            (agenda "" ((org-agenda-overriding-header "AGENDA\n")))
            (org-ql-block '(and (not (priority "A"))
                                (not (priority "B"))
                                (not (priority "C"))
                                (todo)
                                (not (tags "idea"))
                                (not (tags "presents"))
                                (not (tags "entertainment"))
                                (not (tags "ARCHIVE")))
                          ((org-ql-block-header "TODOs\n")))
            (org-ql-block '(and (tags "entertainment")
                                (not (tags "ARCHIVE"))
                                (todo))
                          ((org-ql-block-header "FUN STUFF\n")))))))

  (setq org-agenda-prefix-format '((agenda . " %i	%?-12t% s")
                                   (todo . " %i	")
                                   (tags . " %i	")
                                   (search . " %i	")))

  (setq org-agenda-category-icon-alist
        `(("\\`Research\\'"
           (#("" 0 1 (rear-nonsticky t display (raise 0.0)
                                      font-lock-face
                                      (:family "FontAwesome" :height 1.0)
                                      face
                                      (:family "FontAwesome" :height 1.0))))
           nil nil :ascent center)
          ("\\`Fun Stuff\\'"
           (#("" 0 1 (rear-nonsticky t display (raise 0.0)
                                      font-lock-face
                                      (:family "Material Icons" :height 1.0)
                                      face
                                      (:family "Material Icons" :height 1.0))))
           nil nil :ascent center)
          ("\\`Inbox\\'"
           (#("" 0 1 (rear-nonsticky t display
                                      (raise 0.0)
                                      font-lock-face
                                      (:family "Material Icons" :height 1.0)
                                      face
                                      (:family "Material Icons" :height 1.0))))
           nil nil :ascent center)
          ("\\`IT\\'"
           (#("" 0 1 (rear-nonsticky t display
                                      (raise 0.0)
                                      font-lock-face
                                      (:family "Material Icons" :height 1.0)
                                      face
                                      (:family "Material Icons" :height 1.0))))
           nil nil :ascent center)
          ("\\`Travel\\'"
           (#("" 0 1 (rear-nonsticky t display
                                      (raise 0.0)
                                      font-lock-face
                                      (:family "Material Icons" :height 1.0)
                                      face
                                      (:family "Material Icons" :height 1.0))))
           nil nil :ascent center)
          ("\\`Critique\\'"
           (#("" 0 1 (rear-nonsticky t display
                                      (raise 0.0)
                                      font-lock-face
                                      (:family "Material Icons" :height 1.0)
                                      face
                                      (:family "Material Icons" :height 1.0))))
           nil nil :ascent center)
          ("\\`Personal\\'"
           (#("" 0 1 (rear-nonsticky t display
                                      (raise 0.0)
                                      font-lock-face
                                      (:family "Material Icons" :height 1.0)
                                      face
                                      (:family "Material Icons" :height 1.0))))
           nil nil :ascent center)
          ("\\`Health\\'"
           (#("" 0 1 (rear-nonsticky t display
                                      (raise 0.0)
                                      font-lock-face
                                      (:family "Material Icons" :height 1.0)
                                      face
                                      (:family "Material Icons" :height 1.0))))
           nil nil :ascent center)
          ("\\`Work\\'"
           (#("" 0 1 (rear-nonsticky t display
                                      (raise 0.0)
                                      font-lock-face
                                      (:family "Material Icons" :height 1.0)
                                      face
                                      (:family "Material Icons" :height 1.0))))
           nil nil :ascent center)
          ("\\`Meeting\\'"
           (#("" 0 1 (rear-nonsticky t display
                                      (raise 0.0)
                                      font-lock-face
                                      (:family "Material Icons" :height 1.0)
                                      face
                                      (:family "Material Icons" :height 1.0))))
           nil nil :ascent center))))
#+end_src

** Look

#+begin_src emacs-lisp
(setq org-hide-emphasis-markers nil      ; don’t hide markers for like *foo*
      ;; org-ellipsis " ••• "
      org-ellipsis " ▼ "
      org-highlight-latex-and-related nil
      org-src-fontify-natively t        ; fontify code blocks
      org-startup-with-inline-images t  ; show images when opening a file.
      org-startup-with-latex-preview nil
      org-preview-latex-default-process 'dvisvgm
      org-pretty-entities nil
      org-image-actual-width 800)
#+end_src

Pretty print some maths:

#+begin_src emacs-lisp
(setq org-entities-user '(("coloneqq" "\\coloneqq" t ":=" ":=" ":=" "≔")
                          ("deg" "\\deg" t "deg" "deg" "deg" "deg")
                          ("ZZ" "\\ZZ" t "ZZ" "ZZ" "ZZ" "ℤ")))
#+end_src

** ToDo Keywords & Scheduling

#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)"
                  "WAIT(w@)"
                  "PING(p)"
                  "DELEGATED(e@/!)"
                  "|"
                  "DONE(d)"
                  "CANCELLED(c@/!)") ;;generic

        (sequence "EXPLORE(x)"
                  "DRAFT"
                  "COAUTHOR(@/!)"
                  "EDIT(!)"
                  "SUBMITTED(@/!)"
                  "REBUT"
                  "FINAL"
                  "|"
                  "PUBLISHED(!)"
                  "ONHOLD(h@/!)"
                  "STALLED(s)") ;; papers

        (sequence "REVIEW(v)"
                  "INFO(i@/!)"
                  "|"
                  "DONE(!)") ;; reviews

        (type "BLOG(b)"
              "READ(r)"
              "REPLY(R)"
              "CALL"
              "MAIL"
              "LOAD"
              "PLAY"
              "NEXT"
              "PAY(P)"
              "BOOK(B)"
              "|" "DONE")))

(org-clock-persistence-insinuate)
#+end_src

delete SCHEDULED if new state is a WAITing state

#+begin_src emacs-lisp
(defun malb/org-after-todo-state-change ()
  ;; we no longer have this as sheduled
  (when (or (string-equal org-state "WAIT")
            (string-equal org-state "COAUTHOR")
            (string-equal org-state "DELEGATED")
            (string-equal org-state "SUBMITTED"))
    (org-remove-timestamp-with-keyword org-scheduled-string))

  ;; we set a default deadline for some
  (when (and (or (string-equal org-state "WAIT"))
             (not (org-get-deadline-time (point))))
    (org-deadline nil (org-read-date nil t "+7d"))))

(add-hook 'org-after-todo-state-change-hook 'malb/org-after-todo-state-change)
#+end_src

#+begin_src emacs-lisp
(malb/register-popup-window (rx "*Org Note*"))
#+end_src

** Tags

#+begin_src emacs-lisp
(setq org-tag-persistent-alist '((:startgroup . nil)
                                 ("@office" . ?o)
                                 ("@train" . ?t)
                                 ("@home" . ?h)
                                 (:endgroup . nil)
                                 ("quick" . ?q)
                                 ("noexport" . ?n)
                                 ("ignore" . ?i)))
#+end_src

** Tables

Bind =org-table-*= command when the point is in an org table ([[http://emacs.stackexchange.com/a/22457/115][source]]).

#+begin_src emacs-lisp
(bind-keys
 :map org-mode-map
 :filter (org-at-table-p)
 ("C-c ?" . org-table-field-info)
 ("C-c SPC" . org-table-blank-field)
 ("C-c +" . org-table-sum)
 ("C-c =" . org-table-eval-formula)
 ("C-c `" . org-table-edit-field)
 ("C-#" . org-table-rotate-recalc-marks)
 ("C-c }" . org-table-toggle-coordinate-overlays)
 ("C-c {" . org-table-toggle-formula-debugger))
#+end_src

#+begin_src emacs-lisp
(setq org-latex-tables-booktabs t)
#+end_src

Extract org tables as lists of alists.

#+begin_src emacs-lisp
(defun malb/org-table-to-alist (name)
  "Return list of alists for org table named NAME under current heading."
  (save-excursion
    (save-restriction
      (org-narrow-to-subtree)
      (goto-char (point-min))

      (let ( (case-fold-search t))
        (search-forward (format "+name: %s" name)))
      (forward-line)

      (search-forward "|")

      (unless (org-at-table-p)
        (user-error "Not at a table"))

      (let ((clean-table (org-table-to-lisp))
            (ret '())
            (i 1))
        (dolist (row clean-table)
          (if (eq row 'hline)
              (setq i (+ i 1))
            (dolist (col row)
              (setf col (substring-no-properties col)))))

        (while (< i (length clean-table))
          (add-to-list 'ret
                       (cl-loop
                        for j below
                        (length (nth 0 clean-table))
                        collect (cons (nth j (nth 0 clean-table ))
                                      (nth j (nth i clean-table ))))
                       t)
          (setq i (+ i 1)))
        ret))))
#+end_src

** Speed Commands

([[https://raw.githubusercontent.com/jkitchin/scimax/][source]])

#+begin_src emacs-lisp
(add-to-list 'org-speed-commands (cons "m" 'org-mark-subtree)) ;; Mark a subtree
(add-to-list 'org-speed-commands (cons "S" 'widen)) ;; Widen
(add-to-list 'org-speed-commands (cons "k" (lambda () ;; kill a subtree
                                             (org-mark-subtree)
                                             (kill-region
                                              (region-beginning)
                                              (region-end)))))
(add-to-list 'org-speed-commands (cons "J" 'avy-org-goto-heading-timer))
#+end_src

#+BEGIN_QUOTE
If you prefer using previous patterns, e.g. <s, you can activate them again by requiring Org Tempo library: ~(require 'org-tempo)~
#+END_QUOTE

#+begin_src emacs-lisp
(use-package org-tempo
  :ensure org)
#+end_src

** Refiling

Targets include this file and any file contributing to the agenda - up to 9 levels deep

#+begin_src emacs-lisp
(setq org-refile-targets (quote ((nil :maxlevel . 9) (org-agenda-files :maxlevel . 9))))
#+end_src

Stop using paths for refile targets - we file directly with helm

#+begin_src emacs-lisp
(setq org-refile-use-outline-path 'file)
#+end_src

Allow refile to create parent tasks with confirmation
#+begin_src emacs-lisp
(setq org-refile-allow-creating-parent-nodes '(confirm))
#+end_src

** Spell Checking

#+begin_src emacs-lisp
;; source http://endlessparentheses.com/ispell-and-org-mode.html
(defun malb/org-ispell ()
  "Configure `ispell-skip-region-alist' for `org-mode'."
  (make-local-variable 'ispell-skip-region-alist)
  (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
  (add-to-list 'ispell-skip-region-alist '("~" "~"))
  (add-to-list 'ispell-skip-region-alist '("=" "="))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_src" . "^#\\+end_src"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_example" . "#\\+end_example"))
  (add-to-list 'ispell-skip-region-alist '("#\\+begin_quote" . "#\\+end_quote")))

(add-hook 'org-mode-hook #'malb/org-ispell)
(add-hook 'org-mode-hook #'flyspell-mode)
#+end_src

** Diminish Minor Modes

#+begin_src emacs-lisp
(use-package org-indent
  :ensure nil
  :blackout)
#+end_src

** Archiving

Archive with some order in target file preserved. ([[https://gist.github.com/edgimar/072d99d8650abe81a9fe7c8687c0c993][source]])

#+begin_src emacs-lisp
(defadvice org-archive-subtree (around fix-hierarchy activate)
  (let* ((fix-archive-p (and (not current-prefix-arg)
                             (not (use-region-p))))
         (afile  (car (org-archive--compute-location
		               (or (org-entry-get nil "ARCHIVE" 'inherit) org-archive-location))))
         (buffer (or (find-buffer-visiting afile) (find-file-noselect afile))))
    ad-do-it
    (when fix-archive-p
      (with-current-buffer buffer
        (goto-char (point-max))
        (while (org-up-heading-safe))
        (let* ((olpath (org-entry-get (point) "ARCHIVE_OLPATH"))
               (path (and olpath (split-string olpath "/")))
               (level 1)
               tree-text)
          (when olpath
            (org-mark-subtree)
            (setq tree-text (buffer-substring (region-beginning) (region-end)))
            (let (this-command) (org-cut-subtree))
            (goto-char (point-min))
            (save-restriction
              (widen)
              (-each path
                (lambda (heading)
                  (if (re-search-forward
                       (rx-to-string
                        `(: bol (repeat ,level "*") (1+ " ") ,heading))
                       nil t)
                      (org-narrow-to-subtree)
                    (goto-char (point-max))
                    (unless (looking-at "^")
                      (insert "\n"))
                    (insert (make-string level ?*)
                            " "
                            heading
                            "\n"))
                  (cl-incf level)))
              (widen)
              (org-end-of-subtree t t)
              (org-paste-subtree level tree-text))))))))
#+end_src

#+begin_src emacs-lisp
(setq org-archive-location "~/Documents/Archive/org-files/%s_archive::")
#+end_src

** Habit

#+begin_src emacs-lisp
(use-package org-habit
  :ensure nil
  :config (add-to-list 'org-modules 'org-habit))
#+end_src

** Protocol

#+begin_src emacs-lisp
(use-package org-protocol
  :ensure nil)
#+end_src

** Pretty

I’m using [[https://github.com/minad/org-modern][org-modern]] as a faster org-superstar replacement.

#+begin_src emacs-lisp
(use-package org-modern
  :custom ((org-modern-block-name nil "Don't stylise blocks")
           (org-modern-block-fringe nil "Don't stylise block fringes")
           (org-modern-priority nil "Don't stylise priorities")
           (org-modern-tag nil "Don't stylise tags")
           (org-modern-timestamp nil "Don't stylisee timestamps")
           (org-modern-todo nil "Don't stylise TODOs")
           (org-modern-checkbox nil "Don't stylise checkboxes")
           (org-modern-hide-stars nil "Don't hide leading stars using org-modern")
           (org-hide-leading-stars t "Hide leading stars using org")
           (org-modern-keyword nil "I want to see #+")
           (org-modern-list nil "Don't stylise lists")
           (org-modern-table nil "I can't see the cursor otherwise")
           (org-modern-internal-target nil "Stop it!")
           (org-modern-star ["●" "▲" "■" "◉" "○" "○"]))
  :config (add-hook 'org-mode-hook #'org-modern-mode))
#+end_src

** Export

UTF-8 everywhere.

#+begin_src emacs-lisp
(setq org-export-coding-system 'utf-8
      org-ascii-charset 'utf-8
      org-export-in-background nil
      org-export-use-babel t
      org-export-with-toc nil
      org-export-with-timestamps 'active
      org-latex-pdf-process '("latexmk -g -pdf -pdflatex=\"%latex --shell-escape -halt-on-error\" -outdir=%o %f")
      org-export-async-init-file (expand-file-name "org-export-init.el" user-emacs-directory))
#+end_src

([[https://lists.gnu.org/archive/html/emacs-orgmode/2016-12/msg00555.html][source]])

#+begin_src emacs-lisp
(add-to-list 'org-babel-default-header-args '(:eval . "never-export"))
(add-to-list 'org-babel-default-inline-header-args '(:eval . "never-export"))
#+end_src


#+begin_src emacs-lisp
(setq org-latex-to-mathml-convert-command "java -jar %j -unicode -force -df %o %I"
      org-latex-to-mathml-jar-file (expand-file-name "mathtoweb.jar" user-emacs-directory))
#+end_src

*** iCalendar

iCal export is triggered after 600 seconds of inactivity.

*Note*: this code is definitely from somewhere else. I don’t remember where, though.

#+begin_src emacs-lisp
(use-package ox-icalendar
  :ensure nil
  :config (progn
            (setq org-icalendar-include-todo t
                  org-icalendar-combined-agenda-file malb/org-mode-ics
                  org-icalendar-categories '(category)
                  org-icalendar-timezone "Europe/London"
                  org-icalendar-use-scheduled '(todo-start event-if-not-todo)
                  org-icalendar-use-deadline '(todo-due)
                  org-icalendar-with-timestamps 'active)))
#+end_src

#+begin_src emacs-lisp
(defvar malb/org-icalendar-export-timer nil
  "Timer that `malb/org-icalendar-export-timer' uses to reschedule itself, or nil.")
#+end_src

#+begin_src emacs-lisp
(defun malb/org-icalendar-export-with-delay (secs)
  "Export after `secs' seconds unless the file changed in the meantime."
  (when malb/org-icalendar-export-timer
    (cancel-timer malb/org-icalendar-export-timer))
  (setq malb/org-icalendar-export-timer
        (run-with-idle-timer
         (* 1 secs) nil (lambda ()
                          (dolist (fn (org-agenda-files))
                            (let ((buf (get-file-buffer fn)))
                              (when (and buf (buffer-modified-p buf))
                                (with-current-buffer buf
                                  (save-buffer)))))
                          ;; async, check org-export-init.el
                          (org-icalendar-combine-agenda-files t)
                          (org-agenda-redo)))))
#+end_src

#+begin_src emacs-lisp
(defun malb/ox-export-after-save-hook ()
  "Save after 30 seconds of no changes."
  (if (eq major-mode 'org-mode)
      (malb/org-icalendar-export-with-delay 30)))
#+end_src

*** Org LaTeX

- Use LuaTeX because UTF-8 and fonts.
- Add some standard (to us) packages
- Handouts are done via [[https://www.ctan.org/pkg/tufte-latex?lang=en][tufte-handout]], letters via =ox-koma-letter=.

#+begin_src emacs-lisp
(use-package ox-latex
  :ensure nil
  :config (progn
            (add-to-list 'org-latex-packages-alist '("" "listings"))
            (add-to-list 'org-latex-packages-alist '("" "xcolor"))
            (add-to-list 'org-latex-packages-alist '("" "amssymb"))
            (add-to-list 'org-latex-packages-alist '("" "amsmath"))
            (add-to-list 'org-latex-packages-alist '("" "amsthm"))
            (add-to-list 'org-latex-packages-alist '("" "gensymb"))
            (add-to-list 'org-latex-packages-alist '("" "nicefrac"))
            (add-to-list 'org-latex-packages-alist '("" "units"))
            (add-to-list 'org-latex-packages-alist '("" "xspace"))
            (add-to-list 'org-latex-packages-alist '("," "babel"))
            (add-to-list 'org-latex-packages-alist '("," "stmaryrd"))
            (add-to-list 'org-latex-packages-alist '("capitalize" "cleveref"))
            (add-to-list 'org-latex-packages-alist (list (s-join "," '("notions"
                                                                       "operators"
                                                                       "sets"
                                                                       "keys"
                                                                       "ff"
                                                                       "adversary"
                                                                       "primitives"
                                                                       "complexity"
                                                                       "asymptotics"
                                                                       "lambda"
                                                                       "landau"
                                                                       "advantage"))
                                                         "cryptocode"))
            (add-to-list 'org-latex-packages-alist '("" "newunicodechar"))
            (add-to-list 'org-latex-packages-alist '("" "microtype"))
            (add-to-list 'org-latex-packages-alist '("" "booktabs"))
            (add-to-list 'org-latex-packages-alist '("color=cyan!0!magenta!4!yellow!16" "todonotes") t)


            (setq org-latex-src-block-backend 'listings
                  org-latex-compiler "lualatex"
                  org-latex-prefer-user-labels t
                  org-latex-caption-above nil
                  org-latex-hyperref-template  (concat "\\hypersetup{\n"
                                                       "pdfauthor={%a},\n"
                                                       "pdftitle={%t},\n"
                                                       "pdfkeywords={%k},\n"
                                                       "pdfsubject={%d},\n"
                                                       "pdfcreator={%c},\n"
                                                       "pdflang={%L},\n"
                                                       "colorlinks,\n"
                                                       "citecolor=gray,\n"
                                                       "filecolor=gray,\n"
                                                       "linkcolor=gray,\n"
                                                       "urlcolor=gray\n"
                                                       "}\n"))

            (defun malb/set-org-latex-class (name lines hierarchies)
              (let* ((lines (s-join "\n" lines))
                     (entry (append (list name lines)
                                    hierarchies)))
                (setq org-latex-classes
                      (cons entry (remove (assoc name org-latex-classes) org-latex-classes))) ))

            (defconst malb/org-latex-default
              (with-temp-buffer
                (insert-file-contents
                 (expand-file-name "article-header.tex" user-emacs-directory))
                (buffer-string)))

            (defconst malb/tufte-fix
              (concat "\\renewcommand{\\textls}[2][5]{\\begingroup\\addfontfeatures{LetterSpace=#1}#2\\endgroup}\n"
                      "\\usepackage{fontspec}\n"
                      "\\renewcommand{\\allcapsspacing}[1]{\\textls[15]{#1}}\n"
                      "\\renewcommand{\\smallcapsspacing}[1]{\\textls[10]{#1}}\n"
                      "\\renewcommand{\\allcaps}[1]{\\textls[15]{\\MakeTextUppercase{#1}}}\n"
                      "\\renewcommand{\\smallcaps}[1]{\\smallcapsspacing{\\scshape\\MakeTextLowercase{#1}}}\n"
                      "\\renewcommand{\\textsc}[1]{\\smallcapsspacing{\\textsmallcaps{#1}}}\n"
                      "\n"))

            (defconst malb/tufte-listings
              (concat "\\lstset{showstringspaces=false,\n"
                      "  aboveskip=0.75em,\n"
                      "  basicstyle=\\footnotesize\ttfamily,\n"
                      "  keywordstyle=\\bfseries\\color{gray!40!black},\n"
                      "  commentstyle=\\itshape\\color{gray!140!black},\n"
                      "  identifierstyle=\\color{gray!40!black},\n"
                      "  stringstyle=\\color{gray},\n"
                      "  backgroundcolor=\\color{gray!190!black},\n"
                      "  frame=none,\n"
                      "  xleftmargin=\\parindent\n"
                      "}\n"
                      "\n"))

            (malb/set-org-latex-class "tufte-book-noparts"
                                      `("\\documentclass{tufte-book}"
                                        "\\usepackage{fontspec}"
                                        "[DEFAULT-PACKAGES]"
                                        "[PACKAGES]"
                                        ,malb/org-latex-default
                                        ,malb/tufte-fix
                                        ,malb/tufte-listings
                                        "[EXTRA]")
                                      '(("\\chapter{%s}" . "\\chapter*{%s}")
                                        ("\\section{%s}" . "\\section*{%s}")
                                        ("\\subsection{%s}" . "\\subsection*{%s}")
                                        ("\\paragraph{%s}" . "\\paragraph*{%s}")))

            (malb/set-org-latex-class "tufte-book"
                                      `("\\documentclass{tufte-book}"
                                        "\\usepackage{fontspec}"
                                        "[DEFAULT-PACKAGES]"
                                        "[PACKAGES]"
                                        ,malb/org-latex-default
                                        ,malb/tufte-fix
                                        ,malb/tufte-listings
                                        "[EXTRA]")
                                      '(("\\part{%s}" . "\\part*{%s}")
                                        ("\\chapter{%s}" . "\\chapter*{%s}")
                                        ("\\section{%s}" . "\\section*{%s}")
                                        ("\\subsection{%s}" . "\\subsection*{%s}")
                                        ("\\paragraph{%s}" . "\\paragraph*{%s}")))

            (malb/set-org-latex-class "handout"
                                      `("\\documentclass{tufte-handout}"
                                        "\\usepackage{fontspec}"
                                        "[DEFAULT-PACKAGES]"
                                        "[PACKAGES]"
                                        ,malb/org-latex-default
                                        ,malb/tufte-fix
                                        ,malb/tufte-listings
                                        "[EXTRA]")
                                      '(("\\section{%s}" . "\\section*{%s}")
                                        ("\\subsection{%s}" . "\\subsection*{%s}")
                                        ("\\paragraph{%s}" . "\\paragraph*{%s}")
                                        ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

            (malb/set-org-latex-class "report"
                                      `("\\documentclass{report}"
                                        "[DEFAULT-PACKAGES]"
                                        "[PACKAGES]"
                                        "\\usepackage{fontspec}"
                                        "\\usepackage[a4paper,includeheadfoot,margin=2.54cm]{geometry}"
                                        "\\usepackage[hang,flushmargin]{footmisc}"
                                        "\\parskip 1em"
                                        "\\parindent 0pt"
                                        "\\linespread{1.25}"
                                        ,malb/org-latex-default
                                        "[EXTRA]")
                                      '(("\\chapter{%s}" . "\\chapter*{%s}")
                                        ("\\section{%s}" . "\\section*{%s}")
                                        ("\\subsection{%s}" . "\\subsection*{%s}")
                                        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                                        ("\\paragraph{%s}" . "\\paragraph*{%s}")
                                        ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
            ;; backward compatibility
            (add-to-list 'org-latex-classes (cons "org-report" (cdr (assoc "report" org-latex-classes))))

            (malb/set-org-latex-class "article"
                                      `("\\documentclass{article}"
                                        "[DEFAULT-PACKAGES]"
                                        "[PACKAGES]"
                                        "\\usepackage{fontspec}"
                                        "\\usepackage[a4paper,includeheadfoot,margin=3cm]{geometry}"
                                        "\\usepackage[hang,flushmargin]{footmisc}"
                                        "\\parskip 1em"
                                        "\\parindent 0pt"
                                        ,malb/org-latex-default
                                        "[EXTRA]")
                                      '(("\\section{%s}" . "\\section*{%s}")
                                        ("\\subsection{%s}" . "\\subsection*{%s}")
                                        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                                        ("\\paragraph{%s}" . "\\paragraph*{%s}")
                                        ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

            (malb/set-org-latex-class "plain-article"
                                      `("\\documentclass[11pt]{article}")
                                      '(("\\section{%s}" . "\\section*{%s}")
                                        ("\\subsection{%s}" . "\\subsection*{%s}")
                                        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                                        ("\\paragraph{%s}" . "\\paragraph*{%s}")
                                        ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
            (malb/set-org-latex-class "plain-report"
                                      `("\\documentclass[11pt]{report}")
                                      '(("\\part{%s}" . "\\part*{%s}")
                                        ("\\chapter{%s}" . "\\chapter*{%s}")
                                        ("\\section{%s}" . "\\section*{%s}")
                                        ("\\subsection{%s}" . "\\subsection*{%s}")
                                        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
            (malb/set-org-latex-class "plain-book"
                                      `("\\documentclass[11pt]{book}")
                                      '(("\\part{%s}" . "\\part*{%s}")
                                        ("\\chapter{%s}" . "\\chapter*{%s}")
                                        ("\\section{%s}" . "\\section*{%s}")
                                        ("\\subsection{%s}" . "\\subsection*{%s}")
                                        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))

            ;; backward compatibility
            (add-to-list 'org-latex-classes (cons "org-article" (cdr (assoc "article" org-latex-classes))))))

(use-package ox-koma-letter
  :ensure org
  :after ox-latex
  :config (progn (malb/set-org-latex-class "letter" `("\\documentclass{scrlttr2}\n"
                                                      "\\usepackage{fontspec}\n"
                                                      "[DEFAULT-PACKAGES]\n"
                                                      "[EXTRA]\n")
                                           nil)))
#+end_src

*** Beamer

- _underline_ becomes *bold* in Beamer. ([[https://xgarrido.github.io/emacs-starter-kit/starter-kit-org.html][source]])
- +strikethrough+ becomes grey in Beamer.

#+begin_src emacs-lisp
(use-package ox-beamer
  :ensure nil
  :config (progn
            (add-to-list 'org-beamer-environments-extra
                         '("lemma" "l" "\\begin{lemma}%a" "\\end{lemma}"))

            (defun malb/beamer-underline (contents backend info)
              (when (eq backend 'beamer)
                (replace-regexp-in-string
                 (rx (seq bos "\\" (one-or-more (any alpha digit))))
                 "\\\\textbf"
                 contents)))

            (defun malb/beamer-strikethrough (contents backend info)
              (when (eq backend 'beamer)
                (concat "{"
                        (replace-regexp-in-string
                         (rx (seq bos "\\" (one-or-more (any alpha digit))))
                         "\\\\color{lightgray}"
                         contents)
                        "}")))

            (defun malb/beamer-code (contents backend info)
              (when (eq backend 'beamer)
                (concat (replace-regexp-in-string
                         (rx (seq bos "\\" (one-or-more (any alpha digit))))
                         "\\\\lstinline"
                         contents))))

            (add-to-list 'org-export-filter-underline-functions 'malb/beamer-underline)
            (add-to-list 'org-export-filter-strike-through-functions 'malb/beamer-strikethrough)
            (add-to-list 'org-export-filter-code-functions 'malb/beamer-code)

            (malb/set-org-latex-class "beamer"
                                      `("\\documentclass[presentation,smaller]{beamer}\n"
                                        ,(with-temp-buffer
                                           (insert-file-contents
                                            (expand-file-name "talk-header.tex" user-emacs-directory))
                                           (buffer-string)))
                                      '(("\\section{%s}" . "\\section*{%s}")
                                        ("\\subsection{%s}" . "\\subsection*{%s}")
                                        ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))

            ;; backward compatibility
            (add-to-list 'org-latex-classes (cons "mbeamer" (cdr (assoc "beamer" org-latex-classes))))))
#+end_src

*** ODT

#+begin_src emacs-lisp
(use-package ox-odt
  :ensure nil
  :init (progn
          (setq org-odt-styles-file
                (expand-file-name "org-export-template.ott" user-emacs-directory)
                org-odt-preferred-output-format "docx")))
#+end_src

Enable inline comments in org-export ([[https://gist.github.com/andersjohansson/6baa1e42ad4d7353e125][source]])

#+begin_src emacs-lisp
(load-file (expand-file-name "local/ox-inline-comments.el" user-emacs-directory))
#+end_src

*** Bootstrap

[[https://github.com/marsmining/ox-twbs][ox-twbs]] - Twitter Bootstrap.

#+begin_src emacs-lisp
(use-package ox-twbs)
#+end_src

*** Pandoc

#+begin_src emacs-lisp
(use-package ox-pandoc
  :init (progn
          (setq org-pandoc-menu-entry  '((?m "as md." org-pandoc-export-as-commonmark)
                                         (?M "to md and open." org-pandoc-export-to-commonmark-and-open)
                                         (?x "to docx." org-pandoc-export-to-docx)
                                         (?X "to docx and open." org-pandoc-export-to-docx-and-open)
                                         (?e "to epub." org-pandoc-export-to-epub)
                                         (?E "to epub and open." org-pandoc-export-to-epub-and-open)
                                         (?3 "to epub3." org-pandoc-export-to-epub3)
                                         (?£ "to epub3 and open." org-pandoc-export-to-epub3-and-open)
                                         (?j "as json." org-pandoc-export-as-json)
                                         (?J "to json and open." org-pandoc-export-to-json-and-open)
                                         (?r "as rst." org-pandoc-export-as-rst)
                                         (?R "to rst and open." org-pandoc-export-to-rst-and-open))
                org-pandoc-options '((standalone . t)
                                     (mathjax . t)
                                     (wrap . "preserve")))))
#+end_src

*** Rich Text Clipboard

Place rich text version of selection in clipboard ([[https://melpa.org/#/ox-clip][source]])

#+begin_src emacs-lisp
(use-package ox-clip)
#+end_src

*** HTML Clipboard

#+begin_src emacs-lisp
(defun malb/org-clip-block-to-html ()
  "Copy current block as HTML"
  (interactive)
  (save-restriction
    (save-excursion
      (org-narrow-to-block)
      (let ((text (buffer-string)))
        (with-temp-buffer
          (insert text)
          (org-mode)
          (goto-char (point-min))
          (kill-line)
          (goto-char (point-max))
          (beginning-of-line)
          (kill-line)
          (mark-whole-buffer)
          (org-html-convert-region-to-html)
          (kill-new (buffer-string)))))))
#+end_src

*** Ignore Some Headlines

The tag =:ignore:= ignores a headline when exporting, section content is exported as usual.

#+begin_src emacs-lisp
(use-package ox-extra
  :ensure nil
  :config (ox-extras-activate '(ignore-headlines)))
#+end_src

*** GitHub Flavoured Markdown

Emacs Everywhere wants this (optionally).

#+begin_src emacs-lisp
(use-package ox-gfm)
#+end_src

** Capture

If we are in a project we might add a TODO entry to the appropriate entry in =projects.org=.

#+begin_src emacs-lisp
(defun malb/org-capture-projectile ()
  (if (projectile-project-p)
      (progn
        (let ((malb/projectile-name
               (projectile-project-name)))
          (find-file (expand-file-name "projects.org" malb/org-files-dir))
          (goto-char (point-min))
          (if (re-search-forward (concat "^\* " malb/projectile-name ".*\n") nil t)
              (newline 1)
            (progn
              (goto-char (point-max))
              (insert (concat "* " malb/projectile-name))
              (newline 1)))))
    (progn
      (find-file malb/inbox-org)
      (goto-char (point-min))
      (re-search-forward "^\* Tasks" nil t)
      (newline 1))))
#+end_src

Some helper functions

#+begin_src emacs-lisp
;; https://web.archive.org/web/20181019173343/http://ul.io/nb/2018/04/30/better-code-snippets-with-org-capture
(defun malb/org-capture-get-src-block-string (major-mode)
  "Given a major mode symbol, return the associated org-src block
string that will enable syntax highlighting for that language

E.g. tuareg-mode will return 'ocaml', python-mode 'python', etc..."

  (let ((mm (intern (replace-regexp-in-string (rx (seq (opt "-ts") "-mode"))
                                              ""
                                              (format "%s" major-mode)))))
    (or (car (assoc mm org-babel-load-languages))
        (car (rassoc mm org-src-lang-modes))
        (format "%s" mm))))
#+end_src

#+begin_src emacs-lisp
(defun malb/org-capture-code-snippet (f)
  (with-current-buffer (find-buffer-visiting f)
    (let ((code-snippet (buffer-substring-no-properties (mark) (- (point) 1)))
          (func-name (which-function))
          (file-name (buffer-file-name))
          (line-number (line-number-at-pos (region-beginning)))
          (org-src-mode (malb/org-capture-get-src-block-string major-mode)))
      (format
       "
In [[file:%s::%s][%s]]:

,#+begin_example %s
%s
,#+end_example"
       file-name
       line-number
       func-name
       org-src-mode
       code-snippet))))
#+end_src

#+begin_src emacs-lisp
(defun malb/org-capture-mu4e-after-finalize ()
  ;; TODO, doesn't work any longer
  ;; (mu4e--view-in-headers-context
  ;;  (if (member 'flagged (mu4e-message-field-at-point :flags))
  ;;      (mu4e-mark-set 'unflag)))
  )

(defun malb/mu4e-view-org-capture (arg)
  "Call `org-capture' followed by removing flag from e-mail."
  (interactive "P")
  (mu4e--view-in-headers-context
   (if (member 'flagged (mu4e-message-field-at-point :flags))
       (mu4e-mark-set 'unflag)))
  (org-capture arg))

(bind-key "<f9>" #'malb/mu4e-view-org-capture mu4e-view-mode-map)
#+end_src


#+end_src

#+begin_src emacs-lisp
(defun malb/org-toggle-todo-by-id (id &optional only-today)
  (when (or (not only-today)
            (= (nth 3 (org-decode-time nil))
               (nth 3 (org-decode-time (org-capture-get :default-time)))))
    (save-excursion
      (org-id-goto id)
      (org-todo 'done))
    ;; (winner-undo)
    ))
#+end_src

#+begin_src emacs-lisp
;; https://emacs.stackexchange.com/questions/5923/org-capture-how-to-choose-the-target-file-at-the-end-of-the-process
(defun malb/org-get-target-headline (&optional targets prompt)
  "Prompt for a location in an org file and jump to it.

This is for promping for refile targets when doing captures.
Targets are selected from `org-refile-targets'. If TARGETS is
given it temporarily overrides `org-refile-targets'. PROMPT will
replace the default prompt message."
  (let ((org-refile-targets (or targets '((org-agenda-files :maxlevel . 9))))
        (prompt (or prompt "Capture Location")))
    (org-refile '(t) nil nil prompt)))
#+end_src

*Template Expansions*

| Item                                    | Description                                                                 |
|-----------------------------------------+-----------------------------------------------------------------------------|
| =%[file]=                               | Insert the contents of the file given by file.                              |
| =%(sexp)=                               | Evaluate Elisp sexp and replace with the result.                            |
| =%<...>=                                | The result of format-time-string on the … format specification.             |
| =%t=                                    | Timestamp, date only.                                                       |
| =%T=                                    | Timestamp, with date and time.                                              |
| =%u, %U=                                | Like the above, but inactive timestamps.                                    |
| =%i=                                    | Initial content, the region when capture is called while the region active. |
| =%a=                                    | Annotation, normally the link created with ~org-store-link~.                |
| =%A=                                    | Like =%a=, but prompt for the description part.                             |
| =%l=                                    | Like =%a=, but only insert the literal link.                                |
| =%c=                                    | Current kill ring head.                                                     |
| =%x=                                    | Content of the X clipboard.                                                 |
| =%K=                                    | Link to the currently clocked task.                                         |
| =%k=                                    | Title of the currently clocked task.                                        |
| =%n=                                    | User name (taken from user-full-name).                                      |
| =%f=                                    | File visited by current buffer when org-capture was called.                 |
| =%F=                                    | Full path of the file or directory visited by current buffer.               |
| =%:keyword=                             | Specific information for certain link types, see below.                     |
| =%^g=                                   | Prompt for tags, with completion on tags in target file.                    |
| =%^G=                                   | Prompt for tags, with completion all tags in all agenda files.              |
| =%^t=                                   | Like %t, but prompt for date. Similarly =%^T=, =%^u=, =%^U=.                |
|                                         | You may define a prompt like =%^{Birthday}t=.                               |
| =%^L=                                   | Like %^C, but insert as link.                                               |
| =%^C=                                   | Interactive selection of which kill or clip to use.                         |
| =%^{prop}p=                             | Prompt the user for a value for property prop.                              |
| =%^{prompt}=                            | prompt the user for a string and replace this sequence with it.             |
| =%\n=                                   | Insert the text entered at the nth =%^{prompt}=, where n ≥ 1 is a number.   |
| =%?=                                    | After completing the template, position cursor here.                        |
|-----------------------------------------+-----------------------------------------------------------------------------|
| *Mu4e*                                  |                                                                             |
|-----------------------------------------+-----------------------------------------------------------------------------|
| =%:date=, =%:date-timestamp=            | date, org timestamps                                                        |
| =%:from=, =%:fromname=, =%:fromaddress= | sender, name/address                                                        |
| =%:to=, =%:toname=, =%:toaddress=       | recipient, name/address                                                     |
| =%:maildir=                             | maildir for the message                                                     |
| =%:message-id=                          | message-id                                                                  |
| =%:path=                                | file system path                                                            |
| =%:subject=                             | message subject                                                             |

#+begin_src emacs-lisp
(use-package doct)

(use-package org-capture
  :ensure nil
  :after all-the-icons
  :bind ("<f9>" . org-capture)
  :config
  (progn
    (setq
     org-capture-templates
     (doct
      `((,(format "%s\tTask" (all-the-icons-faicon "check-square-o" :face 'all-the-icons :v-adjust 0.01))
         :keys "t"
         :prepend t
         :empty-lines 1
         :children
         ((,(format "%s\tTask" (all-the-icons-faicon "check-square-o" :face 'all-the-icons :v-adjust 0.01))
           :keys "t"
           :template ("* TODO %?"
                      "%^{schedule|DEADLINE: |SCHEDULED: |}%^t"
                      ":PROPERTIES:"
                      ":CREATED: %U"
                      ":END:"
                      ""
                      "%i")
           :file malb/inbox-org)
          (,(format "%s\tTask in Context" (all-the-icons-faicon "check-square-o" :face 'all-the-icons :v-adjust 0.01))
           :keys "c"
           :template ("* TODO %?"
                      ":PROPERTIES:"
                      ":CREATED: %U"
                      ":END:"
                      ""
                      "%a"
                      ""
                      "%i")
           :file malb/inbox-org)
          (,(format "%s\tTask for Project" (all-the-icons-faicon "check-square-o" :face 'all-the-icons :v-adjust 0.01))
           :keys "p"
           :template ("** TODO %?"
                      ":PROPERTIES:"
                      ":CREATED: %U"
                      ":END:"
                      ""
                      "%i"
                      "%a")
           :type plain
           :function malb/org-capture-projectile)))
        (,(format "%s\tEmail " (all-the-icons-faicon "envelope" :face 'all-the-icons :v-adjust 0.01))
         :keys "e"
         :file malb/inbox-org
         :empty-lines 1
         :children
         ((,(format "%s\tRespond to Email" (all-the-icons-faicon "envelope" :face 'all-the-icons :v-adjust 0.01))
           :keys "r"
           :template  ("* REPLY to %:fromname on %a :email:"
                       "DEADLINE: %(org-insert-time-stamp (org-read-date nil t \"+1d\"))"
                       ":PROPERTIES:"
                       ":CREATED: %U"
                       ":END:"
                       ""
                       "%i")
           :prepend t
           ;; :after-finalize malb/org-capture-mu4e-after-finalize
           :immediate-finish t)
          (,(format "%s\tFile Email" (all-the-icons-faicon "file" :face 'all-the-icons :v-adjust 0.01))
           :keys "f"
           :template  ("- Email %a%? %:date-timestamp-inactive")
           :type item
           :prepend t
           :function malb/org-get-target-headline
           :immediate-finish nil
           :empty-lines 0)
          (,(format "%s\tFile Email Search" (all-the-icons-faicon "search" :face 'all-the-icons :v-adjust 0.01))
           :keys "s"
           :template  ("Query: %a%?")
           :prepend t
           :type item
           :function malb/org-get-target-headline
           :immediate-finish nil
           :empty-lines 0)
          (,(format "%s\tTask" (all-the-icons-octicon "checklist" :face 'all-the-icons :v-adjust 0.01)) :keys "t"
           :file malb/inbox-org
           :template ("* %^{type|TODO|REPLY|READ|REVIEW} %?"
                      "%^{schedule|DEADLINE: |SCHEDULED: |}%^t"
                      ":PROPERTIES:"
                      ":CREATED: %U"
                      ":END:"
                      ""
                      "See %a by %:fromname"
                      "")
           ;; :after-finalize malb/org-capture-mu4e-after-finalize
           :immediate-finish nil
           :prepend t)
          (,(format "%s\tKCL Herrschaftswissen" (all-the-icons-octicon "checklist" :face 'all-the-icons :v-adjust 0.01))
           :keys "k"
           :file malb/work-org
           :headline "King's College London (KCL)"
           :template ("* %?"
                      ":PROPERTIES:"
                      ":CREATED: %U"
                      ":END:"
                      ""
                      "#+begin_quote"
                      "%i"
                      "#+end_quote"
                      ""
                      "— %a by %:fromname"
                      "")
           ;;: after-finalize malb/org-capture-mu4e-after-finalize
           :immediate-finish nil
           :prepend t)
          (,(format "%s\tQuick Task" (all-the-icons-faicon "fast-forward" :face 'all-the-icons :v-adjust 0.01))
           :keys "y"
           :file malb/inbox-org
           :template ("* TODO %a (%:fromname) :email:"
                      "SCHEDULED: %(let ((hour (nth 2 (decode-time (current-time)))))"
                      "                  (if (< hour 16)"
                      "                    (org-insert-time-stamp nil)"
                      "                   (org-insert-time-stamp (org-read-date nil t \"+1d\"))))"
                      ":PROPERTIES:"
                      ":CREATED: %U"
                      ":END:")
           :immediate-finish t
           :prepend t)
          (,(format "%s\tMail Merge" (all-the-icons-faicon "envelope-o" :face 'all-the-icons :v-adjust 0.01))
           :keys "m"
           :file malb/inbox-org
           :template ("* MAIL %?"
                      "SCHEDULED: %^t"
                      ":PROPERTIES:"
                      ":CREATED: %U"
                      ":BCC:"
                      ":END:"
                      ""
                      "#+name: mm-data"
                      "| TO | CC | name |"
                      "|----|----|------|"
                      "|    |    |      |"
                      ""
                      "#+name: mm-template"
                      "#+begin_src markdown"
                      "Hi {{ name }},",
                      ""
                      ""
                      "Cheers,"
                      "Martin"
                      "#+end_src"
                      "")
           :prepend t)
          ))
        (,(format "%s\tQuick Task" (all-the-icons-faicon "fast-forward" :face 'all-the-icons :v-adjust 0.01))
         :keys "y"
         :file malb/inbox-org
         :template ("* TODO %?"
                    "SCHEDULED: %(let ((hour (nth 2 (decode-time (current-time)))))"
                    "                  (if (< hour 16)"
                    "                    (org-insert-time-stamp nil)"
                    "                   (org-insert-time-stamp (org-read-date nil t \"+1d\"))))"
                    ":PROPERTIES:"
                    ":CREATED: %U"
                    ":END:"
                    ""
                    "%i")
         :prepend t)
        (,(format "%s\tReading" (all-the-icons-faicon "book" :face 'all-the-icons :v-adjust 0.01))
         :keys "r"
         :file malb/work-org
         :headline "Reading"
         :template ("* READ %?"
                    "DEADLINE: %^t"
                    ":PROPERTIES:"
                    ":CREATED: %U"
                    ":END:"
                    ""
                    "%i")
         :prepend t
         :empty-lines 1)
        (,(format "%s\tResearch Idea" (all-the-icons-faicon "lightbulb-o" :face 'all-the-icons :v-adjust 0.01))
         :keys "i"
         :file malb/work-org
         :headline "Ideas"
         :template ("* EXPLORE %?"
                    ":PROPERTIES:"
                    ":CREATED: %U"
                    ":END:"
                    ""
                    "%a"
                    "%i")
         :prepend t
         :empty-lines 1)
        ;; (,(format "%s\tJournal" (all-the-icons-faicon "clipboard" :face 'all-the-icons :v-adjust 0.01))
        ;;  :keys "j"
        ;;  :file (lambda () (expand-file-name "journal.org.gpg"
        ;;                                     malb/org-files-dir))
        ;;  :datetree t
        ;;  :olp ("Daily")
        ;;  :type plain
        ;;  :template ,malb/journal-template)
        (,(format "%s\tMeeting" (all-the-icons-faicon "university" :face 'all-the-icons :v-adjust 0.01))
         :keys "m"
         :file malb/inbox-org
         :template ("* Meeting with %^{who}"
                    "%U"
                    ""
                    "%i%?")
         :clock-in t
         :clock-resume t
         :empty-lines 1)
        (,(format "%s\tNote" (all-the-icons-faicon "sticky-note" :face 'all-the-icons :v-adjust 0.01))
         :keys "n"
         :file malb/inbox-org
         :template ("* %?"
                    ":PROPERTIES:"
                    ":CREATED: %U"
                    ":END:"
                    ""
                    "%i")
         :empty-lines 1)
        (,(format "%s\tSoftware Tip" (all-the-icons-faicon "code" :face 'all-the-icons :v-adjust 0.01))
         :keys "s"
         :file (lambda () (expand-file-name "software.org" deft-directory))
         :headline "Incoming"
         :template ("* %?"
                    ":PROPERTIES:"
                    ":CREATED: %U"
                    ":END:"
                    ""
                    "")
         :prepend t
         :empty-lines 1)
        (,(format "%s\tWeight" (all-the-icons-faicon "tachometer"  :face 'all-the-icons :v-adjust 0.01))
         :keys "z"
         :file malb/private-org
         :headline "Weight"
         :type table-line
         :template "| %u | %? | |")
        (,(format "%s\t[External] " (all-the-icons-faicon "firefox" :face 'all-the-icons :v-adjust 0.01))
         :keys "%"
         :children
         ((,(format "%s\tReading" (all-the-icons-faicon "book" :face 'all-the-icons :v-adjust 0.01))
           :keys "r"
           :file malb/work-org
           :headline "Reading"
           :template ("* READ %a%?"
                      "DEADLINE: %^t"
                      ":PROPERTIES:"
                      ":CREATED: %U"
                      ":END:"
                      ""
                      "%i")
           :prepend t
           :empty-lines 1)
          (,(format "%s\tWebsite" (all-the-icons-faicon "globe" :face 'all-the-icons :v-adjust 0.01))
           :keys "w"
           :file malb/inbox-org
           :template ("* %?%a"
                      ":PROPERTIES:"
                      ":CREATED: %U"
                      ":END:")
           :immediate-finish nil
           :prepend t)
          (,(format "%s\tWebsite (selected text)" (all-the-icons-faicon "globe" :face 'all-the-icons :v-adjust 0.01))
           :keys "W"
           :file malb/inbox-org
           ;; :headline "Links"
           :template  ("* %?%a"
                       ":PROPERTIES:"
                       ":CREATED: %U"
                       ":END:"
                       ""
                       "#+begin_quote"
                       "%:initial"
                       "#+end_quote"
                       )
           :immediate-finish nil
           :prepend t))))))

    (setq org-capture-templates-contexts
          '(("er" ((in-mode . "mu4e-view-mode")))
            ("ef" ((in-mode . "mu4e-view-mode")))
            ("et" ((in-mode . "mu4e-view-mode")))
            ("ek" ((in-mode . "mu4e-view-mode")))
            ("ey" ((in-mode . "mu4e-view-mode")))
            ("es" ((in-mode . "mu4e-headers-mode")))))))
#+end_src

Run org-capture [[https://github.com/tumashu/org-capture-pop-frame][in a frame]].

#+begin_src emacs-lisp
(use-package org-capture-pop-frame
  :after (org-capture)
  :config (progn (setq ocpf-frame-parameters '((name . "*Org Capture*")
                                               (width . 120)
                                               (height . 24)
                                               (sticky . t)
                                               (malb/special-frame . t)
                                               (fullscreen . nil)
                                               (tool-bar-lines . 0)
                                               (menu-bar-lines . 0)))

                 (defun ocpf--org-capture (orig-fun &optional goto keys)
                   "Create a new frame and run org-capture."
                   (interactive)
                   (select-frame-set-input-focus (make-frame `(,@ocpf-frame-parameters)))
                   (condition-case nil ;; MALB: handle "q"
                       (funcall orig-fun goto keys)
                     ((debug error) (ocpf--delete-frame))))))
#+end_src

#+begin_src emacs-lisp
(add-to-list 'helm-commands-using-frame 'org-refile)
(add-to-list 'helm-commands-using-frame 'org-agenda-refile)
#+end_src

** Web Tools

#+begin_src emacs-lisp
(use-package org-web-tools
  :after org)
#+end_src

** Eldoc

Activate eldoc and show footnotes in minibuffer.

#+begin_src emacs-lisp
(use-package org-eldoc
  :ensure nil
  :config (progn
            (add-hook 'org-mode-hook #'org-eldoc-load)
            (add-hook 'org-mode-hook #'eldoc-mode)))

(defun malb/org-eldoc-get-footnote (&rest _ignored)
  (save-excursion
    (let ((fn (org-between-regexps-p "\\[fn:" "\\]")))
      (when fn
        (save-match-data
          (nth 3 (org-footnote-get-definition (buffer-substring (+ 1 (car fn)) (- (cdr fn) 1)))))))))

(advice-add 'org-eldoc-documentation-function
            :before-until #'malb/org-eldoc-get-footnote)
#+end_src

** Inline Tasks

#+begin_src emacs-lisp
(use-package org-inlinetask
  :ensure nil
  :config (progn
            (defun malb/org-latex-format-inlinetask-function
                (todo todo-type priority title tags contents info)
              "format function for a inlinetasks.
See `org-latex-format-inlinetask-function' for details."
              (cond
               ((and (> (length todo) 0) (> (length contents) 0))
                (format "\\todo[inline]{\\textbf{%s %s} %s}\n" todo title contents))
               ((and (= (length todo) 0) (> (length contents) 0))
                (format "\\todo[inline]{\\textbf{%s} %s}\n" title contents))
               ((and (> (length todo) 0) (= (length contents) 0))
                (format "\\todo[]{\\textbf{%s} %s}\n" todo title))
               ((and (= (length todo) 0) (= (length contents) 0))
                (format "\\todo[]{%s}\n" title))))
            (setq org-latex-format-inlinetask-function #'malb/org-latex-format-inlinetask-function)
            (setq org-inlinetask-min-level 6)))
#+end_src

** Functions

The equivalent of a TeX-Master. To use add ~eval: (add-hook 'after-save-hook #'malb/org-export-to-latex-main nil t)~ and ~malb.org-main: foo.org~ as file local variables.

#+begin_src emacs-lisp
(defun malb/org-export-to-latex-main ()
  (when (eq major-mode 'org-mode)
    (if (boundp #'malb/org-main)
        (cond ((stringp malb/org-main)
               (with-current-buffer malb/org-main
                 (org-latex-export-to-latex)))
              ((listp malb/org-main)
               (dolist (buffer malb/org-main)
                 (when (get-buffer buffer)
                   (with-current-buffer buffer
                     (org-latex-export-to-latex))))))
      (org-latex-export-to-latex))))
#+end_src

** Org Babel

Working with source code in org-mode.

#+begin_src emacs-lisp
(use-package ob
  :ensure nil
  :config (progn
            ;; load more languages for org-babel
            (org-babel-do-load-languages
             'org-babel-load-languages
             '((python . t)
               (shell . t)
               (latex . t)
               (ditaa . t)
               (sqlite . t)
               (gnuplot . t)
               (C . t)
               (dot . t)
               (plantuml . t)
               (makefile . t)
               (jupyter . t)))          ; must be last

            (setq org-babel-default-header-args:sh    '((:results . "output replace"))
                  org-babel-default-header-args:bash  '((:results . "output replace"))
                  org-babel-default-header-args:shell '((:results . "output replace"))
                  org-babel-default-header-args:jupyter-python '((:async . "yes")
                                                                 (:results . "scalar")
                                                                 (:session . "py")
                                                                 (:exports . "both")
                                                                 (:kernel . "sagemath")))

            (add-to-list 'org-latex-listings-langs '(jupyter-python "python"))

            (setq org-babel-min-lines-for-block-output 4
                  org-confirm-babel-evaluate nil
                  org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar"
                  org-ditaa-jar-path "/usr/share/ditaa/ditaa.jar")

            (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
            ;; TODO this should not be necessary
            (add-to-list 'org-src-lang-modes '("python" . python-ts))
            ;; TODO until org-mode has caught up with auctex 14
            (add-to-list 'org-src-lang-modes '("latex" . LaTeX))))
#+end_src

#+begin_src emacs-lisp
(add-to-list 'display-buffer-alist
             `(,(rx "*Org Src " (zero-or-more nonl) "[" (zero-or-more nonl) "]*")
               (display-buffer-reuse-window
                display-buffer-pop-up-frame)
               (dedicated . t)
               (window-parameters
                (no-other-window . t)
                (no-delete-other-windows . t))
               (pop-up-frame-parameters . ((malb/special-frame . t)
                                           (height . 30)
                                           (width . 160)))))
#+end_src

*** Async

Add =:async= keyword to header-args of any org-babel src block and invoke ~ob-async-org-babel-execute-src-block~.

#+begin_src emacs-lisp
(use-package ob-async
  :after ob
  :init (setq ob-async-no-async-languages-alist '("python" "jupyter-python" "jupyter-julia")
              ob-async-inject-variables "\\`org-babel-[^j].+")
  :config (progn
            (malb/defadvice! malb/no-hide-overlays (orig-fun &rest args)
              :before #'ob-async-org-babel-execute-src-block
              (setq org-babel-hide-result-overlays nil))))
#+end_src

*** To String

#+begin_src emacs-lisp
(defun malb/org-src-to-string (name)
  "Return content of source block with NAME under current heading."
  (save-excursion
    (save-restriction
      (org-narrow-to-subtree)

      (goto-char (point-min))
      (let ((case-fold-search t))
        (search-forward (format "+name: %s" name)))
      (forward-line)
      (forward-line)

      (let ((start (point))
            (case-fold-search t))
        (search-forward (format "#+end_src"))
        (forward-line -1)
        (end-of-line)
        (buffer-substring-no-properties start (point))))))
#+end_src

** Org Download

([[https://github.com/abo-abo/org-download][source]])

This extension facilitates moving images from point A (e.g. an image inside your browser that you can drag to Emacs) to point B (an Emacs org-mode buffer where the inline link will be inserted).

#+begin_src emacs-lisp
(use-package org-download
  :config (progn
            (setq-default org-download-heading-lvl nil)
            (add-hook 'dired-mode-hook 'org-download-enable)))
#+end_src

** Org Chef

[[https://github.com/Chobbes/org-chef][org-chef]]

#+begin_src emacs-lisp
(use-package org-chef)
#+end_src

** Org Wikiinfo

#+begin_src emacs-lisp
(use-package wikinforg)
#+end_src

** Org Dsq

Org interface to to [[https://github.com/multiprocessio/dsq][dsq]].

[[https://fritzgrabo.com/posts/introducing-ob-dsq/][introduction]]

#+begin_src emacs-lisp
(use-package ob-dsq
  :config (add-to-list 'org-latex-listings-langs '(dsq "sql")))
#+end_src

*Example*

#+name: dsq-example
| name   | value |
|--------+-------|
| Foo    |    10 |
| Bar    |    20 |
| Foobar |    30 |

#+begin_src dsq :input dsq-example
SELECT tab.name from {} tab WHERE tab.value >= 20
#+end_src

#+RESULTS:
| name   |
|--------|
| Bar    |
| Foobar |

This also works for =.json=, =.csv= and =.xsls= file.

** Tips

*** Agenda commands

| ~F~         | ~(org-agenda-follow-mode)~           | Toggle Follow mode                                     |
| ~L~         | ~(org-agenda-recenter)~              | Display original location and recenter that window.    |
| ~o~         |                                      | Delete other windows.                                  |
| ~f~         | ~(org-agenda-later)~                 | Go forward in time to display                          |
| ~b~         | ~(org-agenda-earlier)~               | Go backward in time to display earlier dates           |
| ~r~ and ~g~ | ~(org-agenda-redo)~                  | Recreate the agenda buffer.                            |
| ~C-c C-s~   | ~(org-agenda-schedule)~              | Schedule this item.                                    |
| ~C-c C-d~   | ~(org-agenda-deadline)~              | Set a deadline for this item.                          |
| ~S-<right>~ | ~(org-agenda-do-date-later)~         | Change the timestamp by one day into the future.       |
| ~S-<left>~  | ~(org-agenda-do-date-earlier)~       | Change the timestamp by one day into the past.         |
| ~>~         | ~(org-agenda-date-prompt)~           | Change the timestamp associated with the current line. |
| ~m~         | ~(org-agenda-bulk-mark)~             | Mark the entry at point for bulk action.               |
| ~*~         | ~(org-agenda-bulk-mark-all)~         | Mark all visible agenda entries for bulk action.       |
| ~u~         | ~(org-agenda-bulk-unmark)~           | Unmark entry at point for bulk action.                 |
| ~U~         | ~(org-agenda-bulk-remove-all-marks)~ | Unmark all marked entries for bulk action.             |
| ~B~         | ~(org-agenda-bulk-action)~           | Bulk action: act on all marked entries in the agenda.  |
#+TBLFM:

*** Commands I easily forget

- =C-c C-v C-d= splits blocks
- =C-c C-j= calls ~(org-goto)~ which jumps to headlines in a file
- =C-c /= calls ~(org-sparse-tree)~ which reduces the tree to the nodes with some attribute

*** Style

In org-mode we can style inline elements with *bold*, /italic/, _underlined_, =verbatim=, and ~code~. But this breaks if the character just inside the styling code is a non-smart single or double quote. =C-c ;= is styled; =C-c '= is not. We can fix that by inserting a zero-width space between the apostrophe and the = . The first time, we can put the cursor between the apostrophe and the = and enter ~C-x 8 RET ZERO WIDTH SPACE RET~, at which point =C-c '​= will display correctly.

*** Batch Exporting

*Note* the order matters, i.e. open the file first then call =org-latex-export-to-pdf=

#+begin_src shell :tangle no
emacs --batch -l ~/.emacs.d/org-export-init.el file.org -f org-latex-export-to-pdf
#+end_src

* Shells

We don’t need a =$PAGER= here ([[https://github.com/baron42bba/.emacs.d/blob/master/bba.org#eshell-and-shell-environment][source]])

#+begin_src emacs-lisp
(setenv "PAGER" "cat")
(setq shell-file-name "/bin/zsh")
#+end_src

** Toggle Shells

Open various shells at point, close with =x= Config partly stolen from [[https://github.com/syl20bnr/spacemacs/blob/master/layers/shell/packages.el][spacemacs]] and from ([[http://www.howardism.org/Technical/Emacs/eshell-fun.html][source]]).

#+begin_src emacs-lisp
(defun malb/make-toggle-shell (shell-name shell-cmd &optional post-exec per-project enter-exec)
  "Create function to toggle a shell-like thing in current project/directory.

The function behaves as follows:

- The shell-like buffer is renamed to match the current projectile
  project or directory to make multiple windows easier.
- If a buffer of the same name already exists, it is reused.
- If a buffer with the same name is already shown, its window is closed.
- `post-exec` is run after the shell is created.
- `enter-exec` is called before anything else (to set virtualenvs etc)
"
  `(lambda (&optional arg)
     (interactive "P")
     ,enter-exec
     (let* ((parent (if (buffer-file-name)
                        (file-name-directory (buffer-file-name))
                      default-directory))
            (name (if (projectile-project-p)
                      (projectile-project-name)
                    (car (last (split-string parent "/" t)))))
            (buffer-name   (if (and (not arg) ,per-project)
                               (concat "*" ,shell-name
                                       "[" name "]" "*")
                             ,shell-name))
            (window (get-buffer-window buffer-name)))
       (if (malb/window-has-popup-height-p window)
           (progn
             (select-window window)
             (delete-window))
         (progn
           (when (not (get-buffer buffer-name))
             (save-window-excursion
               ,shell-cmd
               (rename-buffer buffer-name)
               ,post-exec))
           (pop-to-buffer buffer-name))))))
#+end_src

** Vterm

[[https://github.com/akermu/emacs-libvterm][Vterm]] is an Emacs terminal using [[http://www.leonerd.org.uk/code/libvterm/][libvterm]]

=C-c C-t= enters copy mode, =<enter>= adds selection to kill ring and leaves copy mode.

#+begin_src emacs-lisp
(use-package vterm
  :commands (malb/toggle-vterm vterm)
  :init (setq vterm-module-cmake-args " -DUSE_SYSTEM_LIBVTERM=no")
  :bind (:map vterm-mode-map
              ("M-<up>"   . vterm-send-up)
              ("M-<down>" . vterm-send-down))
  :config (progn
            (setq vterm-kill-buffer-on-exit t
                  vterm-shell "/bin/zsh")
            (fset 'malb/toggle-vterm
                  (malb/make-toggle-shell
                   "vterm"
                   '(let ((current-prefix-arg nil)) (vterm))
                   '(progn
                      (when (and (boundp 'conda-env-current-name) conda-env-current-name)
                        (vterm-send-string (format "conda activate %s" conda-env-current-name))
                        (vterm-send-return))
                      (vterm-send-string "ls")
                      (vterm-send-return))
                   t))

            (malb/register-popup-window (rx "*vterm["  (0+ any) "*") t)

            (defun malb/vterm-send-C-d-advive (orig-function &rest args)
              (let ((do-kill-frame (and (not (malb/only-frame-p (selected-frame)))
                                        (= (length (window-list)) 1)))
                    (buffer  (current-buffer)))
                (apply orig-function args)
                (sit-for 0.1)
                (if (and do-kill-frame (not (buffer-live-p buffer)))
                    (delete-frame))))

            (advice-add #'vterm-send-C-d :around #'malb/vterm-send-C-d-advive)))
#+end_src

** Term

#+begin_src emacs-lisp
(malb/defadvice! malb/term-handle-exit (&optional process-name msg)
  :after 'term-handle-exit
  (message "%s | %s" process-name msg)
  (kill-buffer (current-buffer)))
#+end_src

** COMMENT [#B] Multi-Term

[[https://www.emacswiki.org/emacs/MultiTerm][MultiTerm]] is a mode based on term.el, for managing multiple terminal buffers in Emacs.

#+begin_src emacs-lisp
(use-package multi-term
  :commands (malb/toggle-multi-term multi-term)
  :config (progn
            (setq term-buffer-maximum-size 16384)

            (add-to-list 'term-bind-key-alist '("S-<left>"  . multi-term-prev))
            (add-to-list 'term-bind-key-alist '("S-<right>" . multi-term-next))
            (add-to-list 'term-bind-key-alist '("TAB" . malb/term-send-tab))
            (add-to-list 'term-bind-key-alist '("C-r" . term-send-reverse-search-history))

            (bind-key "C-y" #'term-paste term-raw-map)

            ;; rebind C-r to the terminal's native one
            (setq term-bind-key-alist (remove* '"C-r" term-bind-key-alist :test 'equal :key 'car))

            (setq multi-term-switch-after-close nil)

            (defun malb/toggle-term-mode ()
              (interactive)
              (if (term-in-char-mode)
                  (term-line-mode)
                (term-char-mode)))

            (defun malb/term-send-tab ()
              "Send tab in term mode."
              (interactive)
              (term-send-raw-string "\t"))

            (fset 'malb/toggle-multi-term
                  (malb/make-toggle-shell "multi-term"
                                          '(let ((current-prefix-arg nil)) (multi-term))
                                          '(progn
                                             (when (and (boundp 'conda-env-current-name) conda-env-current-name)
                                               (insert (format "conda activate %s" conda-env-current-name))
                                               (term-send-input))
                                             (insert "ls")
                                             (term-send-input))
                                          t))))
#+end_src

** Shell

#+begin_src emacs-lisp
(use-package shell
  :config (progn
            (push (cons "\\*shell\\*" display-buffer--same-window-action) display-buffer-alist)

            ;; https://www.emacswiki.org/emacs/multi-shell.el
            (defun malb/comint-close-buffer-when-finished ()
              "This function for close current shell buffer.
When `exit' from shell buffer."
              (when (ignore-errors (get-buffer-process (current-buffer)))
                (set-process-sentinel (get-buffer-process (current-buffer))
                                      (lambda (proc change)
                                        (when (string-match "\\(finished\\|exited\\)" change)
                                          (kill-buffer (process-buffer proc)))))))

            (add-hook 'shell-mode-hook #'toggle-truncate-lines)
            (add-hook 'shell-mode-hook #'malb/comint-close-buffer-when-finished)
            (fset 'malb/toggle-shell
                  (malb/make-toggle-shell "shell" '(shell)  nil t))

            (malb/register-popup-window (rx "*shell["  (0+ any) "*") t)))
#+end_src

** EAT

#+begin_src emacs-lisp
(use-package eat)
#+end_src

** EShell

([[https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org][source]])

#+begin_src emacs-lisp
(use-package eshell
  :after (eat)
  :config (progn

            ;; -------------
            ;; TOGGLE ESHELL
            ;; -------------

            (fset 'malb/toggle-eshell
                  (malb/make-toggle-shell "eshell"
                                          '(eshell "new")
                                          '(progn (insert "ls") (eshell-send-input)) t))

            (malb/register-popup-window (rx "*eshell["  (0+ any) "*") t)

            ;; ------------
            ;; KEY BINDINGS
            ;; ------------

            (defun malb/eshell-keys ()
              (bind-key "<home>" #'eshell-bol eshell-mode-map)
              (bind-key "M-r" #'helm-eshell-history eshell-mode-map)
              (bind-key "M-/" #'helm-esh-pcomplete eshell-mode-map)
              (bind-key "M-w" #'malb/eshell-kill-ring-save eshell-mode-map)
              (bind-key "ESC ." #'malb/eshell-insert-last-word eshell-mode-map)
              (unbind-key "TAB" eshell-cmpl-mode-map))

            ;; https://github.com/bbatsov/emacs-dev-kit/blob/master/eshell-config.el
            ;; for some reason this needs to be a hook
            (add-hook 'eshell-mode-hook #'malb/eshell-keys)

            ;; ---------------
            ;; VISUAL COMMANDS
            ;; ---------------

            ;; (setq eshell-visual-subcommands '(("git" "diff" "show")
            ;;                                   ("tmux" "attach" "new")))

            (defun malb/eshell-add-visual-commands ()
              (add-to-list 'eshell-visual-commands "htop")
              (add-to-list 'eshell-visual-commands "ssh")
              (add-to-list 'eshell-visual-commands "ipython")
              (add-to-list 'eshell-visual-commands "mscdb.sh")
              (add-to-list 'eshell-visual-commands "vim"))

            ;; (add-hook 'eshell-mode-hook #'malb/eshell-add-visual-commands)
            (eat-eshell-mode)
            (eat-eshell-visual-command-mode)
            (setq eshell-visual-commands nil)

            (defun malb/visual-command-frame (old-function &rest arguments)
              (let  ((frame (make-frame '((width . 160) (height . 40)))))
                (select-frame frame)
                (apply old-function arguments)
                ;; (set-process-sentinel (get-buffer-process (current-buffer))
                ;;                       (lambda (proc change)
                ;;                         (when (string-match "\\(finished\\|exited\\)" change)
                ;;                           (delete-frame (window-frame
                ;;                                          (get-buffer-window
                ;;                                           (process-buffer proc)))))))
                (set-window-dedicated-p (get-buffer-window) t)
                (set-frame-parameter frame 'malb/special-frame t)))

            (advice-add #'eshell-exec-visual :around #'malb/visual-command-frame)

            ;; -------
            ;; ALIASES
            ;; -------

            ;; https://github.com/algernon/emacs.d/blob/master/layers/%2Bapps/algernon-eshell/packages.el#L85-L95
            (defun eshell/git (command &rest args)
              (pcase command
                ("status" (progn
                            (magit-status)
                            (eshell/echo)))
                (_ (let ((command (s-join " " (flatten-list (list "git" command args)))))
                     (message command)
                     (shell-command-to-string command)))))

            (defun eshell/conda (command &rest args)
              (pcase command
                ("activate"   (progn (conda-env-activate (car args))))
                ("deactivate" (progn (conda-env-deactivate)))
                (_ (let ((command (s-join " " (flatten-list (list "conda" command args)))))
                     (message command)
                     (shell-command-to-string command)))))

            ;; mapped to 'x' in eshell
            (defun eshell/x ()
              (delete-window)
              (eshell/exit))

            (defalias 'eshell/q     'malb/quit-bottom-disposable-windows)
            (defalias 'eshell/en    'find-file)
            (defalias 'eshell/e     'find-file)
            (defalias 'eshell/vim   'find-file) ;; muscle memory
            (defalias 'eshell/d     'dired)
            (defalias 'eshell/emacs 'find-file)
            (defalias 'eshell/less  'view-file)

            (require 'helm-find)

            (defun eshell/fd (pattern &optional path)
              (let ((default-directory (file-name-as-directory (or path default-directory)))
                    (helm-display-function #'helm-display-buffer-in-own-frame))
                (helm :sources 'helm-source-findutils
                      :buffer "*helm find*"
                      :input pattern
                      :ff-transformer-show-only-basename nil
                      :case-fold-search helm-file-name-case-fold-search)))

            (defun eshell/ag (pattern &optional path)
              (let ((helm-display-function #'helm-display-buffer-in-own-frame))
                (helm-do-ag (file-name-as-directory (or path default-directory)) nil pattern)))

            (defun eshell/clear ()
              "Clear the eshell buffer."
              (let ((inhibit-read-only t))
                (erase-buffer)
                (eshell-send-input)))

            (setq eshell-input-filter #'eshell-input-filter-initial-space)

            (defun eshell/disable-eshell-history ()
              (setq-local eshell-input-filter (lambda (input) nil))
              nil)

            (defun eshell/enable-eshell-history ()
              (setq-local eshell-input-filter #'eshell-input-filter-initial-space)
              nil)

            ;; -----------
            ;; MINOR MODES
            ;; -----------

            (defun malb/eshell-minor-modes ()
              (smartparens-mode t)
              (let ((bracket-qualifiers '(sp-point-before-word-p
                                          sp-point-before-same-p)))
                (sp-with-modes '(eshell-mode)
                  (sp-local-pair "\"" "\"" :unless bracket-qualifiers)
                  (sp-local-pair  "(" ")"  :unless bracket-qualifiers)
                  (sp-local-pair  "[" "]"  :unless bracket-qualifiers))))

            (add-hook 'eshell-mode-hook #'malb/eshell-minor-modes)

            ;; --------------------
            ;; COPY PREVIOUS OUTPUT
            ;; --------------------

            ;; http://fasciism.com/2017/01/27/eshell-kill-previous-output/
            (defun eshell/kpo (&optional nth)
              "Copies the output of the previous command to the kill ring.
When nth is set, it will copy the nth previous command."
              (save-excursion
                ;; Move to the end of the eshell buffer.
                (goto-char (point-max))
                ;; Move to the start of the last prompt.
                (search-backward-regexp eshell-prompt-regexp nil nil nth)
                ;; Move to the start of the line, before the prompt.
                (beginning-of-line)
                ;; Remember this position as the end of the region.
                (let ((end (point)))
                  ;; Move to the start of the last prompt.
                  (search-backward-regexp eshell-prompt-regexp)
                  ;; Move one line below the prompt, where the output begins.
                  (next-line)
                  ;; Find first line that's not blank.
                  (while (looking-at "^[[:space:]]*$")
                    (beginning-of-line)
                    (next-line))
                  ;; Copy region to kill ring.
                  (copy-region-as-kill (point) end)
                  ;; Output stats on what was copied as a sanity check.
                  (format "Copied %s words to kill ring." (count-words-region (point) end)))))

            (defun malb/eshell-kill-ring-save (arg)
              "Copy selection or previous command's output to kill ring."
              (interactive "P")
              (if (or arg (region-active-p))
                  (call-interactively #'kill-ring-save)
                (eshell/kpo)))

            ;; --------------
            ;; TAB COMPLETION
            ;; --------------

            (defun malb/config-eshell-completion ()
              (setq pcomplete-cycle-completions t
                    pcomplete-ignore-case t)
              (setq-local company-idle-delay 1.0
                          company-backends '((company-files :with company-yasnippet)
                                             (company-capf  :with company-yasnippet)))
              (define-key eshell-mode-map [remap eshell-pcomplete]
                          (lambda ()
                            (interactive)
                            (let ((completion--capf-misbehave-funs nil))
                              (call-interactively #'company-capf)))))

            (add-hook 'eshell-mode-hook #'malb/config-eshell-completion)


            ;; -----
            ;; ESC-.
            ;; -----

            ;; https://gist.github.com/kanru/8680931
            (defun malb/eshell-last-argument (n)
              (let* ((input (substring-no-properties
                             (eshell-previous-input-string (1- n))))
                     (parse (with-temp-buffer
                              (insert input)
                              (car (reverse (eshell-parse-arguments
                                             (point-min) (point-max)))))))
                (eval parse)))

            ;; https://gist.github.com/kanru/8680931
            (defun malb/eshell-insert-last-word (n)
              (interactive "p")
              (unless (eq last-command this-command)
                (put 'malb/eshell-insert-last-word 'pre-n n)
                (put 'malb/eshell-insert-last-word 'pre-p nil))
              (let ((n (get 'malb/eshell-insert-last-word 'pre-n))
                    (pre-p (get 'malb/eshell-insert-last-word 'pre-p)))
                (when pre-p
                  (delete-region pre-p (point)))
                (put 'malb/eshell-insert-last-word 'pre-n (1+ n))
                (put 'malb/eshell-insert-last-word 'pre-p (point))
                (if (s-contains-p " " (malb/eshell-last-argument n))
                    (insert "\"" (malb/eshell-last-argument n) "\"")
                  (insert (malb/eshell-last-argument n) ))))

            ;;
            ;; https://github.com/howardabrams/hamacs/blob/main/ha-eshell.org#last-results
            ;;
            (defvar malb/eshell-output (make-ring 10)
              "A ring (looped list) storing history of eshell command output.")

            (defun malb/eshell-store-last-output ()
              "Store the output from the last eshell command.
            Called after every command by connecting to the `eshell-post-command-hook'."
              (let ((output
                     (buffer-substring-no-properties eshell-last-input-end eshell-last-output-start)))
                (ring-insert malb/eshell-output output)))

            (add-hook 'eshell-post-command-hook 'malb/eshell-store-last-output)

            (defun eshell/output (&rest args)
              "Return an eshell command output from its history.

The first argument is the index into the historical past, where
`0' is the most recent, `1' is the next oldest, etc.

The second argument represents the returned output:
 ,* `text' :: as a string
 ,* `list' :: as a list of elements separated by whitespace
 ,* `file' :: as a filename that contains the output

If the first argument is not a number, it assumes the format
to be `:text'.
"
              (let (frmt element)
                (cond
                 ((> (length args) 1)  (setq frmt (cadr args)
                                             element (car args)))
                 ((= (length args) 0)  (setq frmt "text"
                                             element 0))
                 ((numberp (car args)) (setq frmt "text"
                                             element (car args)))
                 ((= (length args) 1)  (setq frmt (car args)
                                             element 0)))

                (if-let ((results (ring-ref malb/eshell-output (or element 0))))
                    (cl-case (string-to-char frmt)
                      (?l     (split-string results))
                      (?f     (malb/eshell-store-file-output results))
                      (otherwise (s-trim results)))
                  "")))

            (defun malb/eshell-store-file-output (results)
              "Writes the string, RESULTS, to a temporary file and returns that file name."
              (let ((filename (make-temp-file "malb-eshell-")))
                (with-temp-file filename
                  (insert results))
                filename))

            (defvar eshell-variable-aliases-list nil "Autoloading this eshell-defined variable")
            (add-to-list 'eshell-variable-aliases-list '("$"  malb/eshell-output-text))
            (add-to-list 'eshell-variable-aliases-list '("_"  malb/eshell-output-list))
            (add-to-list 'eshell-variable-aliases-list '("OUTPUT" malb/eshell-output-file))

            (defun malb/eshell-output (format-type indices)
              "Wrapper around `eshell/output' for the `eshell-variable-aliases-list'."
              (if indices
                  (eshell/output (string-to-number (caar indices)) format-type)
                (eshell/output 0 format-type)))

            (defun malb/eshell-output-text (&optional indices &rest ignored)
              "A _text_ wrapper around `eshell/output' for the `eshell-variable-aliases-list'."
              (malb/eshell-output "text" indices))

            (defun malb/eshell-output-list (&optional indices &rest ignored)
              "A _list_ wrapper around `eshell/output' for the `eshell-variable-aliases-list'."
              (malb/eshell-output "list" indices))

            (defun malb/eshell-output-file (&optional indices &rest ignored)
              "A _file_ wrapper around `eshell/output' for the `eshell-variable-aliases-list'."
              (malb/eshell-output "file" indices))

            ;; ------
            ;; CONFIG
            ;; ------

            (setq eshell-scroll-to-bottom-on-input t
                  eshell-destroy-buffer-when-process-dies t
                  eshell-history-size 8192
                  eshell-buffer-maximum-lines 16384
                  eshell-hist-ignoredups t
                  eshell-list-files-after-cd t
                  eshell-ls-initial-args "-hk"
                  eshell-buffer-shorthand t
                  eshell-plain-echo-behavior t)))
#+end_src

*** COMMENT Plan 9 Smart Shell

([[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][source]])

#+begin_src emacs-lisp
(use-package em-smart
  :ensure nil
  :custom ((eshell-where-to-jump 'end)
           (eshell-review-quick-commands 'not-even-short-output)
           (eshell-smart-space-goes-to-end t))
  :config (add-hook 'eshell-mode-hook #'eshell-smart-initialize))
#+end_src

*** Git Prompt

#+begin_src emacs-lisp
(use-package eshell-git-prompt
  :config (progn (eshell-git-prompt-use-theme "powerline")))
#+end_src

*** Tips

Cat directly into a buffer (select with =C-c M-b=)

#+begin_src shell :tangle no
cat mylog.log >> #<buffer *scratch*>
#+end_src

** ZSH History

#+begin_src emacs-lisp
(defvar malb/helm-c-source-zsh-history
  '((name . "Zsh History")
    (candidates . malb/helm-c-zsh-history-set-candidates)
    (action . (("Insert" . malb/helm-c-zsh-history-insert)
               ("Execute" . malb/helm-c-zsh-history-run)))
    (volatile)
    (requires-pattern . 3)
    (delayed)))

(defun malb/helm-c-zsh-history-set-candidates (&optional request-prefix)
  (let ((pattern (replace-regexp-in-string
                  " " ".*"
                  (or (and request-prefix
                           (concat request-prefix
                                   " " helm-pattern))
                      helm-pattern))))
    (with-current-buffer (find-file-noselect "~/.zsh_history" t t)
      (auto-revert-mode -1)
      (goto-char (point-max))
      (cl-loop for pos = (re-search-backward pattern nil t)
               while pos
               collect (replace-regexp-in-string
                        "\\`:.+?;" ""
                        (buffer-substring (line-beginning-position)
                                          (line-end-position)))))))

(defun malb/helm-c-zsh-history-insert (candidate)
  (insert candidate))

(defun malb/helm-c-zsh-history-run (candidate)
  (malb/named-compile candidate))

(defun malb/helm-command-from-zsh ()
  (interactive)
  (require 'helm)
  (helm-other-buffer 'malb/helm-c-source-zsh-history "*helm zsh history*"))
#+end_src

** Detached

#+begin_quote
=detached.el= is a package to launch, and manage, detached processes. The idea is that these processes are detached from the Emacs process and the package can make Emacs seamlessly attach to these processes. This enables users to launch processes that can survive when Emacs itself is being shutdown. The package relies on the program dtach, in order to make this functionality possible. — [[https://sr.ht/~niklaseklund/detached.el/][detached.el]]
#+end_quote

- =Shift-Enter= runs a command in detached mode

#+begin_src emacs-lisp
(use-package detached
  :init (detached-init)
  :ensure-system-package ((dtach . dtach))
  :bind (;; Replace `async-shell-command' with `detached-shell-command'
         ([remap async-shell-command] . detached-shell-command))
  :custom ((detached-show-output-on-attach t)
           (detached-terminal-data-command system-type))

  :config (progn
            (defun malb/detached-state-transition-notifications-message (session)
              "Issue a notification when SESSION transitions from active to inactive.
This function uses the `notifications' library."
              (let ((status (detached-session-status session))
                    (host (detached-session-host-name session)))
                (notifications-notify
                 :title (pcase status
                          ('success (format "Detached finished [%s]" host))
                          ('failure (format "Detached failed [%s]" host)))
                 :body (detached-session-command session)
                 :urgency (pcase status
                            ('success 'normal)
                            ('failure 'normal))
                 ;; malb: added timeout
                 :timeout (pcase status
                            ('success 10000)
                            ('failure 60000)))))
            (setq detached-notification-function #'malb/detached-state-transition-notifications-message)))
#+end_src

** Yakuake

… still my main shell, let’s make sure we can get there quickly.

#+begin_src sh :tangle no
#!/usr/bin/env bash
if [ -z $(wmctrl -xl | grep -iF 'yakuake.yakuake' | head -n1 | cut -d' ' -f1) ]; then
    qdbus org.kde.yakuake /yakuake/window toggleWindowState;
fi
qdbus org.kde.yakuake /yakuake/sessions org.kde.yakuake.addSession;
qdbus org.kde.yakuake /yakuake/sessions org.kde.yakuake.runCommand "cd $1" >/dev/null 2>&1 &
#+end_src

#+begin_src emacs-lisp
(defun malb/ykcd ()
  (interactive)
  (let ((fn (or (buffer-file-name) "~")))
    (shell-command (concat "ykcd " (file-name-directory fn)))))
#+end_src

* Programming (Languages)
** General
*** REPL / Comint

We want to pick previous inputs based on prefix ([[https://emacs.stackexchange.com/questions/14072/replicate-ipython-history-behaviour-in-emacs][source]])

#+begin_src emacs-lisp
(use-package comint
  :ensure nil
  :config (progn
            (dolist (key '("C-<up>" "M-<up>" "M-p"))
              (bind-key key #'comint-previous-matching-input-from-input comint-mode-map))
            (dolist (key '("C-<down>" "M-<down>" "M-n"))
              (bind-key key #'comint-next-matching-input-from-input comint-mode-map))

            (bind-key "M-r" #'helm-comint-input-ring comint-mode-map)

            (setq comint-scroll-to-bottom-on-input t ; always insert at the bottom
                  comint-scroll-to-bottom-on-output nil
                  comint-input-ignoredups t ; no duplicates in command history
                  comint-prompt-read-only t ; don’t overwrite prompt
                  comint-move-point-for-output t)

            (defun malb/kill-buffer-delete-window ()
              (interactive)
              (let ((kill-buffer-query-functions nil))
                (kill-buffer)))

            (defun malb/kill-buffer (old-function &rest arguments)
              (apply old-function arguments)
              (let ((kill-buffer-query-functions nil))
                (kill-buffer)))

            (advice-add 'comint-send-eof :around  #'malb/kill-buffer)

            (defun malb/comint-kill-ring-save (arg)
              "Copy selection or previous command's output to kill ring."
              (interactive "P")
              (if (or arg (region-active-p))
                  (call-interactively #'kill-ring-save)
                (let ((proc (get-buffer-process (current-buffer)))
                      (inhibit-read-only t))
                  (let ((end (save-excursion
                               (goto-char (process-mark proc))
                               (forward-line 0)
                               (point)))
                        (start (save-excursion
                                 (goto-char comint-last-input-start)
                                 (forward-line 0)
                                 (point))))
                    (copy-region-as-kill start end)))))

            (bind-key "M-w" #'malb/comint-kill-ring-save comint-mode-map)
            (bind-key "C-S-w" #'malb/kill-buffer-delete-window comint-mode-map)))
#+end_src

***** Comint History Across Sessions

[[https://oleksandrmanzyuk.wordpress.com/2011/10/23/a-persistent-command-history-in-emacs/][source]]

Directory where comint history will be stored

  #+begin_src emacs-lisp
(defvar malb/comint-history-dir (locate-user-emacs-file "comint-history"))

(unless (file-exists-p malb/comint-history-dir)
  (make-directory malb/comint-history-dir))
  #+end_src

Function to write comint history on exit

  #+begin_src emacs-lisp
(defun malb/comint-write-history-on-exit (process event)
  (comint-write-input-ring)
  (let ((buf (process-buffer process)))
    (when (buffer-live-p buf)
      (with-current-buffer buf
        (insert (format "\nProcess %s %s" process event))))))
  #+end_src

Function to setup comint history

  #+begin_src emacs-lisp
(defun malb/turn-on-comint-history ()
  (let ((process (get-buffer-process (current-buffer))))
    (when process
      (setq-local comint-input-ring-file-name
                  (expand-file-name (format
                                     "inferior-%s-history"
                                     (process-name process))
                                    malb/comint-history-dir))
      (comint-read-input-ring t)
      (add-hook 'kill-buffer-hook #'comint-write-input-ring t t)
      (set-process-sentinel process #'malb/comint-write-history-on-exit))))
  #+end_src

Setup comint history on comint start

  #+begin_src emacs-lisp
(add-hook 'comint-mode-hook #'malb/turn-on-comint-history)
  #+end_src

Save comint history when emacs is killed

  #+begin_src emacs-lisp
(defun malb/comint-write-input-ring-all-buffers ()
  (mapc (lambda (buffer)
          (with-current-buffer buffer
            (comint-write-input-ring)))
        (buffer-list)))

(add-hook 'kill-emacs-hook #'malb/comint-write-input-ring-all-buffers)
  #+end_src

*** Spell Checking

Enable spell checking in comments and documentation.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+end_src

*** Flycheck

[[https://raw.githubusercontent.com/flycheck/flycheck/master/doc/images/flycheck-annotated.png]] ([[http://www.flycheck.org/images/screencast.gif][source]])

Use [[https://github.com/flycheck/flycheck][Flycheck]] to run static checkers on code. We use clang’s checker for flycheck for which we can load per directory configuration using =.dir-locals.el=, e.g.

#+begin_src emacs-lisp :tangle no
((c-ts-mode . ((flycheck-clang-include-path . ("/FULL/PATH/TO/DIR1" "/FULL/PATH/TO/DIR2" ) ))))
#+end_src

Make flycheck prettier based on what spacemacs does.

#+begin_src emacs-lisp
(use-package flycheck
  :blackout flycheck-mode

  :config (progn
            (global-flycheck-mode)
            (add-hook 'org-mode-hook (lambda () (flycheck-mode -1)))

            (bind-key "C-c f n" #'flycheck-next-error flycheck-mode-map)
            (bind-key "C-c f p" #'flycheck-previous-error flycheck-mode-map)
            (bind-key "C-c f l" #'flycheck-list-errors flycheck-mode-map)

            (setq flycheck-check-syntax-automatically '(save mode-enabled)
                  flycheck-standard-error-navigation nil
                  flycheck-flake8-maximum-line-length 120)

            (when (fboundp 'define-fringe-bitmap)
              (define-fringe-bitmap 'my-flycheck-fringe-indicator
                (vector #b00000000
                        #b00000000
                        #b00000000
                        #b00000000
                        #b00011000
                        #b01111110
                        #b11111111
                        #b11111111
                        #b11111111
                        #b11111111
                        #b11111111
                        #b01111110
                        #b00011000
                        #b00000000
                        #b00000000
                        #b00000000
                        #b00000000)))


            (flycheck-define-error-level 'error
              :overlay-category 'flycheck-error-overlay
              :fringe-bitmap 'my-flycheck-fringe-indicator
              :fringe-face 'flycheck-fringe-error)

            (flycheck-define-error-level 'warning
              :overlay-category 'flycheck-warning-overlay
              :fringe-bitmap 'my-flycheck-fringe-indicator
              :fringe-face 'flycheck-fringe-warning)

            (flycheck-define-error-level 'info
              :overlay-category 'flycheck-info-overlay
              :fringe-bitmap 'my-flycheck-fringe-indicator
              :fringe-face 'flycheck-fringe-info)
            ))
#+end_src

Use [[https://github.com/yasuyk/helm-flycheck][helm-flycheck]] because reasons.

#+begin_src emacs-lisp
(use-package helm-flycheck
  :after flycheck
  :config (progn
            (bind-key "C-c f h" #'helm-flycheck flycheck-mode-map)))
#+end_src

[[https://raw.githubusercontent.com/flycheck/flycheck-pos-tip/master/screenshot.png]]

Use [[https://github.com/flycheck/flycheck-pos-tip][flycheck-pos-tip]] to display hints about potential issues.

#+begin_src emacs-lisp
(use-package flycheck-pos-tip
  :after flycheck
  :init (progn
          ;; flycheck errors on a tooltip (doesnt work on console)
          (with-eval-after-load 'flycheck
            (flycheck-pos-tip-mode))))
#+end_src

*** Comments

Comments, as I mean, using [[https://github.com/remyferre/comment-dwim-2][comment-dwim-2]].

#+begin_src emacs-lisp
(use-package comment-dwim-2
  :bind ("M-;" . comment-dwim-2)
  :config (setq cd2/region-command #'cd2/comment-or-uncomment-region))
#+end_src

Make bug references in comments and string clickable

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'bug-reference-prog-mode)
#+end_src

*** Indenting
**** Obey Project Rules

[[https://github.com/jscheid/dtrt-indent][drt-indent]] guesses the indentation offset originally used for creating source code files and transparently adjusts the corresponding settings in Emacs, making it more convenient to edit foreign files.

#+begin_src emacs-lisp
(use-package dtrt-indent
  :blackout dtrt-indent-mode
  :config (progn (dtrt-indent-global-mode t)))
#+end_src

**** Agressive Indenting

[[https://github.com/Bruce-Connor/aggressive-indent-mode][aggressive-indent-mode]] for … aggressive indenting.

[[https://github.com/Malabarba/aggressive-indent-mode/raw/master/c-example.gif]] ([[https://github.com/Malabarba/aggressive-indent-mode/raw/master/c-example.gif][source]])

Enable it on a per-project basis in order to keep RC check ins clean: use it in own projects but not necessarily in projects where not the main contributor. Use =.dir-locals.el= to enable it, e.g.:

#+begin_src emacs-lisp :tangle no
((c-ts-mode . ((aggressive-indent-mode t))))
#+end_src

#+begin_src emacs-lisp
(use-package aggressive-indent
  :hook ((emacs-lisp-mode-hook . aggressive-indent-mode)
         (lisp-data-mode . aggressive-indent-mode))
  :config (unbind-key "C-c C-q" aggressive-indent-mode-map)
  :blackout aggressive-indent-mode)
#+end_src

*** Trailing whitespace

[[https://github.com/lewang/ws-butler][ws-buttler]] for not leaving trailing white spaces without being that guy™.

#+begin_src emacs-lisp
(use-package ws-butler
  :blackout ws-butler-mode
  :config (progn
            ;; adding it to prog-mode-hook causes problems for emacsclient
            (add-hook 'cython-mode-hook     #'ws-butler-mode)
            (add-hook 'LaTeX-mode-hook      #'ws-butler-mode)
            (add-hook 'emacs-lisp-mode-hook #'ws-butler-mode)))
#+end_src

*** Highlight FIXME and friends

#+begin_src emacs-lisp
(defun malb/fixme-highlight ()
  (font-lock-add-keywords nil
                          '(("\\<\\(FIXME\\|BUG\\|TODO\\|HACK\\|NOTE\\)" 1
                             font-lock-warning-face t))))

(add-hook 'prog-mode-hook #'malb/fixme-highlight)
#+end_src

*** Which Function

Show function in mode-line ([[https://github.com/howardabrams/dot-files/blob/master/emacs-mode-line.org][source]])

#+begin_src emacs-lisp
(use-package which-func
  :config (progn
            (which-function-mode 1)
            (setq which-func-unknown ""
                  which-func-maxout 1024
                  which-func-modes '(latex-mode
                                     LaTeX-mode
                                     markdown-mode
                                     c-mode
                                     c-ts-mode
                                     emacs-lisp-mode
                                     org-mode
                                     c++-mode
                                     c++-ts-mode))

            (setq which-func-format
                  `(" "
                    (:propertize which-func-current local-map
                                 (keymap
                                  (mode-line keymap
                                             (mouse-3 . end-of-defun)
                                             (mouse-2 . narrow-to-defun)
                                             (mouse-1 . beginning-of-defun)))
                                 face which-func
                                 mouse-face mode-line-highlight
                                 help-echo "mouse-1: go to beginning\n\
mouse-2: toggle rest visibility\n\
mouse-3: go to end")
                    " "))
            ))
#+end_src

*** Highlight Symbols

[[https://github.com/wolray/symbol-overlay][symbol-overlay]] for highlighting symbols.

#+begin_src emacs-lisp
(use-package symbol-overlay
  :bind ("M-s h ." . symbol-overlay-put)
  :config (setq symbol-overlay-faces '((t (:background "#b58900" :foreground "black"))
                                       (t (:background "#cb4b16" :foreground "white"))
                                       (t (:background "#dc322f" :foreground "white"))
                                       (t (:background "#d33682" :foreground "white"))
                                       (t (:background "#6c71c4" :foreground "white"))
                                       (t (:background "#268bd2" :foreground "white"))
                                       (t (:background "#2aa198" :foreground "black"))
                                       (t (:background "#859900" :foreground "black")))))
#+end_src

*** Highlight Stuff

#+begin_src emacs-lisp
(use-package hi-lock
  :ensure nil
  :config (setq hi-lock-auto-select-face t))
#+end_src

*** Looking Stuff Up (Devdocs)

Browse [[https://devdocs.io][devdocs.io]] documents inside Emacs

#+begin_src emacs-lisp
(use-package devdocs-browser
  :bind ("C-c h ." . devdocs-browser-open)
  :config (malb/register-right-side-window (rx "*devdocs") t))
#+end_src

*** GNU Global

Use GNU Global for Java ([[https://tuhdo.github.io/c-ide.html][source]]) and optionally for C++

#+begin_src emacs-lisp
(use-package ggtags
  :commands ggtags-mode
  :bind (:map ggtags-mode-map
              ("C-c j g s" . ggtags-find-other-symbol)
              ("C-c j g h" . ggtags-view-tag-history)
              ("C-c j g r" . ggtags-find-reference)
              ("C-c j g f" . ggtags-find-file)
              ("C-c j g c" . ggtags-create-tags)
              ("C-c j g u" . ggtags-update-tags))
  :config (progn (unbind-key "M-." ggtags-mode-map)
                 (unbind-key "M-," ggtags-mode-map)
                 (unbind-key "C-M-." ggtags-mode-map)))
#+end_src

#+begin_src emacs-lisp
(use-package helm-gtags
  :init (setq helm-gtags-prefix-key "\C-cjg")
  :commands helm-gtags-mode
  :blackout helm-gtags-mode
  :bind (:map helm-gtags-mode-map
              ("C-c j g a"  . helm-gtags-tags-in-this-function)
              ("C-c j g j"  . helm-gtags-select)
              ("C-c j g ."  . helm-gtags-dwim)
              ("C-c j g ,"  . helm-gtags-pop-stack)
              ("C-c j g <"  . helm-gtags-previous-history)
              ("C-c j g >"  . helm-gtags-next-history))
  :config (setq helm-gtags-ignore-case t
                helm-gtags-auto-update t
                helm-gtags-use-input-at-cursor t
                helm-gtags-pulse-at-cursor t))
#+end_src

*** Dumb & Smart Jump

zero-config [[https://github.com/jacktasia/dumb-jump][jump to definition]] for JavaScript, Emacs Lisp, Python, Go, Clojure, …

- =dumb-jump-go= =C-c j d .= core functionality. Attempts to jump to the definition for the thing under point
- =dumb-jump-back= =C-c j d ,= jumps back to where you were when you jumped. These are chained so if you go down a rabbit hole you can get back out or where you want to be.
- =dumb-jump-quick-look= =C-c j d q= like =dumb-jump-go= but shows tooltip with file, line, and context

#+begin_src emacs-lisp
(use-package dumb-jump
  :bind (:map dumb-jump-mode-map
         ("C-c j d ." . dumb-jump-go)
         ("C-c j d ," . dumb-jump-back)
         ("C-c j d q" . dumb-jump-quick-look))
  :config (progn
            (setq dumb-jump-selector 'helm)
            (unbind-key "C-M-g" dumb-jump-mode-map)
            (unbind-key "C-M-p" dumb-jump-mode-map)
            (unbind-key "C-M-q" dumb-jump-mode-map)
            (dumb-jump-mode)))
#+end_src

#+begin_quote
This packages tries to smartly go to definition leveraging several methods to do so. If one method fails, this package will go on to the next one, eventually falling back to dumb-jump. — [[https://github.com/jojojames/smart-jump][smart-jump]]
#+end_quote

#+begin_src emacs-lisp
(use-package smart-jump
  :custom ((smart-jump-default-mode-list '(cc-mode
                                           csharp-mode
                                           clojure-mode
                                           elixir-mode
                                           go-mode
                                           lisp-mode
                                           ruby-mode
                                           rust-mode
                                           scheme
                                           typescript-mode)))
  :config (smart-jump-setup-default-registers))
#+end_src

*** Debuggers

[[https://github.com/realgud/realgud][All the debuggers]]

#+begin_src emacs-lisp
(use-package realgud
  :commands (realgud:pdb realgud:ipdb realgud:trepan2 realgud:gdb)
  :config (progn
            (setq realgud:pdb-command-name "python -m pdb")))
#+end_src

#+begin_src emacs-lisp
(setq gdb-find-source-frame t
      gdb-many-windows t)
#+end_src

*** CamelCase

#+begin_src emacs-lisp
(use-package string-inflection)
#+end_src

*** Code Formatting

#+begin_quote
Auto-format source code in many languages with one command – [[https://github.com/lassik/emacs-format-all-the-code][format-all]]
#+end_quote

#+begin_src emacs-lisp
(use-package format-all)
#+end_src

****** TODO It would be nice to use this to replace the various other modes floating around
****** END

*** Jupyter

[[https://github.com/dzop/emacs-jupyter][emacs-jupyter]] is an Emacs frontend to Jupyter kernels

#+begin_src emacs-lisp
(use-package jupyter
  :commands (jupyter-run-server-repl
             jupyter-run-repl
             jupyter-server-list-kernels)
  :defer 2
  :bind (:map jupyter-repl-mode-map
              ("M-<up>" . jupyter-repl-history-previous-matching)
              ("C-<up>" . jupyter-repl-history-previous-matching)
              ("M-<down>" . jupyter-repl-history-next-matching)
              ("C-<down>" . jupyter-repl-history-next-matching)
              ("C-d"    . malb/delchar-or-maybe-eof))
  :init (eval-after-load 'jupyter-org-extensions
          '(unbind-key "C-c h" jupyter-org-interaction-mode-map))
  :config (progn
            (defun malb/jupyter-company-completion ()
              (setq-local company-backends
                          '((:separate company-files
                                       company-math-symbols-unicode
                                       company-yasnippet
                                       company-capf
                                       ))))

            (add-hook 'jupyter-repl-mode-hook #'malb/jupyter-company-completion)

            ;; =C-d= should kill the repl (and kernel) when pressed at end of buffer.
            (defun malb/delchar-or-maybe-eof (arg)
              (interactive "p")
              (if (eobp)
                  ;; kill client and kernel
                  (cl-letf (((symbol-function 'yes-or-no-p) (lambda (prompt) t)))
                    (kill-buffer))
                (delete-char arg)))

            (malb/register-right-side-window (rx "*jupyter-pager*") t)

            ;; TODO: workaround
            (setq jupyter-use-zmq nil)))
#+end_src

#+begin_src emacs-lisp
(use-package ob-jupyter
  :ensure nil
  :init (progn
          (org-babel-jupyter-override-src-block "python")
          (setq org-babel-jupyter-resource-directory "/tmp/org-babel-jupyter-resource-directory/")))
#+end_src

#+begin_src emacs-lisp
(defun malb/previous-org-jupyter-kernel ()
  (save-excursion
    (if (re-search-backward " :kernel \\(\\w+\\)" nil t)
        (substring-no-properties (match-string 1))
      "sagemath")))
#+end_src

**** Toggle Shell for Jupyter Kernels

A generator for pop-up Jupyter repls.

#+begin_src emacs-lisp
(defun malb/make-jupyter-shell (shell-name kernel &optional post-exec per-project)
  `(lambda (&optional arg)
     (interactive "P")
     (let* ((name (if (and (not arg) ,per-project)
                      (format "%s,%s"
                              ,shell-name
                              (if (projectile-project-p)
                                  (projectile-project-name)
                                (car (last (split-string parent "/" t)))))
                    ,shell-name))
            (buffer-name (format "*jupyter-repl[%s]*" name))
            (window (get-buffer-window buffer-name)))
       (if (malb/window-has-popup-height-p window)
           (progn
             (select-window window)
             (delete-window))
         (progn
           (when (not (get-buffer buffer-name))
             (jupyter-run-repl ,kernel name)
             (with-current-buffer buffer-name
               (dolist (cmd ,post-exec)
                 (insert (concat cmd "\n")))))
           (pop-to-buffer buffer-name))))))
#+end_src

**** Tips

We can [[https://janakiev.com/blog/jupyter-virtual-envs/][add virtual environments as Jupyter kernels]] like this:

#+begin_example shell
(env) pip install ipykernel
(env) python -m ipykernel install --user --name=env
#+end_example

It also works over Tramp

Make Emacs aware by reloading kernels:

#+begin_src emacs-lisp :tangle no
(jupyter-available-kernelspecs t)
#+end_src

*** Tree Sitter

[[https://blog.markhepburn.com/posts/experimenting-with-the-built-in-treesitter-support-in-emacs/][Experimenting With the Built-in Tree-sitter Support in Emacs]]
[[https://archive.casouri.cc/note/2023/tree-sitter-in-emacs-29/index.html?utm_source=pocket_reader][Tree-sitter in Emacs 29 and Beyond]]

#+begin_src emacs-lisp
(use-package tree-sitter-langs)
#+end_src

*** Language Server Protocol (LSP)

#+begin_quote
The Language Server Protocol (LSP) defines the protocol used between an editor or IDE and a language server that provides language features like auto complete, go to definition, find all references etc. – https://microsoft.github.io/language-server-protocol/
#+end_quote

#+begin_src emacs-lisp
(use-package lsp-mode
  :after (projectile)
  :commands (lsp malb/lsp-enable-maybe)
  :custom ((lsp-eldoc-render-all nil)
           (lsp-prefer-flymake nil)
           (lsp-completion-provider :none "We enable it manually"))
  :bind (:map lsp-mode-map
              ("M-r" . lsp-find-references))
  :config (progn
            (defun malb/lsp-enable-maybe ()
              (condition-case nil
                  (if (buffer-file-name) (lsp-deferred))
                (user-error nil)))

            (setq read-process-output-max (* 1024 1024))
            (add-hook 'lsp-after-open-hook 'lsp-enable-imenu)))
#+end_src

#+begin_src emacs-lisp
(use-package lsp-ui
  :after (lsp-mode)
  :config (progn
            (setq lsp-ui-sideline-enable nil
                  lsp-ui-sideline-ignore-duplicate t
                  lsp-ui-peek-enable t
                  lsp-ui-imenu-enable t
                  lsp-ui-doc-enable t
                  lsp-ui-flycheck-enable t)))
#+end_src

#+begin_src emacs-lisp
;; https://github.com/emacs-lsp/helm-lsp/issues/19
(use-package helm-lsp
  :config (progn
            (define-key lsp-mode-map [remap xref-find-apropos] #'helm-lsp-workspace-symbol)
            (add-to-list 'helm-commands-using-frame #'helm-lsp-workspace-symbol)
            (add-to-list 'helm-commands-using-frame #'helm-lsp-global-workspace-symbol)))
#+end_src

** C/C++

#+begin_src emacs-lisp
(use-package c-ts-mode
  :bind (:map c-ts-base-mode-map
              ("M-<up>" . drag-stuff-up)
              ("M-<down>" . drag-stuff-down)
              ("<home>"  .  malb/beginning-of-line-dwim))
  :hook ((c-ts-base-mode . hs-minor-mode)
         (c-ts-base-mode . display-line-numbers-mode)
         (c-ts-base-mode . ws-butler-mode)
         (c-ts-base-mode . ggtags-mode)
         (c-ts-base-mode . helm-gtags-mode)
         (c-ts-base-mode . malb/lsp-enable-maybe)
         (c-ts-base-mode . clang-format+-mode))
  :init (progn
          (add-to-list 'major-mode-remap-alist '(c-mode . c-ts-mode))
          (add-to-list 'major-mode-remap-alist '(c++-mode . c++-ts-mode))
          (add-to-list 'auto-mode-alist '("\\.inl\\'" . c++-ts-mode)))
  :config  ;; register the defaults which will call out to ccls
  (smart-jump-register :modes '(c-mode c-ts-mode c++-modec c++-ts-mode)
                       :async 2000
                       :order 1))
#+end_src

Use [[http://clang.llvm.org/docs/ClangFormat.html][clang-format]] to … format code, [[https://github.com/SavchenkoValeriy/emacs-clang-format-plus][clang-format+]] automatically runs =clang-format= when a =.clang-format= is present.

#+begin_src emacs-lisp
(use-package clang-format
  :config (setq clang-format-executable "clang-format"))

(use-package clang-format+
  :commands clang-format+-mode)
#+end_src

*** COMMENT Valgrind

This code allows to run [[http://valgrind.org/][valgrind]] and step through warnings/errors. We set =--error-errorcode=1= because we bury compilation buffers that finish with exit code zero automatically. By default, valgrind returns the exit code of the program it runs. ([[https://github.com/codemac/config/blob/master/emacs.d/boot.org][source]])

#+begin_src emacs-lisp
(require 'compile "compile")

(defgroup valgrind nil
  "Run valgrind as inferior of Emacs, parse error messages."
  :group 'tools
  :group 'processes)


(defcustom valgrind-command "valgrind --error-exitcode=1 --leak-check=full"
  "*Last shell command used to run valgrind; default for next valgrind run.

Sometimes it is useful for files to supply local values for this variable.
You might also use mode hooks to specify it in certain modes, like this:

    (add-hook 'c-mode-hook
       (lambda ()
         (unless (or (file-exists-p \"makefile\")
                     (file-exists-p \"Makefile\"))
           (set (make-local-variable 'valgrind-command)
                (concat \"make -k \"
                        (file-name-sans-extension buffer-file-name))))))"
  :type 'string
  :group 'valgrind)

;; History of compile commands.
(defvar valgrind-history nil)

(defun valgrind (command)
  "Run valgrind.
Runs COMMAND, a shell command, in a separate process asynchronously
with output going to the buffer `*valgrind*'.

You can then use the command [next-error] to find the next error message
and move to the source code that caused it."
  (interactive
   (if (or compilation-read-command current-prefix-arg)
       (list (read-from-minibuffer "Valgrind command: "
                                   (eval valgrind-command) nil nil
                                   '(valgrind-history . 1)))
     (list (eval valgrind-command))))
  (unless (equal command (eval valgrind-command))
    (setq valgrind-command command))
  (compilation-start command t))
#+end_src

*** COMMENT Disassemble

#+begin_src emacs-lisp
(use-package disaster)
#+end_src

** Golang

#+begin_src emacs-lisp
(use-package go-ts-mode
  :mode "\\.go$"
  :ensure-system-package (gopls . gopls)
  :hook ((go-ts-mode . eldoc-mode)
         (go-ts-mode . malb/lsp-enable-maybe)
         (go-ts-mode . display-line-numbers-mode))
  :init (add-to-list 'major-mode-remap-alist '(go-mode . go-ts-mode))
  :config (when (boundp 'dtrt-indent-hook-mapping-list)
            (add-to-list 'dtrt-indent-hook-mapping-list
                         '(go-ts-mode c/c++/java go-ts-mode-indent-offset))))
#+end_src

** Rust

#+begin_src emacs-lisp
(use-package rust-ts-mode
  :ensure nil
  :mode "\\.rs$"
  :hook ((rust-ts-mode . eldoc-mode)
         (rust-ts-mode . malb/lsp-enable-maybe)
         (rust-ts-mode . display-line-numbers-mode))
  :init (add-to-list 'major-mode-remap-alist '(rust-mode . rust-ts-mode))
  :config (when (boundp 'dtrt-indent-hook-mapping-list)
            (add-to-list 'dtrt-indent-hook-mapping-list
                         '(rust-ts-mode c/c++/java rust-ts-mode-indent-offset))))
#+end_src

** Python

To avoid

#+begin_example
0.01s - Debugger warning: It seems that frozen modules are being used, which may
0.00s - make the debugger miss breakpoints. Please pass -Xfrozen_modules=off
0.00s - to python to disable frozen modules.
0.00s - Note: Debugging will proceed. Set PYDEVD_DISABLE_FILE_VALIDATION=1 to disable this validation.
#+end_example

we set

#+begin_src emacs-lisp
(setenv "PYDEVD_DISABLE_FILE_VALIDATION" "1")
#+end_src

We use the “onetwo” style to fill docstrings in Python, i.e.:

#+begin_src python :tangle no
"""Process foo, return bar."""

"""
Process foo, return bar.

If processing fails throw ProcessingError.

"""
#+end_src

I often restart Python processes (Cython development), so let’s bind a key for that.

#+begin_src emacs-lisp
(use-package python
  :ensure nil
  ;; otherwise I get: Cannot modify an area being edited in a dedicated buffer with ob-jupyter
  ;; :mode (("\\.py$" . python-mode))
  :bind (:map python-mode-map
              ("C-c C-c" . elpy-shell-send-region-or-buffer)
              ("C-c C-r" . pyvenv-restart-python)
              ("<home>"  . malb/beginning-of-line-dwim)
              ("C-<tab>" . bicycle-cycle)
              ("<backtab>" . bicycle-cycle-global)
              :map inferior-python-mode-map
              ("C-c C-r" . pyvenv-restart-python))
  :commands (malb/python-mode-hook malb/inferior-python-mode-hook)
  :init (add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode))
  :hook ((python-base-mode . outline-minor-mode)
         (python-base-mode . highlight-indentation-mode)
         (python-base-mode . malb/local-anaconda-mode)
         (python-base-mode . malb/local-anaconda-eldoc-mode)
         (python-base-mode . python-docstring-mode)
         (python-base-mode . sphinx-doc-mode)
         (python-base-mode . malb/python-mode-hook)
         (python-base-mode . ws-butler-mode)
         (python-base-mode . malb/elpy-sane-defaults)
         ;; (python-mode . importmagic-mode) ;; doesn't like python-ts-mode
         (inferior-python-mode . malb/inferior-python-mode-hook)
         )
  :config (progn
            (setq-default python-indent 4
                          python-fill-docstring-style 'django)

            (setq python-shell-interpreter "jupyter"
                  python-shell-interpreter-args "console --simple-prompt"
                  python-shell-prompt-detect-failure-warning nil)

            (defun malb/python-mode-hook ()
              (setq-local outline-blank-line t))

            (defun malb/inferior-python-mode-hook ()
              (setq-local company-backends '(company-files company-capf)))

            ;; http://emacs.stackexchange.com/a/21186/8930
            (add-to-list 'python-indent-trigger-commands 'malb/indent-fold-or-complete)
            (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")))
#+end_src

#+begin_src emacs-lisp
(use-package python-docstring
  :bind (:map python-docstring-mode-map
             ("M-q" . fill-paragraph)))
#+end_src

*** Highlight indentation

It makes sense to highlight indentation in Python.

#+begin_src emacs-lisp
(use-package highlight-indentation
  :blackout highlight-indentation-mode
  :commands highlight-indentation-mode)
#+end_src

*** Autocompletion

Use [[https://github.com/proofit404/anaconda-mode][anaconda-mode]] for auto-completion and stuff, it runs [[https://github.com/tkf/emacs-jedi][jedi]] for us. In particular it offers:

|-------+----------------------------------|
| ~M-.~ | =anaconda-mode-complete=         |
| ~M-=~ | =anaconda-mode-find-assignments= |
| ~M-r~ | =anaconda-mode-find-references=  |
| ~M-,~ | =xref-pop-marker-stack=          |
| ~M-?~ | =anaconda-mode-show-doc=         |
|-------+----------------------------------|

Fall back to dumb jump if anaconda fails.

#+begin_src emacs-lisp
(use-package anaconda-mode
  :after smart-jump
  :blackout anaconda-mode
  :commands (malb/local-anaconda-mode malb/local-anaconda-eldoc-mode)
  :config (progn

            (defun malb/local-anaconda-mode ()
              (when (and (buffer-file-name)
                         (not (file-remote-p (buffer-file-name))))
                (anaconda-mode)))

            (defun malb/local-anaconda-eldoc-mode ()
              (when (and (buffer-file-name)
                         (not (file-remote-p (buffer-file-name))))
                (anaconda-eldoc-mode)))

            (defun malb/vanilla-python-shell-interpreter (orig-fun &rest args)
              (let ((python-shell-interpreter "python")
                    (python-shell-interpreter-args "-i"))
                (apply orig-fun args)))

            (advice-add 'anaconda-mode-start :around #'malb/vanilla-python-shell-interpreter)))
#+end_src

*** Docstrings
**** [[https://github.com/glyph/python-docstring-mode][Python Docstring Mode]]

#+BEGIN_QUOTE
Python docstring mode provides syntax highlighting for docstrings in both ReStructuredText and Epydoc formats, as well as an override for the fill-paragraph function when editing such a docstring that will wrap things according to Python community convention.
#+END_QUOTE

Manually fixed bugs:

- [[https://github.com/glyph/python-docstring-mode/issues/9][Problems locating `docstring_wrap.py` #9]]

#+begin_src emacs-lisp
(use-package python-docstring
  :blackout python-docstring-mode
  :commands python-docstring-mode)
#+end_src

**** [[https://github.com/naiquevin/sphinx-doc.el][Sphinx Doc]]                                                                                               :patch:

An emacs minor mode for inserting docstring skeleton for Python functions and methods (=C-c M-d=). The structure of the docstring is as per the requirement of the Sphinx documentation generator.

#+begin_src emacs-lisp
(use-package sphinx-doc
  :blackout sphinx-doc-mode
  :commands sphinx-doc-mode)
#+end_src

Tweak sphinx-doc to fit my preferences

#+begin_src diff
(defun sphinx-doc-doc->str (ds)
  "Convert a doc object DS into string representation."
  (s-join
   "\n"
   (-filter
    (lambda (x) (not (equal x nil)))
+    ;; malb: put summary on first proper line
+    (list (s-format "\"\"\"\n$0\n" 'elt (list (sphinx-doc-doc-summary ds)))
-    (list (s-format "\"\"\"$0\n" 'elt (list (sphinx-doc-doc-summary ds)))
          (when (and (sphinx-doc-doc-before-fields ds)
                     (not (string= (sphinx-doc-doc-before-fields ds) "")))
            (concat (sphinx-doc-doc-before-fields ds) "\n"))
          (s-join "\n" (mapcar #'sphinx-doc-field->str
                               (sphinx-doc-doc-fields ds)))
          ""
          (when (and (sphinx-doc-doc-after-fields ds)
                     (not (string= (sphinx-doc-doc-after-fields ds) "")))
            (sphinx-doc-doc-after-fields ds))
          "\"\"\""))))

(defun sphinx-doc-parse (docstr indent)
  "Parse docstring DOCSTR into it's equivalent doc object.
INDENT is the current indentation level of the Python function."
  (let* ((lines (mapcar (lambda (line)
                          (s-chop-prefix (make-string indent 32) line))
                        (split-string docstr "\n")))
+         ;; malb: don't eat summary if on first proper line
+         (lines (if (string-equal (car lines) "") (cdr lines) lines))
         (paras (sphinx-doc-lines->paras lines))
         (field-para? #'(lambda (p) (s-starts-with? ":" (car p))))
         (comment? #'(lambda (p) (not (funcall field-para? p)))))
    (progn
      (make-sphinx-doc-doc
       :summary (caar paras)
       :before-fields (sphinx-doc-paras->str
                       (-take-while comment? (cdr paras)))
       :after-fields (sphinx-doc-paras->str
                      (cdr (-drop-while comment? (cdr paras))))
       :fields (sphinx-doc-parse-fields
                (car (-filter field-para? paras)))))))
#+end_src

*** Cython

#+begin_src emacs-lisp
(use-package cython-mode
  :mode (("\\.pyx$"  . cython-mode)
         ("\\.spyx$" . cython-mode)
         ("\\.pxd$"  . cython-mode)
         ("\\.pxi$"  . cython-mode)))
#+end_src

[[https://github.com/lbolla/emacs-flycheck-cython][Flycheck for Cython]]

#+begin_src emacs-lisp
(use-package flycheck-cython
  :after (cython-mode flycheck))
#+end_src

*** Black

Code formatting “do what they want”: [[https://github.com/psf/black][https://github.com/psf/black]]

#+begin_src emacs-lisp
(use-package blacken
  :config (setq blacken-line-length 'fill))
#+end_src

*** Managing Imports

[[https://github.com/anachronic/importmagic.el][importmagic]] tries to guess how to add missing imports. You need to install =importmagic= and =epc= for it work.

#+begin_src shell :tangle no
pip install importmagic epc
#+end_src

#+begin_src emacs-lisp
(use-package importmagic
  :blackout importmagic-mode
  :commands importmagic-mode
  :config (setq importmagic-python-interpreter "python"))
#+end_src

[[https://github.com/timothycrosley/isort][isort]] sorts Python imports. You need to install =isort= first.

#+begin_example shell :tangle no
pip install isort
#+end_example

#+begin_src emacs-lisp
(use-package py-isort
  :config (setq py-isort-options '("--lines=120")))
#+end_src

*** ElPy

#+BEGIN_QUOTE
[[https://github.com/jorgenschaefer/elpy][Elpy]] is an Emacs package to bring powerful Python editing to Emacs. It combines a number of other packages, both written in Emacs Lisp as well as Python.
#+END_QUOTE

Elpy is quite opinionated and we don’t necessarily share all those opinions. Hence, we only enable a small subset.

#+begin_src emacs-lisp
(defun malb/elpy-sane-defaults ()
  (elpy-module-sane-defaults 'buffer-init))

(use-package elpy
  :bind (:map python-mode-map
              ("C-c C-c" . elpy-shell-send-region-or-buffer))
  :commands (elpy-shell-send-region-or-buffer
             elpy-module-yasnippet
             elpy-module-sane-defaults)
  :config (progn (elpy-module-yasnippet 'global-init)))
#+end_src

*** Pip

#+begin_src emacs-lisp
(use-package pip-requirements)
#+end_src

*** Virtual Environments

#+begin_src emacs-lisp
(use-package conda
  :custom (conda-anaconda-home "/opt/conda/")
  :config (progn
            (conda-env-initialize-interactive-shells)
            (conda-env-initialize-eshell)
            (conda-env-autoactivate-mode t)

            (setq conda-env-home-directory (expand-file-name "~/.conda/")
                  conda-message-on-environment-switch nil)

            (malb/defadvice! malb/conda-no-more-nil (fn name)
              "Don't throw an error if there's no conda env"
              :around #'conda-env-name-to-dir
              (if name (apply fn (list name))))

            (malb/defadvice! malb/conda-shut-up (fn params)
              :around #'conda-env-activate-path
              (cl-letf (((symbol-function 'message) (lambda (msg &rest args)) nil))
                (apply fn (list params))))))
#+end_src

** Sage

Enable [[https://github.com/stakemori/sage-shell-mode][sage-shell-mode]] for running [[http://sagemath.org][Sage]] from within Emacs. It’s available on MELPA and hence easier to keep around when we switch Sage installs all the time. To edit a file in sage-shell-mode put ~# -*- mode: sage-shell:sage -*-~ on top.

#+begin_src emacs-lisp
(use-package sage-shell-mode
  :custom ((sage-shell:use-simple-prompt t)
           (sage-shell:use-prompt-toolkit nil)
           (sage-shell:set-ipython-version-on-startup nil)
           (sage-shell:check-ipython-version-on-startup nil))
  :hook ((sage-shell-mode . malb/sage-shell-company-completion)
         (sage-shell:sage-mode-hook . eldoc-mode)
         (sage-shell-mode-hook . eldoc-mode)
         (sage-shell-after-prompt . sage-shell-view-mode))
  :bind (:map sage-shell-mode-map
              ("C-<up>" . comint-previous-matching-input-from-input)
              ("C-<down>" . comint-next-matching-input-from-input)
              ("M-p" . comint-previous-matching-input-from-input)
              ("M-n" . comint-next-matching-input-from-input))
  :config (progn
            (defun malb/sage-shell-company-completion ()
              (setq-local company-backends
                          '((:separate company-files
                                       company-math-symbols-unicode
                                       company-yasnippet
                                       company-capf
                                       ))))


            (setq sage-shell-view-default-commands 'plots
                  sage-shell-view-scale 1.5
                  sage-shell-view-default-resolution 180)

            (setq sage-shell:input-history-cache-file (concat user-emacs-directory "sage_shell_input_history")
                  sage-shell:sage-executable malb/sage-executable
                  ac-sage-show-quick-help t)

            (fset 'malb/toggle-sage
                  (malb/make-toggle-shell "*Sage*"
                                          '(sage-shell:run-sage "sage --simple-prompt")
                                          nil
                                          nil))
            (malb/register-popup-window (rx "*Sage*") t)

            (advice-add 'sage-shell:send-eof :around  #'malb/kill-buffer)

            (malb/defadvice! malb/clean-sagemath (fn &rest args)
              "Run sage outside current conda env."
              :around #'sage-shell:run-sage
              (let ((prev-env-path conda-env-current-path))
                (conda-env-deactivate)
                (unwind-protect
                    (apply fn args)
                  (when prev-env-path
                    (conda-env-activate-path prev-env-path))))) ))
#+end_src

#+begin_src emacs-lisp
(fset 'malb/toggle-sage-jupyter
      (malb/make-jupyter-shell "*Sage*" "sagemath"
                               '(list
                                 "%load_ext autoreload"
                                 "%autoreload 2"
                                 (concat "%cd " default-directory))))
#+end_src

org babel for Sage can be quite handy for writing talks etc. ([[https://github.com/stakemori/ob-sagemath][source]])

#+begin_src emacs-lisp
(use-package ob-sagemath
  :config (progn
            (setq org-babel-default-header-args:sage '((:session . t)
                                                       (:results . "output replace")
                                                       (:exports . "both")
                                                       (:eval . "never-export")
                                                       (:cache .   "no")
                                                       (:noweb . "no")
                                                       (:hlines . "no")
                                                       (:tangle . "no")))))
#+end_src

([[https://emacs.stackexchange.com/questions/44202/open-a-file-in-read-only-preprocessed-mode][source]])

#+begin_src emacs-lisp
(define-derived-mode sobj-mode python-mode "sobj"
  "Major mode for viewing sobj files."
  (delete-region (point-min) (point-max))
  (call-process "python" nil t t "-c" (format (concat "# -*- coding: utf-8 -*-\n"
                                                      "import pickle\n"
                                                      "import pprint\n"
                                                      "pprint.PrettyPrinter(indent=4).pprint(pickle.load(open('%s', 'rb')))")
                                              (buffer-file-name)))
  (set-buffer-modified-p nil)
  (read-only-mode)
  (beginning-of-buffer))

(add-to-list 'auto-mode-alist '("\\.sobj\\'" . sobj-mode))
#+end_src

** Lisp

[[https://imgs.xkcd.com/comics/lisp_cycles.png]]

*** General

#+BEGIN_QUOTE
short and sweet LISP editing ([[https://github.com/abo-abo/lispy][source]])
#+END_QUOTE

Basic navigation by-list and by-region:

| binding | command                                      |
|---------+----------------------------------------------|
| ~h~     | moves left                                   |
| ~j~     | moves down                                   |
| ~k~     | moves up                                     |
| ~l~     | moves right                                  |
| ~f~     | steps inside the list                        |
| ~b~     | moves back in history for all above commands |
| ~d~     | moves to different side of sexp              |

Paredit transformations, callable by plain letters:

| binding | command    |
|---------+------------|
| ~>~     | slurps     |
| ~<~     | barfs      |
| ~r~     | raises     |
| ~C~     | convolutes |
| ~s~     | moves down |
| ~w~     | moves up   |

IDE-like features for Elisp, Clojure, Scheme, Common Lisp, Hy, Python and Julia:

| binding | command                                                          |
|---------+------------------------------------------------------------------|
| ~e~     | evals                                                            |
| ~E~     | evals and inserts                                                |
| ~g~     | jumps to any tag in the current directory with semantic          |
| ~G~     | jumps to any tag in the current file                             |
| ~M-.~   | jumps to symbol, ~M-~, jumps back                                |
| ~F~     | jumps to symbol, ~D~ jumps back                                  |
| ~C-1~   | shows documentation in an overlay                                |
| ~C-2~   | shows arguments in an overlay                                    |
| ~Z~     | breaks out of edebug, while storing current function's arguments |

Code manipulation:

| binding | command                                                                 |
|---------+-------------------------------------------------------------------------|
| ~i~     | prettifies code (remove extra space, hanging parens ...)                |
| ~xi~    | transforms cond expression to equivalent if expressions                 |
| ~xc~    | transforms if expressions to an equivalent cond expression              |
| ~xf~    | flattens function or macro call (extract body and substitute arguments) |
| ~xr~    | evals and replaces                                                      |
| ~xl~    | turns current defun into a lambda                                       |
| ~xd~    | turns current lambda into a defun                                       |
| ~O~     | formats the code into one line                                          |
| ~M~     | formats the code into multiple lines                                    |

#+begin_src emacs-lisp
(use-package lispy
   :hook (lisp-data-mode . lispy-mode))
#+end_src

[[https://raw.githubusercontent.com/cpitclaudel/easy-escape/master/img/easy-escape.png]]

#+begin_src emacs-lisp
(use-package easy-escape
  :hook ((emacs-lisp-mode lisp-mode) . easy-escape-minor-mode))
#+end_src

*** Emacs Lisp

([[https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L20-L94][source]])

#+begin_src emacs-lisp
(defun malb/lisp-indent-function (indent-point state)
  "This function is the normal value of the variable `lisp-indent-function'.
The function `calculate-lisp-indent' calls this to determine
if the arguments of a Lisp function call should be indented specially.

INDENT-POINT is the position at which the line being indented begins.
Point is located at the point to indent under (for default indentation);
STATE is the `parse-partial-sexp' state for that position.

If the current line is in a call to a Lisp function that has a non-nil
property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
it specifies how to indent.  The property value can be:

`defun', meaning indent `defun'-style
  (this is also the case if there is no property and the function
  has a name that begins with \"def\", and three or more arguments);

an integer N, meaning indent the first N arguments specially
  (like ordinary function arguments), and then indent any further
  arguments like a body;

  a function to call that returns the indentation (or nil).
  `lisp-indent-function' calls this function with the same two arguments
  that it itself received.

This function returns either the indentation to use, or nil if the
Lisp function does not specify a special indentation."
  (let ((normal-indent (current-column))
        (orig-point (point)))
    (goto-char (1+ (elt state 1)))
    (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
    (cond
     ;; car of form doesn't seem to be a symbol, or is a keyword
     ((and (elt state 2)
           (or (not (looking-at "\\sw\\|\\s_"))
               (looking-at ":")))
      (if (not (> (save-excursion (forward-line 1) (point))
                  calculate-lisp-indent-last-sexp))
          (progn (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point)
                                     calculate-lisp-indent-last-sexp 0 t)))
      ;; Indent under the list or under the first sexp on the same
      ;; line as calculate-lisp-indent-last-sexp.  Note that first
      ;; thing on that line has to be complete sexp since we are
      ;; inside the innermost containing sexp.
      (backward-prefix-chars)
      (current-column))
     ((and (save-excursion
             (goto-char indent-point)
             (skip-syntax-forward " ")
             (not (looking-at ":")))
           (save-excursion
             (goto-char orig-point)
             (looking-at ":")))
      (save-excursion
        (goto-char (+ 2 (elt state 1)))
        (current-column)))
     (t
      (let ((function (buffer-substring (point)
                                        (progn (forward-sexp 1) (point))))
            method)
        (setq method (or (function-get (intern-soft function)
                                       'lisp-indent-function)
                         (get (intern-soft function) 'lisp-indent-hook)))
        (cond ((or (eq method 'defun)
                   (and (null method)
                        (> (length function) 3)
                        (string-match "\\`def" function)))
               (lisp-indent-defform state indent-point))
              ((integerp method)
               (lisp-indent-specform method state
                                     indent-point normal-indent))
              (method
               (funcall method indent-point state))))))))
#+end_src

#+begin_src emacs-lisp
(use-package elisp-mode
  :ensure nil
  :bind (:map emacs-lisp-mode-map
         ("C-c C-z" . ielm)
         ("C-c C-c" . eval-defun)
         ("C-c C-b" . eval-buffer)
         ("M-<up>" .   (lambda () (interactive) (when (looking-at-p "(") (sp-forward-sexp)) (sp-transpose-sexp -1)))
         ("M-<down>" . (lambda () (interactive) (when (looking-at-p "(") (sp-forward-sexp)) (sp-transpose-sexp  1))))
  :hook ((emacs-lisp-mode . smartparens-strict-mode)
         (emacs-lisp-mode . eldoc-mode)
         (emacs-lisp-mode . lispy-mode)
         (emacs-lisp-mode . hs-minor-mode)
         (emacs-lisp-mode . malb/override-lisp-indent-function)
         (eval-expression-minibuffer-setup . eldoc-mode)
         (lisp-interaction-mode . smartparens-strict-mode)
         (lisp-interaction-mode . eldoc-mode)
         (lisp-interaction-mode . lispy-mode)
         (ielm-mode . smartparens-strict-mode)
         (ielm-mode . eldoc-mode))
  :config (progn
            (setq eldoc-idle-delay 0.3)
            (defun malb/override-lisp-indent-function ()
              (setq-local lisp-indent-function #'malb/lisp-indent-function))))
#+end_src

#+begin_src emacs-lisp
(use-package elisp-slime-nav
  :blackout elisp-slime-nav-mode
  :hook ((emacs-lisp-mode . elisp-slime-nav-mode)
         (lisp-interaction-mode . elisp-slime-nav-mode)
         (ielm-mode . elisp-slime-nav-mode))
  :bind (:map emacs-lisp-mode-map
              ("M-?" . elisp-slime-nav-describe-elisp-thing-at-point)))
#+end_src

[[https://github.com/Wilfred/suggest.el][suggest.el]] is an Emacs package for discovering elisp functions based on examples.

#+begin_src emacs-lisp
(use-package suggest)
#+end_src

** Web

[[http://web-mode.org/web-mode.png?v=5]]

#+begin_src emacs-lisp
(use-package web-mode
  :mode "\\.html?$"
  :after pandoc
  :config (progn
            (setq web-mode-enable-engine-detection t)
            (add-to-list 'pandoc-major-modes '(web-mode . "html"))))
#+end_src

#+begin_src emacs-lisp
(use-package typescript-ts-mode
  :ensure nil
  :mode "\\.js$"
  :hook ((typescript-ts-mode . malb/lsp-enable-maybe)))
#+end_src

* Prose
** General
*** Tab Completion

Use less tab completion in prose. ([[http://endlessparentheses.com/tab-completion-for-prose.html][souce]])

#+begin_src emacs-lisp
(defun malb/config-prose-completion ()
  "Make auto-complete less agressive in this buffer."
  (setq-local company-minimum-prefix-length 3)
  (setq-local company-idle-delay 0.5))

(add-hook 'text-mode-hook #'malb/config-prose-completion)
#+end_src

*** Line Wrapping

Put everything back on one line if =M-q= is pressed twice and use ~visual-line-mode~ to do the work of wrapping text for us. ([[http://endlessparentheses.com/fill-and-unfill-paragraphs-with-a-single-key.html?source=rss][source]])

#+begin_src emacs-lisp
(add-hook 'text-mode-hook #'turn-on-visual-line-mode)
(blackout 'visual-line-mode)

(defun malb/fill-or-unfill ()
  "Like `fill-paragraph', but unfill if used twice."
  (interactive)
  (let ((fill-column
         (if (eq last-command 'malb/fill-or-unfill)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (call-interactively #'fill-paragraph)))

(defun malb/org-fill-or-unfill ()
  "Like `org-fill-paragraph', but unfill if used twice."
  (interactive)
  (let ((fill-column
         (if (eq last-command 'malb/org-fill-or-unfill)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (call-interactively #'org-fill-paragraph)))

(bind-key [remap fill-paragraph] #'malb/fill-or-unfill)
(bind-key "M-q" #'malb/org-fill-or-unfill org-mode-map)
#+end_src

Indent correctly in ~visual-line-mode~ (~org-mode~ has its own thing).

#+begin_src emacs-lisp
(use-package adaptive-wrap
  :config (progn
            (add-hook 'markdown-mode-hook #'adaptive-wrap-prefix-mode)
            (add-hook 'LaTeX-mode-hook #'adaptive-wrap-prefix-mode)))
#+end_src

Allow for a bit more characters per line by default.

#+begin_src emacs-lisp
(setq-default fill-column 100)
#+end_src

For some modes we want resp. less wrapping width.

#+begin_src emacs-lisp
(defun malb/fill-column-32768 ()
  (set-fill-column 32768))
#+end_src

Indicate soft wrapped lines.

#+begin_src emacs-lisp
(setq visual-line-fringe-indicators '(nil right-curly-arrow))
#+end_src

*** Typography

[[https://github.com/jorgenschaefer/typoel][typo]] is a minor mode that will change a number of normal keys to make them insert typographically useful unicode characters. Some of those keys can be used repeatedly to cycle through variations. This includes in particular quotation marks and dashes.

#+begin_src emacs-lisp
(use-package typo
  :blackout typo-mode
  :config (progn
            (typo-global-mode)
            (setq-default typo-language "English")

            (defun malb/typo-in-src-block ()

              (or (org-in-block-p '("src" "example"))
                  (memq (face-at-point) '(markdown-code-face))))

            (add-to-list 'typo-disable-electricity-functions #'malb/typo-in-src-block)
            (add-to-list 'typo-disable-electricity-functions #'texmathp)

            (add-hook 'org-mode-hook #'typo-mode)))
#+end_src

*** Visual Fill Column Mode

[[https://github.com/joostkremers/visual-fill-column][soft wrap at fill-column]]

([[http://www.lunaryorn.com/posts/center-buffer-text-in-emacs.html][source]])

#+begin_src emacs-lisp
(use-package visual-fill-column
  :commands (visual-fill-column-mode turn-on-visual-fill-column-mode)
  :config (progn
            (setq-default visual-fill-column-center-text t
                          visual-fill-column-inhibit-sensible-window-split t
                          visual-fill-column-fringes-outside-margins nil)

            (dolist (fn '(text-scale-increase text-scale-decrease text-scale-adjust))
              (advice-add fn :after #'visual-fill-column-adjust))))
#+end_src

*** Sentences

#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
(bind-key "C-x C-t" #'transpose-sentences)
#+end_src

#+begin_src emacs-lisp
(advice-add 'kill-sentence :after #'fixup-whitespace)
#+end_src

*** Highlighting Sentences & Paragraphs

Also use [[https://github.com/larstvei/Focus][focus-mode]] occationally.

[[https://raw.githubusercontent.com/larstvei/Focus/master/demo-light.gif]] ([[https://github.com/larstvei/Focus][source]])


#+begin_src emacs-lisp
(use-package focus)
#+end_src

** Spell Checking

- Replace ~’~ with ~​'​~ before sending it to ispell ([[http://endlessparentheses.com/ispell-and-apostrophes.html][source]]) *Note:* Below, we adapt "en-default" (our default) instead of =nil= (the global default) because otherwise we [[http://endlessparentheses.com/ispell-and-apostrophes.html#comment-2258586606][can’t change dictionaries]].

- Enable/disable company completion from ispell dictionaries ([[https://github.com/redguardtoo/emacs.d/blob/master/lisp/init-company.el][source]])

#+begin_src emacs-lisp
(use-package ispell
  :hook ((message-mode) . malb/company-prose-setup)
  :config (progn
            (setq ispell-dictionary "en_GB"
                  ispell-silently-savep t)

            ;; Tell ispell.el that ’ can be part of a word. ;
            (setq ispell-local-dictionary-alist
                  '(("en_GB" "[[:alpha:]]" "[^[:alpha:]]"
                     "['\x2019]" nil ("-d" "en_GB") nil utf-8)))

            ;; Don't send ’ to the subprocess.
            (defun malb/replace-apostrophe (args)
              (cons (replace-regexp-in-string
                     "’" "'" (car args))
                    (cdr args)))

            (advice-add #'ispell-send-string :filter-args #'malb/replace-apostrophe)

            ;; Convert ' back to ’ from the subprocess.
            (defun malb/replace-quote (args)
              (if (not (or (derived-mode-p 'org-mode)
                           (derived-mode-p 'markdown-mode)
                           (derived-mode-p 'rst-mode)
                           (derived-mode-p 'message-mode)))
                  args
                (cons (replace-regexp-in-string
                       "'" "’" (car args))
                      (cdr args))))

            (defun malb/company-prose-setup ()
              (when (boundp 'company-backends)
                (setq-local company-backends
                            '((company-capf :with company-yasnippet)
                              (company-math-symbols-unicode :with company-yasnippet)
                              (company-files :with company-yasnippet)
                              company-ispell))
                ;; https://github.com/redguardtoo/emacs.d/issues/473
                (if (and (boundp 'ispell-alternate-dictionary)
                         ispell-alternate-dictionary)
                    (setq company-ispell-dictionary ispell-alternate-dictionary))))

            (advice-add #'ispell-parse-output :filter-args #'malb/replace-quote)))
#+end_src

Diminish ~flyspell-mode~ as we always use it.

#+begin_src emacs-lisp
(use-package flyspell
  :blackout
  :config (setq flyspell-issue-message-flag nil))
#+end_src

Use [[https://github.com/cute-jumper/ace-flyspell][ace-flyspell]] for fixing typos. I find myself pressing =C-.= in other programs these days just to be frustrated that it doesn’t just work™

#+begin_src emacs-lisp
(use-package ace-flyspell
  :bind (("C-." . ace-flyspell-correct-word)
         :map flyspell-mode-map
         ("C-." . malb/ace-flyspell-dwim))
  :after flyspell
  :config (progn
            (setq ace-flyspell-new-word-no-query t)

            (defun malb/ace-flyspell-dwim (arg)
              "Run `ace-flyspell-dim` unless prefix argument is given. In that case offer a word to insert."
              (interactive "P")
              (if arg
                  (progn
                    (ace-flyspell-jump-word)
                    (ace-flyspell--insert-word))
                (ace-flyspell-dwim)))

            (unbind-key "C-;" flyspell-mode-map)))
#+end_src

Automatically pick dictionary.

#+begin_src emacs-lisp
(use-package auto-dictionary
  :disabled
  :config (progn
            (setf (cdr (rassoc "en" adict-dictionary-list)) "en_GB")))
#+end_src

#+begin_src emacs-lisp
(use-package guess-language
  :commands (guess-language-buffer)
  :hook (message-mode . guess-language-mode)
  :config (setq guess-language-langcodes '((en . ("en_GB" "English"))
                                           (de . ("de_DE" "German")))
                guess-language-languages '(en de)))
#+end_src

** Dictionary

[[https://raw.githubusercontent.com/wiki/abo-abo/define-word/images/define-word.png]]

*[[https://github.com/tecosaur/lexic][Lexic]] for offline lookups.*

#+begin_src emacs-lisp
(use-package lexic
  :commands lexic-search lexic-list-dictionary malb/define-word-at-point-lexic
  :bind (("C-c w d" . malb/define-word-at-point-lexic))
  :config (progn
            (defun malb/define-word-at-point-lexic (identifier &optional arg)
              "Look up the definition of the word at point (or selection) using `lexic-search'."
              :override #'+lookup/dictionary-definition
              (interactive
               (list (or (thing-at-point 'word)
                         (read-string "Look up in dictionary: "))
                     current-prefix-arg))
              (cl-letf (((symbol-function 'visual-fill-column-mode)
                         (lambda (&optional arg)) nil))
                (lexic-search identifier nil nil t)))

            (malb/register-right-side-window (rx bos "*lexic*" eos))))
#+end_src

*[[http://oremacs.com/2015/05/22/define-word/][Define-word]] for online [[https://www.wordnik.com/][wordnik]] lookups.*

#+begin_src emacs-lisp
(use-package define-word
  :bind (("C-c w D" . define-word-at-point)))
#+end_src

** Synonyms

*[[Https://github.com/hpdeifel/synosaurus][Synosaurus]] for offline lookups.*

[[https://raw.githubusercontent.com/hpdeifel/synosaurus/master/screenshots/cnr.png]]

#+begin_src emacs-lisp
(use-package synosaurus
  :ensure-system-package ((wn . wordnet))
  :hook ((org-mode . synosaurus-mode)
         (LaTeX-mode . synosaurus-mode))
  :custom ((synosaurus-prefix (kbd "C-c w S"))
           (synosaurus-choose-method 'popup))
  :bind (("C-c w s" . synosaurus-choose-and-replace))
  :config (progn
            (malb/defadvice! malb/capitalise-wordnet (orig-function word)
              :around 'synosaurus-backend-wordnet
              (let* ((case-fold-search nil)
                     (is-capitalised (string-match-p (rx upper) word))
                     (words (apply orig-function (list word))))
                (message "%s %s" word is-capitalised)
                (if is-capitalised
                    (mapcar  (lambda (x) (list (capitalize (car x)) (cdr x))) words)
                  words)))))
#+end_src

*[[https://github.com/SavchenkoValeriy/emacs-powerthesaurus][PowerThesaurus]] for online lookups.*

[[https://raw.githubusercontent.com/SavchenkoValeriy/emacs-powerthesaurus/master/assets/demo.gif]]

#+begin_src emacs-lisp
(use-package powerthesaurus
  :bind ("C-c w p" . powerthesaurus-lookup-dwim)
  :config (malb/register-right-side-window (rx bos "*Powerthesaurus - " (0+ any) "*" eos) t))
#+end_src

** Grammar Checking

*[[https://github.com/emacs-languagetool/lsp-ltex][Langtool]] for offline grammar checking.*

#+begin_src emacs-lisp
(use-package lsp-ltex
  :init
  (setq lsp-ltex-version "16.0.0"
        lsp-ltex-language "en-GB"
        lsp-ltex-disabled-rules '(:en-GB ["OXFORD_SPELLING_Z_NOT_S"
                                          "MORFOLOGIK_RULE_EN_GB"]))
  (add-to-list 'lsp-disabled-clients 'ltex-ls))
#+end_src

*[[https://github.com/emacs-grammarly/lsp-grammarly][Grammarly]] for online grammar checking.*

#+begin_src emacs-lisp
(use-package lsp-grammarly
  :init (progn
          (setq lsp-grammarly-dialect "british")
          ;; never start grammarly-ls automatically, but only do it on a document-by-document basis
          (add-to-list 'lsp-disabled-clients 'grammarly-ls)))
#+end_src

** Translating

*[[https://www.reverso.net/][Reverso]] offers translation, grammar checks, synonyms and context.*

#+begin_src emacs-lisp
(use-package reverso
  :bind (("C-c w t r" . reverso))
  :hook ((reverso-result-mode . visual-line-mode))
  :config (progn
            (setq reverso-languages '(english german))
            (malb/register-right-side-window (rx (seq bos "*Reverso*" eos)))))
#+end_src

*[[Https://github.com/atykhonov/google-translate][Google-translate]] queries just that.*

#+begin_src emacs-lisp
(use-package google-translate
  :bind ("C-c w t g" . google-translate-smooth-translate)
  :init (progn
          (setq google-translate-translation-directions-alist
                '(("de" . "en") ("en" . "de")))
          (malb/register-right-side-window (rx (seq bos "*Google Translate*" eos)))))
#+end_src

*[[https://github.com/argosopentech/argos-translate][Argos-translate]] for offline translations.*

#+begin_src emacs-lisp
(use-package argos-translate
  :ensure nil
  :bind ("C-c w t t" . argos-translate-region)
  :config (progn
            (setq argos-translate-command
                  "conda run -n cuda --no-capture-output argos-translate -f ${from} -t ${to} ${text}")
            (malb/register-right-side-window (rx bos "*argos-translate*" eos))))
#+end_src

** Taking Notes (Deft)

Use [[http://jblevins.org/projects/deft/][deft]] for random notes and for a listing of blog entries.

[[http://jblevins.org/projects/deft/deft-v0.6.gif]] ([[http://jblevins.org/projects/deft/deft-v0.6.gif][source]])

#+begin_src emacs-lisp
(use-package deft
  :bind ("<f8>" . malb/deft)
  :bind ("S-<f8>" . malb/blog)
  :init (progn
          (setq deft-extensions '("org" "md")
                deft-default-extension "org"
                deft-directory malb/deft-directory
                deft-text-mode 'org-mode
                deft-use-filename-as-title nil
                deft-auto-save-interval 300.0
                deft-use-filter-string-for-filename t
                deft-current-sort-method 'mtime
                deft-file-naming-rules '((noslash . "-")
                                         (nospace . "-")
                                         (case-fn . downcase)))

          (defun malb/deft-fill-columns ()
            (setq-local fill-column 140)
            (visual-fill-column-mode))

          (add-hook 'deft-mode-hook #'malb/deft-fill-columns)

          (defun malb/deft-in-dir (dir)
            "Run deft in directory DIR"
            (setq deft-directory dir) ;; TODO: cannot let-bind
            (pop-to-buffer "*Deft*")
            (kill-this-buffer)
            (deft)
            (delete-other-windows))

          (defun malb/blog ()
            (interactive)
            (malb/with-tab "blog"
                           (malb/deft-in-dir (expand-file-name "web/blog" malb/projects-dir))))

          (defun malb/deft ()
            (interactive)
            (malb/with-tab "deft"
                           (malb/deft-in-dir malb/deft-directory)))

          ;; https://github.com/jrblevin/deft/issues/100
          (defun malb/deft-parse-summary (contents title)
            "Parse the file CONTENTS, given the TITLE, and extract a summary.
The summary is a string extracted from the contents following the
title."
            (let* ((summary (let ((case-fold-search nil))
                              (replace-regexp-in-string deft-strip-summary-regexp " " contents)))
                   (summary-processed (deft-chomp
                                       (if (and title
                                                (not deft-use-filename-as-title)
                                                (string-match (regexp-quote
                                                               (if deft-org-mode-title-prefix
                                                                   (concat "^#+TITLE: " title)
                                                                 title))
                                                              summary))
                                           (substring summary (match-end 0) nil)
                                         summary))))
              (substring summary-processed 0 (min 512 (string-width summary-processed)))))

          (advice-add #'deft-parse-summary :override #'malb/deft-parse-summary)

          (add-hook 'deft-mode-hook #'hl-line-mode)))
#+end_src

** Markdown

Standard setup and quick preview ([[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-markdown.el][source]])

#+begin_src emacs-lisp
(use-package markdown-mode
  :bind (:map markdown-mode-map
              ("M-<up>" . markdown-move-up)
              ("M-<down>" . markdown-move-down)
              ("C-<tab>" . outline-cycle)
              ("M-." .  markdown-do))
  :mode (("\\.md$" . markdown-mode)
         ("\\.markdown$" . markdown-mode)
         ("\\.text$" . markdown-mode)
         ("README\\.md$" . gfm-mode))
  :config (progn
            (defvar malb/markdown.css
              (expand-file-name "themes/foghorn.css" user-emacs-directory))

            (setq markdown-command (concat
                                    "pandoc --highlight-style pygments -f markdown+smart -t html -c"
                                    malb/markdown.css)
                  markdown-css-paths (list malb/markdown.css)
                  markdown-enable-math t
                  markdown-fontify-code-blocks-natively t)

            (add-hook 'markdown-mode-hook #'flyspell-mode)
            (add-hook 'markdown-mode-hook #'outline-minor-mode)
            (add-hook 'markdown-mode-hook #'turn-on-visual-fill-column-mode)

            ;; https://github.com/jrblevin/markdown-mode/issues/189
            (defun malb/markdown-footnote-find-all-marks ()
              "Collect all footnote mark."
              (save-excursion
                (goto-char (point-min))
                (cl-loop while (re-search-forward "\\[\\([^]]+\\)\\]\\(?:[^:]\\|\\'\\)" nil t)
                         collect (match-string-no-properties 1))))

            (defun malb/markdown-footnote-find-all-texts ()
              "Collect all footnote text."
              (save-excursion
                (goto-char (point-min))
                (cl-loop while (re-search-forward "^ \\{0,3\\}\\[\\([^]]+\\)\\]:" nil t)
                         collect
                         (let ((id (match-string-no-properties 1))
                               (line (line-number-at-pos))
                               (content (buffer-substring-no-properties
                                         (line-beginning-position) (line-end-position))))
                           (cons id (list :line line :content content))))))

            (defun malb/markdown-footnote-sort ()
              "Sort footnote text order by appearance."
              (interactive)
              (let* ((marks (malb/markdown-footnote-find-all-marks))
                     (texts (malb/markdown-footnote-find-all-texts))
                     (new-lines (sort (mapcar (lambda (e) (plist-get (cdr e) :line)) texts) #'<)))
                (save-excursion
                  (cl-loop for mark in marks
                           for new-line in new-lines
                           when (assoc-default mark texts)
                           do
                           (progn
                             (goto-char (point-min))
                             (forward-line (1- new-line))
                             (delete-region (line-beginning-position) (line-end-position))
                             (insert (plist-get it :content)))))))))
#+end_src

The [[https://github.com/Fanael/edit-indirect][edit-indirect]] package is used to edit code blocks in markdown-mode.

#+begin_src emacs-lisp
(use-package edit-indirect)
#+end_src

*** Pandoc

Use [[https://joostkremers.github.io/pandoc-mode/][pandoc-mode]] to call [[http://johnmacfarlane.net/pandoc/][pandoc]] for converting markdown to everything else.

#+begin_src emacs-lisp
(use-package pandoc-mode
  :config (progn
            (add-hook 'markdown-mode-hook #'conditionally-turn-on-pandoc)
            (add-hook 'org-mode-hook #'conditionally-turn-on-pandoc)
            (add-hook 'pandoc-mode-hook #'pandoc-load-default-settings)
            (add-to-list 'pandoc-major-modes '(LaTeX-mode . "latex"))
            (add-to-list 'pandoc-major-modes '(mu4e-view-mode . "markdown"))
            (add-to-list 'pandoc-major-modes '(mu4e-compose-mode . "markdown"))

            (defun malb/pandoc-convert (writer &optional buffer beginning end reader)
              (let* ((buffer (or buffer (current-buffer)))
                     (pandoc-buffer (get-buffer-create pandoc--output-buffer-name))
                     (begginning (or beginning (point-min)))
                     (end (or end (point-max)))
                     (reader (or reader (cdr (assq major-mode pandoc-major-modes)) "markdown"))
                     (text))
                (with-current-buffer pandoc-buffer
                  (erase-buffer))
                (with-current-buffer buffer
                  (call-process-region beginning end "pandoc" nil pandoc-buffer t
                                       "--read"
                                       reader
                                       "--write"
                                       writer
                                       "--quiet"
                                       "--wrap=none"))
                (with-current-buffer pandoc-buffer
                  (setq text (buffer-string)))
                text))

            (defun malb/-copy-as-from-org (backend)
              (let ((beg (if (org-region-active-p) (region-beginning) (point-min)))
                    (end (if (org-region-active-p) (region-end) (point-max))))
                (kill-new (org-export-string-as (buffer-substring beg end) backend t))
                (deactivate-mark)))

            (defun malb/-copy-as (what)
              (kill-new (malb/pandoc-convert what
                                             (current-buffer)
                                             (if (use-region-p) (region-beginning) (point-min))
                                             (if (use-region-p) (region-end) (point-max))))
              (deactivate-mark))


            (defun malb/copy-as (arg)
              (interactive "P")
              (cond (arg (malb/-copy-as (completing-read
                                         "Output format to use: "
                                         (mapcar 'car pandoc-output-format-extensions) nil t)))
                    ((derived-mode-p 'org-mode) (malb/-copy-as-from-org 'md))
                    (t (malb/-copy-as "org"))))

            (defun malb/copy-as-latex ()
              (interactive)
              (malb/-copy-as "latex"))

            (defun malb/copy-as-org ()
              (interactive)
              (malb/-copy-as "org"))

            (bind-key "M-W" #'malb/copy-as)))
#+end_src

** ReST

Python’s distutils [[http://bugs.python.org/issue11913][mandate]] =README.txt= or =README= in ReST. Hence, we add =README.txt= as the kind of file which wants ReST and use [[http://docutils.sourceforge.net/docs/user/emacs.html][rst-mode]] to edit it.

#+begin_src emacs-lisp
(use-package rst
  :bind (:map rst-mode-map
              ("M-<up>" . drag-stuff-up)
              ("M-<down>" . drag-stuff-down))
  :commands rst-mode-hook
  :hook (rst-mode . adaptive-wrap-prefix-mode)
  :mode "README\\.txt$")
#+end_src

** LaTeX (AucTeX)

| Command   | Explanation          |
|-----------+----------------------|
| ~C-c C-v~ | forward search       |
| ~C-c @~   | outline minor mode   |
| ~C-c ?~   | symbol documentation |

#+begin_src emacs-lisp
(use-package tex
  :ensure auctex
  :mode (("\\.tikz$" . LaTeX-mode))
  :bind (:map LaTeX-mode-map
              ("C-<tab>" . outline-cycle)
              ("M-." . malb/latex-jump)
              ("M-<right>" . sp-forward-sexp)
              ("M-<left>" . sp-backward-sexp)
              ("M-<up>" . outline-move-subtree-up)
              ("M-<down>" . outline-move-subtree-down)
              ("C-c h ." . TeX-doc))
  :hook ((LaTeX-mode . electric-indent-local-mode)
         (LaTeX-mode . turn-on-visual-line-mode)
         (LaTeX-mode . turn-on-flyspell)
         (LaTeX-mode . turn-on-reftex)
         (LaTeX-mode . turn-on-visual-fill-column-mode)
         (LaTeX-mode . outline-minor-mode)
         (LaTeX-mode . turn-on-cdlatex)
         (LaTeX-mode . prettify-symbols-mode)
         (LaTeX-mode . malb/latex-add-environments)
         (LaTeX-mode . malb/latex-add-font-lock)
         (LaTeX-mode . malb/enable-cleveref)
         (LaTeX-mode . malb/expand-region-setup)
         (LaTeX-mode . malb/lsp-enable-maybe)
         (LaTeX-mode . malb/company-latex-setup))
  :custom ((texmathp-tex-commands '(("\\sendmessageright*" arg-on)
                                    ("\\sendmessageleft*" arg-on)
                                    ("\\sendmessagerightleft*" arg-on))))
  :config (progn
            (require 'tex-mode)

            (setq TeX-auto-save t
                  TeX-parse-self t
                  reftex-plug-into-AUCTeX t
                  LaTeX-math-menu-unicode t
                  TeX-PDF-mode t
                  TeX-source-correlate-mode t
                  TeX-save-query nil
                  TeX-error-overview-open-after-TeX-run t
                  TeX-electric-sub-and-superscript t
                  TeX-quote-after-quote nil
                  reftex-toc-split-windows-fraction 0.15
                  reftex-toc-split-windows-horizontally t
                  font-latex-fontify-sectioning 1.0)
            (setq-default TeX-engine 'luatex)

            ;; TODO somehow auctex wants the former but we have the latter, this is for `prettify-symbols-mode'
            (fset 'TeX--prettify-symbols-compose-p #'tex--prettify-symbols-compose-p)

            ;; :- vs :=
            (setq tex--prettify-symbols-alist (remove '("\\coloneq" . ?≔) tex--prettify-symbols-alist))
            (push '("\\coloneqq" . ?≔) tex--prettify-symbols-alist)
            (push '("\\lvert" . ?|) tex--prettify-symbols-alist)
            (push '("\\rvert" . ?|) tex--prettify-symbols-alist)
            (push '("\\concat" . ?‖) tex--prettify-symbols-alist)
            (push '("\\mhyphen " . ?-) tex--prettify-symbols-alist)

            (setq TeX-view-program-list '(("Okular" "okular --unique %o#src:%n%b")
                                          ("Emacs" "emacsclient -n -e '(find-file-other-window \"%o\")'")))

            (setq TeX-view-program-selection '((output-pdf "PDF Tools")
                                               (output-html "xdg-open")))

            (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)

            (defun malb/latex-add-environments ()
              (LaTeX-add-environments
               '("lemma" LaTeX-env-label)
               '("theorem" LaTeX-env-label)
               '("algorithm" LaTeX-env-label)
               '("corollary" LaTeX-env-label)
               '("definition" LaTeX-env-label)
               '("example" LaTeX-env-label)
               '("proposition" LaTeX-env-label)
               '("pcvstack" LaTeX-env-label)
               '("pchstack" LaTeX-env-label)))

            (defun malb/latex-add-font-lock ()
              (font-latex-add-keywords '(("mat" "{")
                                         ("vec" "{"))
                                       'bold-command)
              (font-latex-add-keywords '(("malb" "*{[")
                                         ("todo" "*{[")
                                         ("cmnt" "*{{[")
                                         ("bug" "*{[")
                                         ("hltodo" "{")
                                         ("hlcmnt" "{")
                                         ("hlbug" "{")
                                         ("anonymous" "{{")
                                         ("fullversion" "{{")
                                         ("pgfkeysvalueof" "{"))
                                       'function))

            (defun malb/company-latex-setup ()
              (setq-local company-backends '(:separate
                                             (company-bibtex-completion
                                              company-reftex-labels
                                              company-capf
                                              company-math-symbols-latex
                                              company-auctex-environments
                                              company-auctex-macros
                                              company-files
                                              company-dabbrev
                                              :with company-yasnippet)
                                             )))

            (defun malb/enable-cleveref ()
              ;; TODO dunno why cleveref.el isn't loaded
              (font-latex-add-keywords '(("cref"          "*{")
                                         ("Cref"          "*{")
                                         ("crefrange"     "*{{")
                                         ("Crefrange"     "*{{")
                                         ("cpageref"      "{")
                                         ("Cpageref"      "{")
                                         ("cpagerefrange" "{{")
                                         ("Cpagerefrange" "{{")
                                         ("namecref"      "{")
                                         ("nameCref"      "{")
                                         ("lcnamecref"    "{")
                                         ("namecrefs"     "{")
                                         ("nameCrefs"     "{")
                                         ("lcnamecrefs"   "{")
                                         ("labelcref"     "{")
                                         ("labelcpageref" "{")
                                         ("label"         "[{")
                                         ("citet"         "*[{")
                                         ("citep"         "*[{"))
                                       'reference)

              (setq reftex-ref-style-default-list '("Default" "Cleveref")))

            (defun malb/latex-jump ()
              "If point is on a citation, jump to the bibtex file, otherwise open refex menu."
              (interactive)
              (xref-push-marker-stack)
              (let ((current (point)))
                (ignore-errors (org-ref-latex-jump-to-bibtex))
                (if (eq current (point))
                    (reftex-goto-label))))

            ;; http://endlessparentheses.com/improving-latex-equations-with-font-lock.html
            (defface malb/unimportant-latex-face
              '((t :height 1.0
                   :inherit font-lock-comment-face))
              "Face used on less relevant math commands.")

            (font-lock-add-keywords
             'LaTeX-mode
             `((,(rx "\\" (or (any ",.!;@")
                              (and (or "left" "right" "qquad" "quad" "big" "bigg" "Big" "Bigg" "t" "pcind")
                                   symbol-end)))
                0 'malb/unimportant-latex-face prepend))
             'end)

            (font-lock-add-keywords
             'LaTeX-mode
             `((,(rx "\\pc" (and (or "if" "then" "else" "elseif"
                                     "for" "do" "return"
                                     "const"
                                     "and" "or"
                                     "linecomment" "comment" "assert" "in")
                                 symbol-end))
                0 'font-latex-bold-face prepend))
             'end)

            (add-to-list 'display-buffer-alist
                         '("^\\*toc\\*$" display-buffer-in-side-window
                           (window-parameters
                            (no-other-window . t)
                            (no-delete-other-windows . t))
                           (side . left)
                           (window-width . 0.15)
                           (preserve-size t)
                           (dedicated . t)))

            (defun malb/reftex-toc-advice (old-function &rest arguments)
              (save-window-excursion
                (apply old-function arguments))
              (display-buffer "*toc*"))

            (advice-add #'reftex-toc :around #'malb/reftex-toc-advice)

            ;; https://stackoverflow.com/questions/19845598/emacs-regex-replacing-a-string-inside-a-latex-equation
            (defun malb/latex-replace-in-math ()
              "Call `query-replace-regexp' with `isearch-filter-predicate' to filter out outside math environments."
              (interactive)
              (let ((isearch-filter-predicate
                     (lambda (BEG END)
                       (save-excursion (save-match-data (goto-char BEG) (texmathp)))))
                    (case-fold-search nil))
                (call-interactively 'query-replace-regexp)))

            (setq-default TeX-master 'dwim
                          TeX-auto-local (expand-file-name "auctex-auto" user-emacs-directory))

            (add-to-list 'TeX-command-list
                         '("HTLaTeX"
                           "htlatex %s \"xhtml,html5,mathml,charset=utf-8\" \" -cunihtf -utf8\""
                           TeX-run-TeX nil
                           (LaTeX-mode docTeX-mode)
                           :help "Run HTLaTeX")
                         t)

            (defun malb/expand-region-setup ()
              "Setup LaTeX expansions."
              (set (make-local-variable 'er/try-expand-list)
                   '(er/mark-word
                     er/mark-symbol
                     er/mark-symbol-with-prefix
                     er/mark-next-accessor
                     er/mark-inside-quotes
                     er/mark-outside-quotes
                     er/mark-inside-pairs
                     er/mark-outside-pairs
                     er/mark-LaTeX-math
                     er/mark-text-sentence
                     er/mark-paragraph
                     er/mark-LaTeX-inside-environment
                     LaTeX-mark-environment
                     LaTeX-mark-section)))

            (add-to-list 'LaTeX-verbatim-environments "lstlisting")))
#+end_src

*** COMMENT Yanking

- https://abizjak.github.io/emacs/2016/03/05/latex-environment-yank.html
- https://abizjak.github.io/emacs/2016/03/05/latex-environment.html

#+begin_src emacs-lisp
(use-package latex-math-yank
  :ensure nil)
#+end_src


*** CDLaTeX

We do fast mathematics entry using a mix of [[https://github.com/cdominik/cdlatex][CDLaTeX]] and YaSnippet (for stuff like ~!=~).

#+begin_src emacs-lisp
(use-package cdlatex
  :custom ((cdlatex-takeover-parenthesis nil)
           (cdlatex-takeover-dollar nil)
           (cdlatex-simplify-sub-super-scripts nil))
  :config (progn
            (unbind-key "C-c ?" 'cdlatex-mode-map)
            (unbind-key "TAB" 'cdlatex-mode-map) ;; TeX-doc

            (defun malb/cdlatex-sub-superscript ()
              "Insert ^{} or _{} unless the number of backslashes before point is odd.
When not in LaTeX math environment, _{} and ^{} will have dollars.
When pressed twice, make the sub/superscript roman."
              (interactive)
              (if (and cdlatex-make-sub-superscript-roman-if-pressed-twice
                       (equal this-command last-command))
                  (insert "\\rm ")
                (if (or (cdlatex-number-of-backslashes-is-odd) ;; Quoted
                        (not (looking-at "[[:space:]\\\$]")))   ;; malb: added
                    (insert (event-basic-type last-command-event))
                  ;; Check if we are in math mode, if not switch to or only add _ or ^
                  (if (and (not (texmathp))
                           (not cdlatex-sub-super-scripts-outside-math-mode))
                      (insert (event-basic-type last-command-event))
                    (if (not (texmathp)) (cdlatex-ensure-math))
                    ;; Insert the normal template.
                    (insert (event-basic-type last-command-event))
                    (insert "{}")
                    (forward-char -1)))))

            (advice-add #'cdlatex-sub-superscript :override #'malb/cdlatex-sub-superscript)

            (setq cdlatex-math-modify-alist '((?a "\\alert" "\\alert" t nil nil)
                                              (?m "\\mat" nil t nil nil)
                                              (?o "\\operatorname" nil t nil nil)
                                              (?v "\\vec" nil t nil nil)
                                              (?F "\\mathfrak" nil t nil nil)
                                              (?B "\\mathbb" nil t nil nil))
                  cdlatex-command-alist
                  '(("ZZ"  	"\\ZZ" 		"\\ZZ?" 				cdlatex-position-cursor nil nil t)
                    ("QQ"  	"\\QQ" 		"\\QQ?" 				cdlatex-position-cursor nil nil t)
                    ("RR"  	"\\RR" 		"\\RR?" 				cdlatex-position-cursor nil nil t)
                    ("CC"  	"\\CC" 		"\\CC?" 				cdlatex-position-cursor nil nil t)
                    ("OO"  	"\\mathcal{O}()" "\\mathcal{O}\\left({?}\\right)" cdlatex-position-cursor nil nil t)
                    ("Rq"  	"\\ring_q" "\\ring_q?" 	  	cdlatex-position-cursor nil nil t)
                    ("nrm" 	"||x||" 	"\\|?\\|" 	cdlatex-position-cursor nil nil t)
                    ("abs" 	"|x|" 	"\\lvert ? \\rvert" 	cdlatex-position-cursor nil nil t))
                  cdlatex-math-symbol-alist '(( ?a  ("\\alpha" "\\alert{?}"))
                                              ( ?c  ("\\circ"  "" "\\cos"))
                                              ( ?R  ("\\ring" "\\ring_q"))
                                              ( ?=  ("\\equiv" "\\Leftrightarrow" "\\Longleftrightarrow"))))))
#+end_src

*** LaTeXMK

#+begin_src emacs-lisp
(use-package auctex-latexmk
  :ensure nil
  :after tex
  :config (progn
            (auctex-latexmk-setup)
            (setq LaTeX-clean-intermediate-suffixes
                  (append LaTeX-clean-intermediate-suffixes '("\\.fdb_latexmk" "\\.fls")))))
#+end_src

Run =latexmk -pvc= in async shell

#+begin_src emacs-lisp
(defun malb/toggle-latexmk ()
  "Run LaTeXMK in continuos mode."
  (interactive)
  (if (not (buffer-file-name))
      (error (format "Buffer %s is not visiting a file." (buffer-name))))
  (let*
      ((parent (if (buffer-file-name) (file-name-directory (buffer-file-name)) default-directory))
       (name (if (projectile-project-p) (projectile-project-name) (car (last (split-string parent "/" t)))))
       (main-file-name (if (boundp 'TeX-master)
                           (cond
                            ((stringp TeX-master) (expand-file-name TeX-master) )
                            ((booleanp TeX-master) (buffer-file-name))
                            (t (buffer-file-name)))
                         (progn
                           (buffer-file-name))))
       (buffer-name (concat "*" "LaTeXMK" "[" name "|" (file-name-nondirectory main-file-name) "]" "*"))
       (window (get-buffer-window buffer-name)))
    (if (malb/window-has-popup-height-p window)
        (progn
          (select-window window)
          (delete-window))
      (progn
        (when (not (get-buffer buffer-name))
          (let*
              ((default-directory (file-name-directory main-file-name))
               (process (start-process "latexmk"
                                       buffer-name
                                       "latexmk"
                                       "-pvc"
                                       "-pdflua"
                                       "-shell-escape"
                                       "-interaction=nonstopmode"
                                       "-halt-on-error"
                                       "-f-"
                                       (format "%s.tex"
                                               (file-name-sans-extension main-file-name)))))
            (set-process-query-on-exit-flag process nil)
            (with-current-buffer buffer-name
              (compilation-mode))))
        (display-buffer (get-buffer buffer-name))))))
#+end_src

*** Mathpix

[[https://mathpix.com/][https://mathpix.com/]]

#+begin_src emacs-lisp
(use-package mathpix
  :ensure nil
  :custom ((mathpix-app-id
            (plist-get
             (car
              (auth-source-search :host "mathpix" :max 1 :create nil :require '(:user)))
             :user))
           (mathpix-app-key
            (funcall
             (plist-get
              (car
               (auth-source-search :host "mathpix" :max 1 :create nil :require '(:secret)))
              :secret)))))
#+end_src

*** Pix2TeX

#+begin_src emacs-lisp
(use-package pix2tex
  :ensure nil
  :custom (pix2tex-command "conda run -n cuda pix2tex %s"))
#+end_src

*** Math Delimiters

#+begin_src emacs-lisp
(use-package math-delimiters
  :commands (math-delimiters-no-dollars math-delimiters-mode)
  :hook ((LaTeX-mode . math-delimiters-mode)
           (org-mode . math-delimiters-mode))
  :ensure nil
  :config (progn
            (setq math-delimiters-compressed-display-math nil)

            (malb/defadvice! malb/math-delimiters-no-dollars (old-function &rest args)
              :around 'math-delimiters-no-dollars
              (interactive)
              (save-restriction
                (when (region-active-p)
                  (narrow-to-region (caar (region-bounds)) (cdar (region-bounds))))
                (apply old-function args)))

            (define-minor-mode math-delimiters-mode
              "Math Delimeters"
              :init-value nil
              :lighter " MD"
              :keymap (let ((map (make-sparse-keymap)))
                        (define-key map (kbd "$")  #'math-delimiters-insert)
                        map))))
#+end_src

** Utility Functions

([[https://sriramkswamy.github.io/dotemacs/][source]])

#+begin_src emacs-lisp
(defun malb/align-& (start end)
  "Align columns by ampersand"
  (interactive "r")

  (when (not (use-region-p))
    (save-excursion
      (LaTeX-mark-environment)
      (setq start (region-beginning))
      (setq end (region-end))))

  (save-excursion
    (replace-regexp "\\s-*&\\s-*" " & " nil start end)
    (replace-regexp "^\\s-*" " " nil start end))
  (align-regexp start end "\\(\\s-*\\)&" 1 1 t))

(defun malb/align-whitespace (start end)
  "Align columns by whitespace"
  (interactive "r")
  (save-excursion
    (align-regexp start end
                  "\\(\\s-*\\)\\s-" 1 0 t)))

(defun malb/align-= (start end)
  "Align columns by equals sign"
  (interactive "r")
  (save-excursion
    (align-regexp start end
                  "\\(\\s-*\\)=" 1 0 t)))

(defun malb/align-: (start end)
  "Align columns by equals sign"
  (interactive "r")
  (save-excursion
    (align-regexp start end
                  "\\(\\s-*\\):" 1 0 t)))
#+end_src

** BibTeX

My standard BibTeX sources are

- =crypto_crossref.bib= and =abbrev3.bib= are from [[http://cryptobib.di.ens.fr/][crypto.bib]] which has most references relevant to crypto,
- =jacm.bib= is for the Journal of the ACM provided by the [[http://ftp.math.utah.edu/pub/tex/bib/jacm.bib][University of Utah]],
- =dcc.bib= is for Designs, Codes, and Cryptography provided by the [[http://ftp.math.utah.edu/pub/tex/bib/designscodescryptogr.bib][University of Utah]],
- =rfc.bib= is for RFCs and provided by [[http://tm.uka.de/~bless/bibrfcindex.html][Roland Bless]].

These are stored in some =common-latex= folder which has my [[https://bitbucket.org/malb/paper-template][paper-template]] as a subfolder.

#+begin_src emacs-lisp
(defvar malb/common-latex (concat (file-name-as-directory malb/projects-dir) "common-latex"))

(defvar malb/crypto-bib (concat (file-name-as-directory malb/common-latex) "cryptobib-crossref"))

(defvar malb/bibtex-files (list (expand-file-name "abbrev3.bib" malb/crypto-bib)
                                (expand-file-name "crypto_crossref.bib" malb/crypto-bib) ;; order matters
                                (expand-file-name "rfc.bib" malb/common-latex)
                                (expand-file-name "jacm.bib" malb/common-latex)
                                (expand-file-name "dcc.bib" malb/common-latex)
                                (expand-file-name "local.bib" malb/common-latex)
                                (expand-file-name "social-science.bib" malb/common-latex)
                                ))

(setq reftex-default-bibliography malb/bibtex-files)
#+end_src

We cite as “Alice15” or “AliBobCha15” or “ABCD15” ([[https://nickhigham.wordpress.com/2016/01/06/managing-bibtex-files-with-emacs/#comment-2977][source]]) and clean up BibTeX entries as we like them on =C-c C-c=.

#+begin_src emacs-lisp
(use-package bibtex
  :config (progn
            (setq bibtex-align-at-equal-sign t
                  bibtex-comma-after-last-field t
                  bibtex-entry-format '(opts-or-alts
                                        required-fields
                                        sort-fields
                                        page-dashes
                                        whitespace
                                        last-comma
                                        delimiters
                                        numerical-fields
                                        realign))

            ;; “no” wrap in BibTeX
            (add-hook 'bibtex-mode-hook #'malb/fill-column-32768)

            (defun bibtex-generate-autokey ()
              (let* ((bibtex-autokey-names nil)
                     (bibtex-autokey-year-length 2)
                     (bibtex-autokey-name-separator "\0")
                     (names (split-string (bibtex-autokey-get-names) "\0"))
                     (year (bibtex-autokey-get-year))
                     (name-char (cond ((= (length names) 1)
                                       (length (car names)))
                                      ((<= (length names) 3)
                                       3)
                                      (t 1)))
                     (existing-keys (bibtex-parse-keys))
                     key)
                (setq names (mapcar 'capitalize names))
                (setq names (mapconcat (lambda (x)
                                         (substring x 0 (min (length x) name-char)))
                                       names
                                       ""))
                (setq key (format "%s%s" names year))
                (let ((ret key))
                  (cl-loop for c from ?a to ?z
                        while (assoc ret existing-keys)
                        do (setq ret (format "%s%c" key c)))
                  ret)))))
#+end_src

Force parsing of the BibTeX bibliography ([[http://stackoverflow.com/questions/9682592/setting-up-reftex-tab-completion-in-emacs][source]])

#+begin_src emacs-lisp
(defun malb/get-bibtex-keys (file)
  (with-current-buffer (find-file-noselect file)
    (mapcar #'car (bibtex-parse-keys))))

(defun malb/latex-parse-bibtex ()
  (interactive)
  (mapc 'LaTeX-add-bibitems
        (apply 'append
               (mapcar #'malb/get-bibtex-keys (reftex-get-bibfile-list)))))
#+end_src

*** BibTeX Completion & Helm BibTeX                                                                            :patch:

[[https://github.com/tmalsburg/helm-bibtex/][Helm-bibtex]] is a nice interface for BibTeX.

[[https://github.com/tmalsburg/helm-bibtex/raw/master/screenshot.png]] ([[https://github.com/tmalsburg/helm-bibtex/][source]])

In [[./local/bibtex-completion-overrides.el][bibtex-completion-overrides]] we
- patch =bibtex-completion-find-pdf-in-library= to replace =:= with =_=, e.g. =EPRINT:FooBar21= to =EPRINT_FooBar=; [[https://cryptobib.di.ens.fr/][crypto.bib]] uses those keys.
- add another layer of caching to speed up loading.

We also patch bibtex-completion:

#+begin_src diff
diff --git a/bibtex-completion.el b/bibtex-completion.el
index f5e7009..3732c34 100644
--- a/bibtex-completion.el
+++ b/bibtex-completion.el
@@ -199,6 +199,11 @@ This should be a single character."
   :group 'bibtex-completion
   :type 'string)

+(defcustom bibtex-completion-replace-tex nil
+  "Make use of parsebib's ability to parse TeX and replace it by unicode characters."
+  :group 'bibtex-completion
+  :type 'boolean)
+
 (defcustom bibtex-completion-fallback-options
   '(("CrossRef                                  (biblio.el)"
      . (lambda (search-expression) (biblio-lookup #'biblio-crossref-backend search-expression)))
@@ -676,25 +681,28 @@ Also do some preprocessing of the entries.

 If HT-STRINGS is provided it is assumed to be a hash table."
   (goto-char (point-min))
-  (cl-loop
-   with fields = (append '("title" "crossref")
-                         (-map (lambda (it) (if (symbolp it) (symbol-name it) it))
-                               bibtex-completion-additional-search-fields))
-   for entry-type = (parsebib-find-next-item)
-   while entry-type
-   unless (member-ignore-case entry-type '("preamble" "string" "comment"))
-   collect (let* ((entry (parsebib-read-entry entry-type (point) ht-strings))
-                  (fields (append
-                           (list (if (assoc-string "author" entry 'case-fold)
-                                     "author"
-                                   "editor")
-                                 (if (assoc-string "date" entry 'case-fold)
-                                     "date"
-                                   "year"))
-                           fields)))
-             (-map (lambda (it)
-                     (cons (downcase (car it)) (cdr it)))
-                   (bibtex-completion-prepare-entry entry fields)))))
+  (cl-letf (((symbol-function 'parsebib--convert-tex-italics) (lambda (str) str))
+            ((symbol-function 'parsebib--convert-tex-bold) (lambda (str) str)))
+    (cl-loop
+     with fields = (append '("title" "crossref")
+                           (-map (lambda (it) (if (symbolp it) (symbol-name it) it))
+                                 bibtex-completion-additional-search-fields))
+     for entry-type = (parsebib-find-next-item)
+     while entry-type
+     unless (member-ignore-case entry-type '("preamble" "string" "comment"))
+     collect (let* ((entry (parsebib-read-entry entry-type (point) ht-strings nil
+                                                bibtex-completion-replace-tex))
+                    (fields (append
+                             (list (if (assoc-string "author" entry 'case-fold)
+                                       "author"
+                                     "editor")
+                                   (if (assoc-string "date" entry 'case-fold)
+                                       "date"
+                                     "year"))
+                             fields)))
+               (-map (lambda (it)
+                       (cons (downcase (car it)) (cdr it)))
+                     (bibtex-completion-prepare-entry entry fields))))))

 (defun bibtex-completion-get-entry (entry-key)
   "Given a BibTeX key this function scans all bibliographies listed in `bibtex-completion-bibliography' and returns an alist of the record with that key.
diff --git a/helm-bibtex.el b/helm-bibtex.el
index 10b1afb..0bcbbd5 100644
--- a/helm-bibtex.el
+++ b/helm-bibtex.el
@@ -174,12 +174,18 @@ comes out in the right buffer."

 ;; Helm sources:

+(defcustom helm-bibtex-ignore-diacritics nil
+  "Ignore diacritics when searching."
+  :group 'bibtex-completion
+  :type 'boolean)
+
 (defvar helm-source-bibtex
   (helm-build-sync-source "BibTeX entries"
     :header-name (lambda (name)
                    (format "%s%s: " name (if helm-bibtex-local-bib " (local)" "")))
     :candidates 'helm-bibtex-candidates
     :filtered-candidate-transformer 'helm-bibtex-candidates-formatter
+    :diacritics helm-bibtex-ignore-diacritics
     :action (helm-make-actions
              "Open PDF, URL or DOI"       'helm-bibtex-open-any
              "Open URL or DOI in browser" 'helm-bibtex-open-url-or-doi

#+end_src

#+begin_src emacs-lisp
(use-package bibtex-completion)

;; my tweaks
(use-package bibtex-completion-overrides
  :demand t
  :ensure nil
  :custom ((helm-bibtex-ignore-diacritics t "Fold e.g. é to e")
           (bibtex-completion-replace-tex t "Parse as unicode"))
  :after bibtex-completion
  :config (progn

            (setf (alist-get 'org-mode bibtex-completion-format-citation-functions)
                  #'bibtex-completion-format-citation-cite)

            (setq bibtex-completion-bibliography malb/bibtex-files
                  bibtex-completion-library-path malb/literature-dirs
                  bibtex-completion-notes-path malb/literature-notes-file
                  bibtex-completion-notes-template-one-file
                  (concat "** ${title} cite:${=key=}\n"
                          ":PROPERTIES:\n"
                          ":CUSTOM_ID: ${=key=}\n"
                          ":AUTHOR: ${author-or-editor}\n"
                          ":YEAR: ${year}\n"
                          ":DOI: ${doi}\n"
                          ":URL: ${url}\n"
                          ":END:\n"
                          "\n"
                          "fullcite:${=key=}\n"
                          "\n"))

            (require 'async)

            (defvar malb/bibtex-completion-get-value-replacements  `((,(rx (0+ any) "\\url{" (group (+? any)) "}") . "\\1")

                                                                     (,(rx (opt "{") "\\\"a" (opt "}")) . "ä")
                                                                     (,(rx (opt "{") "\\\"e" (opt "}")) . "ë")
                                                                     (,(rx (opt "{") "\\\"i" (opt "}")) . "ï")
                                                                     (,(rx (opt "{") "\\\"o" (opt "}")) . "ö")
                                                                     (,(rx (opt "{") "\\\"u" (opt "}")) . "ü")

                                                                     (,(rx (opt "{") "\\'a" (opt "}")) . "á")
                                                                     (,(rx (opt "{") "\\'e" (opt "}")) . "é")
                                                                     (,(rx (opt "{") "\\'i" (opt "}")) . "í")
                                                                     (,(rx (opt "{") "\\'o" (opt "}")) . "ó")
                                                                     (,(rx (opt "{") "\\'u" (opt "}")) . "ú")

                                                                     (,(rx (opt "{") "\\`a" (opt "}")) . "à")
                                                                     (,(rx (opt "{") "\\`e" (opt "}")) . "è")
                                                                     (,(rx (opt "{") "\\`i" (opt "}")) . "ì")
                                                                     (,(rx (opt "{") "\\`o" (opt "}")) . "ò")
                                                                     (,(rx (opt "{") "\\`u" (opt "}")) . "ù")

                                                                     ("\\\\&" . "&")
                                                                     ("~" . " ")))



            (malb/defadvice! malb/bibtex-completion-get-value (old-function &rest args)
              :around 'bibtex-completion-get-value
              (let ((st (apply old-function args)))
                (when st
                  (dolist (rep malb/bibtex-completion-get-value-replacements)
                    (setq st (replace-regexp-in-string (car rep) (cdr rep) st))))
                st))

            (malb/defadvice! malb/bibtex-completion-apa-format-reference (old-function key)
              :around 'bibtex-completion-apa-format-reference
              (let ((entry (bibtex-completion-get-entry key)))
                (cond ((s-equals-p (downcase (bibtex-completion-get-value "=type=" entry)) "misc")
                       (replace-regexp-in-string
                        "\\([.?!]\\)\\." "\\1"
                        (s-format
                         "${author} (${year}). ${title}. ${howpublished}. ${note}"
                         'bibtex-completion-apa-get-value entry)))
                      (t
                       (apply old-function (list key))))))

            (if (and (not malb/startup-quick)
                     (daemonp))
                (let ((async-prompt-for-password nil))
                  (async-start `(lambda ()
                                  (add-to-list 'load-path (expand-file-name "local/" user-emacs-directory))
                                  (setq load-prefer-newer t)
                                  (package-initialize)
                                  (require 'bibtex-completion-overrides)
                                  ,(async-inject-variables "\\`\\(bibtex-completion\\)")

                                  (bibtex-completion-candidates)

                                  (list bibtex-completion-cache
                                        bibtex-completion-string-cache
                                        bibtex-completion-string-hash-table))

                               (lambda (result)
                                 (setq bibtex-completion-cache (nth 0 result)
                                       bibtex-completion-string-cache (nth 1 result)
                                       bibtex-completion-string-hash-table (nth 2 result))
                                 (message "Finished scanning BibTeX file.")))))))
#+end_src

We add an option to search for the paper’s title online.

#+begin_src emacs-lisp
(use-package helm-bibtex
  :commands (helm-bibtex helm-bibtex-with-local-bibliography)
  :config (progn
            (setq helm-bibtex-full-frame t)
            (add-to-list 'helm-commands-using-frame 'helm-bibtex)

            (defun malb/bibtex-completion-google-this (keys-or-entries)
              (dolist (key-or-entry keys-or-entries)
                (let* ((key (if (stringp key-or-entry)
                                key-or-entry
                              (bibtex-completion-get-value "=key=" key-or-entry))))
                  (helm-ddgr (replace-regexp-in-string
                                 "{\\|}" ""
                                 (bibtex-completion-get-value
                                  "title"
                                  (bibtex-completion-get-entry key)))))))

            (helm-bibtex-helmify-action malb/bibtex-completion-google-this
                                        helm-malb/bibtex-completion-google-this)

            (eval-after-load "org-ref"
              '(progn (helm-delete-action-from-source "Insert BibTeX key"
                                                      helm-source-bibtex)
                      (helm-add-action-to-source "Insert BibTeX key" 'helm-bibtex-insert-key
                                                 helm-source-bibtex 0)
                      (helm-add-action-to-source "Find online" 'helm-malb/bibtex-completion-google-this
                                                 helm-source-bibtex)))

            (malb/defadvice! malb/helm-case-fold-search (fn &optional args)
              "Ignore case when searching BibTeX."
              :around 'helm-bibtex-with-local-bibliography
              (let ((helm-case-fold-search t))
                (apply fn args)))))
#+end_src

A [[https://company-mode.github.io/][company]] interface to bibtex-completion.

#+begin_src emacs-lisp
(defun company-bibtex-completion-candidates ()
  (let ((bibtex-completion-bibliography
         (or (bibtex-completion-find-local-bibliography)
             bibtex-completion-bibliography)))
    (mapcar (lambda (x) (propertize (cdr (assoc "=key=" (cdr x)))
                                    'bibtex-completion-annotation
                                    (cdr (assoc "title" (cdr x)))))
            (bibtex-completion-candidates))))

(defun company-bibtex-completion (command &optional arg &rest ignored)
  "bibtex-completion backend"
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'company-bibtex-completion))
    (prefix (let ((prefixes
                   (cond ((derived-mode-p 'LaTeX-mode)
                          (company-auctex-prefix "\\\\cite[^[{]*\\(?:\\[[^]]*\\]\\)?{\\([^}]*\\)\\="))
                         ((and (derived-mode-p 'org-mode)
                               (not (org-in-src-block-p))
                               (looking-back "cite:\\([^}]*\\)"))
                          (match-string-no-properties 1))
                         (t nil))))
              (if prefixes
                  (last (split-string prefixes "," t))
                nil)))
    (candidates (all-completions arg (company-bibtex-completion-candidates)))
    (annotation (get-text-property 0 'bibtex-completion-annotation arg))))

(add-to-list 'company-backends '(company-bibtex-completion company-math-symbols-unicode company-capf)) ;;
#+end_src

****** TODO turn company-bibtex-completion into library so it can be lazy loaded

*** Adding References

I like the interface of [[https://github.com/cpitclaudel/biblio.el][biblio]] better, [[https://github.com/cute-jumper/gscholar-bibtex][gscholar-bibtex]] covers more bases.

- [[https://github.com/cpitclaudel/biblio.el][biblio]] browses and gathers bibliographic references and publications from various sources, by keywords or by DOI.

  #+begin_src emacs-lisp
(use-package biblio
  :config (setq biblio-bibtex-use-autokey t))
  #+end_src

- [[https://github.com/cute-jumper/gscholar-bibtex][gscholar-bibtex]] grabs BibTeX entries from from Google Scholar, ACM Digital Library, IEEE Xplore and DBLP.

  #+begin_src emacs-lisp
(use-package gscholar-bibtex
  :init (progn
            (setq gscholar-bibtex-database-file (expand-file-name "common-latex/local.bib" malb/projects-dir))))
  #+end_src

*** Org Cite

#+begin_src emacs-lisp
(use-package oc
  :ensure nil
  :after org)

(use-package oc-biblatex
  :ensure nil
  :config
  (setq org-cite-biblatex-options "backend=bibtex")
  (add-to-list 'org-cite-biblatex-styles '("full" nil "fullcite" nil nil))
  (add-to-list 'org-cite-biblatex-styles '("footfull" nil "footfullcite" nil nil))
  :after oc)
#+end_src

*** Org Ref

#+BEGIN_QUOTE
[[https://github.com/jkitchin/org-ref][Org-ref]] is a library for org-mode that provides rich support for citations, labels and cross-references in org-mode. org-ref is especially suitable for org-mode documents destined for LaTeX export and scientific publication. org-ref is also extremely useful for research documents and notes. org-ref bundles several other libraries that provide functions to create and modify bibtex entries from a variety of sources, but most notably from a DOI.
#+END_QUOTE

#+begin_src emacs-lisp
(use-package org-ref
  :after org
  :defer 2
  :bind (:map bibtex-mode-map
              ("<f2> ;" . org-ref-bibtex-hydra/body))
  :config (setq org-ref-default-ref-type "cref"))
#+end_src

#+begin_src emacs-lisp
(use-package org-ref-latex
  :ensure nil
  :commands org-ref-latex-jump-to-bibtex)
#+end_src

** Speed Reading

Spray is a speed reading mode.

[[https://gitlab.com/iankelling/spray/raw/master/screencast.gif]]

([[https://gitlab.com/iankelling/spray][source]])

#+begin_src emacs-lisp
(use-package spray
  :config (progn
            (setq spray-wpm 400
                  spray-margin-left 4
                  spray-margin-top 12)
            (bind-key "+" 'spray-faster spray-mode-map)
            (bind-key "-" 'spray-slower spray-mode-map)
            (add-to-list 'spray-unsupported-minor-modes 'beacon-mode)))
#+end_src

** Piper

[[https://github.com/rhasspy/piper][Text to speech]]

#+begin_src emacs-lisp
(use-package piper
  :after emms
  :commands piper-region
  :ensure-system-package piper
  :ensure nil)
#+end_src

** Tesseract

[[https://github.com/tesseract-ocr/tesseract][OCR screenshots]]

#+begin_src emacs-lisp
(use-package tesseract
  :ensure nil)
#+end_src

* E-Mail (Mu4e)

We use Mu4e:

#+begin_src emacs-lisp
(setq mail-user-agent 'mu4e-user-agent)
#+end_src

We can then use the following =emacsmail= script as =mailto= handler

#+begin_src sh :tangle no
#!/bin/bash
emacsclient -c --eval "(browse-url-mail \"$@\")"
#+end_src

E-mail is fetched by [[http://isync.sourceforge.net/mbsync.html][mbsync]] and parsed by [[http://www.djcbsoftware.nl/code/mu/][mu]]. Then, we use [[http://www.djcbsoftware.nl/code/mu/mu4e.html][mu4e]]. See this [[https://martinralbrecht.wordpress.com/2016/05/30/handling-email-with-emacs/#more-1336][blog post]] for details.

#+begin_src emacs-lisp
(use-package mu4e
  :ensure nil
  :ensure-system-package mu
  :commands (mu4e mu4e-update-index)
  :bind (:map mu4e-main-mode-map ("u" . mu4e-update-index))
  :config  (setq mu4e-headers-skip-duplicates t
                 mu4e-view-show-images t
                 message-kill-buffer-on-exit t
                 mu4e-hide-index-messages t
                 mu4e-auto-retrieve-keys t
                 message-dont-reply-to-names #'mu4e-personal-or-alternative-address-p
                 mu4e-completing-read-function 'completing-read
                 mu4e-compose-switch 'display-buffer
                 mu4e-split-view 'vertical
                 mu4e-headers-visible-columns 134
                 mu4e-headers-visible-lines 16
                 mu4e-context-policy 'pick-first
                 mu4e-compose-context-policy 'ask
                 mu4e-change-filenames-when-moving t
                 mu4e-confirm-quit nil
                 mu4e-index-cleanup t
                 mu4e-view-show-addresses t
                 mu4e-headers-precise-alignment t
                 mu4e-compose-complete-only-after nil
                 mu4e-index-lazy-check nil
                 mu4e-headers-auto-update nil
                 mu4e-org-link-query-in-headers-mode t
                 mu4e-eldoc-support t
                 mu4e-modeline-support nil))
#+end_src

** Folders

#+begin_src emacs-lisp
(setq mu4e-drafts-folder "/gmail/[Google Mail]/Drafts"
      mu4e-sent-folder   "/gmail/[Google Mail]/Sent Mail"
      mu4e-trash-folder  "/gmail/[Google Mail]/Bin")

(setq mu4e-maildir-shortcuts
      '((:maildir "/gmail/Inbox"      :key ?G)
        (:maildir "/sandbox/Inbox"    :key ?S)
        (:maildir "/kcl/INBOX"        :key ?K)
        (:maildir "/gmail/research/ec24artifacts" :key ?a)))
#+end_src

** Retrieving

#+begin_src emacs-lisp
(setq mu4e-get-mail-command "timelimit -t 180 -T 180 mbsync all"
      mu4e-update-interval nil)
#+end_src

** Prettier ([[https://github.com/Bronsa/.emacs.d/blob/master/config/mu4e.el][source]])

#+begin_src emacs-lisp
(use-package mu4e-headers
  :ensure nil
  :after all-the-icons
  :config (setq mu4e-use-fancy-chars t
                mu4e-headers-draft-mark     '("D" . "✎ ") ; draft
                mu4e-headers-new-mark       '("N" . "")
                mu4e-headers-seen-mark      '("S" . "")    ; seen
                mu4e-headers-unread-mark    '("u" . "")    ; unseen
                mu4e-headers-flagged-mark   '("F" . "★ ")  ; flagged
                mu4e-headers-new-mark       '("N" . "✉ ")  ; new
                mu4e-headers-replied-mark   '("R" . "⮐ ")  ; replied
                mu4e-headers-passed-mark    '("P" . "⇉ ")  ; passed
                mu4e-headers-encrypted-mark '("x" . "🔒 ") ; encrypted
                mu4e-headers-signed-mark    '("s" . "✍ ")  ; signed
                mu4e-headers-attach-mark    '("a" . "🗎")   ; attachments
                mu4e-headers-empty-parent-prefix '("-" . "○")
                mu4e-headers-first-child-prefix '("\\" . "▸")
                mu4e-headers-has-child-prefix '("+" . "●")
                mu4e-headers-threaded-label (cons
                                             "T"
                                             (all-the-icons-faicon "tree" :face 'all-the-icons :v-adjust 0.01))
                mu4e-headers-related-label (cons
                                            "R"
                                            (all-the-icons-faicon "circle-o-notch" :face 'all-the-icons :v-adjust 0.01))
                mu4e-headers-eldoc-format (concat
                                           (all-the-icons-faicon "tag" :face 'all-the-icons :v-adjust 0.01)
                                           ": %m, "
                                           (all-the-icons-faicon "envelope" :face 'all-the-icons :v-adjust 0.01)
                                           ": %M")))
#+end_src

#+begin_src emacs-lisp
(add-to-list 'mu4e-headers-mode-hook #'stripe-buffer-mode)
#+end_src

** Search

([[https://melpa.org/#/mu4e-query-fragments][source]])

#+begin_src emacs-lisp
(use-package mu4e-query-fragments
  :config (setq mu4e-query-fragments-list
                `(("%trash" . ,(s-join " OR "
                                       '("flag:trashed"
                                         "maildir:\"/gmail/[Google Mail]/Bin\""
                                         "maildir:\"/sandbox/[Gmail]/Trash\""
                                         "maildir:\"/kcl/Deleted Items\"")))
                  ("%junk" . ,(s-join " OR "
                                      '("maildir:\"/gmail/[Google Mail]/Spam\""
                                        "maildir:\"/sandbox/[Gmail]/Spam\""
                                        "maildir:\"/kcl/Junk Email\"")))
                  ("%drafts" . ,(s-join " OR "
                                        '("maildir:\"/gmail/[Google Mail]/Drafts\""
                                          "maildir:\"/sandbox/[Gmail]/Drafts\""
                                          "maildir:\"/kcl/Drafts\"")))
                  ("%hidden" . "%trash OR %junk")
                  ("%unread" . "flag:unread AND NOT %hidden  ")
                  ("%today"  . "date:today..now AND NOT %hidden")
                  ("%week"   . "date:7d..now AND NOT %hidden")
                  ("%month"  . "date:31d..now AND NOT %hidden")
                  ("%inbox"  . ,(concat "(" (s-join " OR "
                                                    '("maildir:/gmail/Inbox"
                                                      "maildir:/sandbox/Inbox"
                                                      "maildir:/kcl/INBOX")
                                                    )
                                        ")"
                                        " AND NOT %hidden"))
                  ("%sent"   . ,(concat "(" (s-join " OR "
                                                    '("maildir:\"/gmail/[Google Mail]/Sent Mail\""
                                                      "maildir:\"/sendmail/[Gmail]/Sent Mail\""
                                                      "maildir:\"/gmail/royal holloway/sent\""
                                                      "maildir:\"/kcl/Sent Items\""))
                                        ")"))
                  ("%direct" . "%inbox AND NOT flag:list  AND (to:martinralbrecht@* OR to:martin.albrecht@*)")
                  ("%doc"    . ,(concat "mime:application/* "
                                        "AND NOT (mime:application/pgp* or mime:application/ics) "
                                        "AND size:5k.. "
                                        "AND NOT %hidden"))
                  ("%bulk"   . ,(concat "(" "flag:list "
                                        "OR from:trac@sagemath.org "
                                        "OR maildir:/bulk "
                                        "OR maildir:/research/.lists) "
                                        "AND NOT %hidden"
                                        ")"))
                  ("%fromme"  . ,(concat "("
                                         (s-join " OR " (mapcar (lambda (arg)
                                                                  (format "from:%s" arg))
                                                                malb/user-mail-addresses))
                                         ")")))))
#+end_src

#+begin_quote
Just press ~l~ in the headers view and any mailing list you've subscribed to will be automatically discovered and presented in recency order. No setup or refiling necessary.
#+end_quote

#+begin_src emacs-lisp
(use-package mu4e-jump-to-list
  :config (progn
            (unbind-key "l" mu4e-main-mode-map)
            (unbind-key "l" mu4e-headers-mode-map)))
#+end_src

Canned queries.

#+begin_src emacs-lisp
(setq mu4e-bookmarks nil)               ; clear out

(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%inbox") :name "Inbox" :key ?i) t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%unread") :name "Unread messages" :key ?u) t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%unread AND %bulk") :name "Unread (bulk)" :key ?l) t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%direct") :name "Direct" :key ?d) t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "flag:flagged AND NOT %hidden") :name "Flagged" :key ?f) t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%today") :name "Today's" :key ?t) t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%direct AND %today") :name "Today's (direct)" :key ?T) t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%week")  :name "Last 7 days" :key ?w) t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%direct AND %week") :name "Last 7 days (direct)" :key ?W) t)
(add-to-list 'mu4e-bookmarks
             `(:query ,(mu4e-query-fragments-expand
                        "%direct AND %week AND NOT (flag:replied OR flag:passed OR flag:list) AND NOT %hidden")
                      :name "Last 7 days (direct, unanswered)"
                      :key ?R)
             t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%sent AND %week") :name "Last 7 days (sent)" :key ?s) t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%drafts") :name "Drafts" :key ?!) t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%trash") :name "Bin" :key ?b) t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%junk") :name "Junk" :key ?j) t)
(add-to-list 'mu4e-bookmarks `(:query ,(mu4e-query-fragments-expand "%doc AND %inbox AND %month") :name "Documents (31 days)" :key ?D) t)
#+end_src

** Key Bindings

#+begin_src emacs-lisp
(bind-key "D" #'mu4e-headers-mark-for-trash mu4e-headers-mode-map)
(bind-key "d" #'mu4e-headers-mark-for-delete mu4e-headers-mode-map)
#+end_src

** Contacts

Handling contacts semi-automagically is one of mu4e’s big selling points to me. The functions below make it more automagic.

My shitty regexp for detecting e-mail addresses

#+begin_src emacs-lisp
(defconst malb/email-regexp "<?\\([^ ]+@[^ ]+\.[^ >]+\\)>?")
#+end_src

#+begin_src emacs-lisp
(defun malb/extract-email (str)
  ;; return last sub-string looking like an email address
  (let ((tokens (reverse (split-string-and-unquote str)))
        (match))
    (dolist (token tokens)
      (string-match malb/email-regexp token)
      (setq match (or match (match-string 1 token))))
    match))
#+end_src

*** Canonicalisation

A table of canonical names for people who cannot seem to fix their headers …

#+begin_src emacs-lisp
(defcustom malb/mu4e-name-replacements nil
  "replacement names from e-mail addresses"
  :type '(list :type string)
  :group 'malb)
#+end_src

- My uni likes “Lastname, Firstname (Year)” which is weird, so we fix it.
- Some people like to YELL their LASTNAME and then write the first name, we also canonicalise that
- Some people like to send incomplete data, so we maintain a local replacement list

#+begin_src emacs-lisp
(defun malb/canonicalise-contact-name (email  &optional name nick)
  "Try to extract a firstname lastname pair from whatever is written in an email"
  (let* ((name (or name ""))
         (case-fold-search nil)
         ;; look up email address and use entry if found
         (candidate-in-db (if nick (caddr (assoc (downcase email) malb/mu4e-name-replacements))
                            (cadr (assoc (downcase email) malb/mu4e-name-replacements)))))
    (cond (candidate-in-db candidate-in-db) ;; we found something
          ((s-ends-with-p "ethz.ch" email)  ;; ETH Zurich  like to do "Lastname Firstname"
           (replace-regexp-in-string "^\\(.*\\) \\(.*\\)" "\\2 \\1" name))
          ((and (s-blank-p name) (string-match-p "^\\(.*\\)\\.\\(.*\\)@.*" email)) ;; firstname.lanstname@corp.com
           (upcase-initials (replace-regexp-in-string "^\\(.*\\)\\.\\(.*\\)@.*" "\\1 \\2" email)))
          (t ;; if all else fails let's use some heuristics
           (progn
             ;; deal with "'Foo Bar'"
             (setq name (replace-regexp-in-string "'\\(.*?\\)'" "\\1" name))
             ;; deal with YELL’d last names
             (setq name (replace-regexp-in-string "^\\(\\<[[:upper:]]+\\>\\) \\(.*\\)" "\\2 \\1" name))
             ;; Foo, Bar becomes Bar Foo
             (setq name (replace-regexp-in-string "^\\(.*\\), \\([^ ]+\\).*" "\\2 \\1" name))
             ;; foo bar becomes Foo Bar
             (setq name (capitalize name)))))))
#+end_src

A function to add new replacements.

#+begin_src emacs-lisp
(defun malb/add-mu4e-name-replacement ()
  (interactive)
  (let* ((email (helm-read-string "E-mail: " (replace-regexp-in-string
                                              ".*<\\(.*\\)>.*" "\\1"
                                              (downcase (get-text-property (point) 'gnus-data)))))
         (name  (helm-read-string "Name: "
                                  (malb/canonicalise-contact-name
                                   email
                                   (replace-regexp-in-string "\\(.*\\) <.*>.*" "\\1"
                                                             (get-text-property (point) 'gnus-data)))))
         (nick  (helm-read-string "Nick: " (replace-regexp-in-string "\\([^ ]?\\) .*" "\\1" name))))
    (add-to-list 'malb/mu4e-name-replacements (list email name nick) t)
    (customize-save-variable 'malb/mu4e-name-replacements malb/mu4e-name-replacements)))
#+end_src

#+begin_src emacs-lisp
(bind-key "N" #'malb/add-mu4e-name-replacement mu4e-view-mode-map)
#+end_src

Canonicalise contacts as they appear from mu4e.

#+begin_src emacs-lisp
(defun malb/mu4e-contact-rewrite-function (contact)
  (let ((heuristic-email-regex "\\([^ \\.]*+\\)\\.\\([^ \\.]*+\\)@\\(.*?\\)")
        (full-email-regex "\"?\\(.*?\\)\"? <\\(.*?\\)>"))
    (cond
     ;; ignore a bunch
     ((string-match-p (rx  (or (seq "no" (zero-or-one "-") "reply")
                               (seq "replyto-" (one-or-more anychar) "@plus.google.com")
                               (seq "@" (one-or-more anychar) ".twitter.com")
                               (seq "do-not-reply" (zero-or-more anychar) "@")
                               (seq "bounce-" (one-or-more anychar) "@")
                               "@reply.github.com"))
                      contact)
      nil)
     ;; ignore a bunch of invalid addresses
     ((seq-some (lambda (invalid-address)
                  (or (s-contains-p (s-concat "<" invalid-address ">") contact t)
                      (s-equals-p invalid-address (downcase contact))))
                malb/invalid-email-addresses)
      nil)
     ;; full "Name <e-mail>"
     ((string-match-p full-email-regex contact)
      (let* ((email (downcase (replace-regexp-in-string full-email-regex "\\2" contact)))
             (name  (replace-regexp-in-string full-email-regex "\\1" contact))
             (case-fold-search t))
        (format "%s <%s>"
                (malb/canonicalise-contact-name email
                                                (if (equal (downcase name) email)
                                                    "" name))
                email)))
     ;; just "e@mail" (could potentially be removed since `malb/canonicalise-contact-name' handles it?
     ((string-match heuristic-email-regex contact)
      (progn
        (let* ((email (downcase contact))
               (firstname (upcase-initials (match-string 1 contact)))
               (lastname (upcase-initials (match-string 2 contact))))
          (if (> (length firstname) 1)
              (format "%s %s <%s>" firstname lastname email)
            contact))))
     (t contact))))

(setq mu4e-contact-process-function #'malb/mu4e-contact-rewrite-function)
#+end_src

Some tests, these should all return the same value.

#+begin_src emacs-lisp :tangle no :results drawer
(list
 (malb/mu4e-contact-rewrite-function "Alice Smith <alice.smith@corp.com>")
 (malb/mu4e-contact-rewrite-function "Smith, Alice <alice.smith@corp.com>")
 (malb/mu4e-contact-rewrite-function "'Alice smith' <alice.smith@corp.com>")
 (malb/mu4e-contact-rewrite-function "Alice SMITH <alice.smith@corp.com>")
 (malb/mu4e-contact-rewrite-function "alice.smith@corp.com"))
#+end_src

#+RESULTS:
:results:
(Alice Smith <alice.smith@corp.com> Alice Smith <alice.smith@corp.com> Alice Smith <alice.smith@corp.com> Alice Smith <alice.smith@corp.com> Alice Smith <alice.smith@corp.com>)
:end:

Extract a pretty-ish list of contacts from an e-mail.

#+begin_src emacs-lisp
(defun malb/mu4e-end-of-my-message ()
  (save-excursion
    (or (search-forward
         "-------------------- Start of forwarded message --------------------"
         nil t)
        (progn (message-goto-signature)
               (point)))))
#+end_src

#+begin_src emacs-lisp
(defun malb/extract-contacts (fields)
  "Return a list of 'name <email>' entries."
  (let (contacts
        point-end-of-line
        (case-fold-search t)
        (search-regexp (mapconcat (lambda (arg) (concat "^" arg ": *"))
                                  fields "\\|"))
        (end (malb/mu4e-end-of-my-message)))

    ;; extract contacts
    (save-excursion
      (save-restriction
        (goto-char (point-min))
        (narrow-to-region (point-min) end)
        (while (re-search-forward search-regexp nil t)
          (save-excursion
            (setq point-end-of-line (re-search-forward "$")))
          (add-to-list 'contacts
                       (mail-header-parse-addresses
                        (buffer-substring-no-properties (point)
                                                        point-end-of-line))
                       t))))
    (apply #'append contacts)))
#+end_src

The following is useful in e-mail templates

#+begin_src emacs-lisp
(defun malb/get-names-from-fields (fields)
  (let ((contacts (malb/extract-contacts fields))
        ret
        (case-fold-search t))
    (dolist (contact contacts)
      (let ((name (malb/canonicalise-contact-name (car contact) (cdr contact) t)))
        ;; extract first name
        (when (string-match "\\([^ ,]+\\)" name)
          (push (match-string 1 name) ret))))
    (if ret (string-join (nreverse ret) ", ") ret "there")))
#+end_src

A shortcut:

#+begin_src emacs-lisp
(defun malb/get-names-from-to-field ()
  (interactive)
  (malb/get-names-from-fields '("To")))
#+end_src

*** Rearrange To and CC

Use Helm to re-arrange recipients of an e-mail. I often get e-mail from Bob with Charley in CC which prompts me to send an e-mail to Charley with Bob in CC.

#+begin_src emacs-lisp
(defun malb/helm-reorder-recipients ()
  "Re-distribute addresses to To: and CC: fields."
  (interactive)
  (let* ((search-regexp "^to: *\\|^cc: *")
         (addresses (mapcar (lambda (address)
                              (format "\"%s\" <%s>"
                                      (malb/canonicalise-contact-name (car address) (cdr address))
                                      (car address)))
                            (malb/extract-contacts '("to" "cc"))))
         (case-fold-search t)
         to cc)

    ;; ask user to split into To and CC
    (setq to (helm :sources (helm-build-sync-source "To:"
                              :candidates addresses
                              :action  '(("Select" . (lambda (x) (helm-marked-candidates)))
                                         ("Ignore" . (lambda (x)))))))

    (dolist (address to)
      (setq addresses (delete address addresses)))

    (if addresses
        (setq cc (helm :sources (helm-build-sync-source "CC:"
                                  :candidates addresses
                                  :action  '(("Select" . (lambda (x) (helm-marked-candidates)))
                                             ("Ignore" . (lambda (x))))))))

    ;; Replace To: and CC: fields
    (save-excursion
      (goto-char (point-min))

      (while (re-search-forward search-regexp nil t)
        (kill-whole-line))

      (message-goto-from)

      (progn (newline)
             (insert "To: ")
             (insert (mapconcat #'identity to ", ")))
      (if cc (progn (newline)
                    (insert "Cc: ")
                    (insert (mapconcat #'identity cc ", ")))))))
#+end_src

#+begin_src emacs-lisp
(bind-key "C-c ]" #'malb/helm-reorder-recipients mu4e-compose-mode-map)
#+end_src

*** Contact look up

#+begin_src emacs-lisp
(defun malb/fullcontact ()
  (interactive)
  (let* ((email (replace-regexp-in-string "<?\\(.*?\\)>?" "\\1" (thing-at-point 'email)))
         (path (expand-file-name "fullcontact.py" user-emacs-directory)))
    (if email
        (let ((msg (shell-command-to-string (format "PYTHONIOENCODING=utf8 python3 %s -e %s" path email))))
          (message "%s" msg)))))

(bind-key "@" #'malb/fullcontact mu4e-view-mode-map)
#+end_src

*** Add MailRC entry

Query the user for an alias and add an entry to =~/.mailrc=.

#+begin_src emacs-lisp
(defun malb/add-to-mailrc (alias &optional arg)
  (interactive
   (list (read-string "alias: ")
         current-prefix-arg))
  (let ((addresses))
    (if (equal major-mode 'mu4e-view-mode)
        (setq addresses (mapcar
                         (lambda (a)
                           (if (car a)
                               (format "%s <%s>" (car a) (cdr a))
                             (format "%s" (cdr a))))
                         (mu4e-message-field (mu4e-message-at-point) :to)))
      (setq addresses (or
                       (mail-header-parse-addresses (message-fetch-field "Bcc") t)
                       (mail-header-parse-addresses (message-fetch-field "To") t))))
    (write-region
     (format "alias %s %s\n" alias
             (mapconcat (lambda (s)
                          (if (string-match-p "<" s)
                              (format "\"%s\"" (replace-regexp-in-string "\"" ""
                                                                         (string-trim s)))
                            s))
                        addresses " "))
     nil
     (expand-file-name ".mailrc" "~")
     'append)))
#+end_src

*** Searching

#+begin_src emacs-lisp
(unbind-key "s" mu4e-main-mode-map)
#+end_src

A helm menu for contacts, based on ([[http://kitchingroup.cheme.cmu.edu/blog/2015/03/14/A-helm-mu4e-contact-selector/][source]])

#+begin_src emacs-lisp
(defun malb/helm-mu-contacts (arg)
  "Helm interface to e-mail addresses.

When ARG equals then the persistent action is search, otherwise
it is to insert the contact.
"
  (interactive "p")

  (if (not mu4e--contacts-set)
      (progn
        ;; request contacts
        (mu4e--request-contacts-maybe)
        (let ((i 0))
          ;; sleep for at most 2 seconds to wait for contacts to be filed
          (while (and (not mu4e--contacts-set) (> 2 i))
            (sleep-for 1)
            (+ i 1)))))

  (let ((helm-case-fold-search t)
        (malb/helm-mu-actions
         '(("Insert" . (lambda (x)
                         (insert (mapconcat 'identity
                                            (helm-marked-candidates) ","))))
           ("Find messages (simple)" .
            (lambda (x)
              (let ((combiner "OR")
                    (from-to-contact "contact:"))
                (mu4e-headers-search
                 (mapconcat (lambda (x) (format (concat from-to-contact "%s")
                                                (malb/extract-email x)))
                            (helm-marked-candidates)
                            (format " %s " combiner))))))
           ("Find messages" .
            (lambda (x)
              (let* ((candidates (helm-marked-candidates))
                     (combiner  (if (> (length candidates ) 1)
                                    (completing-read "Combine multiple with:" '("OR" "AND"))
                                  ""))
                     (from-to-contact (completing-read "Restrict to:" '("from:" "to:" "contact:"))))
                (mu4e-headers-search
                 (mapconcat (lambda (x) (format (concat from-to-contact "%s")
                                                (malb/extract-email x)))
                            candidates
                            (format " %s " combiner))))))
           ;; ("Copy to clipboard" . (lambda (x)
           ;;                          (kill-new (mapconcat 'identity
           ;;                                               (helm-marked-candidates) ","))))
           ("Google search" . (lambda (x) (helm-googler (replace-regexp-in-string
                                                         (format "^\\(.*\\) %s" malb/email-regexp) "\\1" x))))
           )))

    (helm :sources (helm-build-sync-source "E-mail address candidates"
                     :candidates  (append
                                   ;; aliases
                                   (cl-loop for alias across mail-abbrevs
                                            if (symbol-value
                                                (intern-soft (format "%s" alias) mail-abbrevs))
                                            collect  (cons (format "%s" alias)
                                                           (symbol-value
                                                            (intern-soft (format "%s" alias) mail-abbrevs))))
                                   ;; mu contacts
                                   (cl-loop for contact being the hash-key of mu4e--contacts-set
                                            collect (cons contact contact)))
                     :action  (cond ((equal arg 4) (cons (cadr malb/helm-mu-actions)
                                                         (cons (car malb/helm-mu-actions)
                                                               (cddr  malb/helm-mu-actions))))
                                    (t malb/helm-mu-actions))))))
#+end_src

#+begin_src emacs-lisp
(bind-key "C-c [" #'malb/helm-mu-contacts mu4e-compose-mode-map)
#+end_src

Search mu with [[https://github.com/emacs-helm/helm-mu][helm-mu]].

#+begin_src emacs-lisp
(use-package helm-mu
  :config (progn

            (defun malb/helm-mu (arg)
              (interactive "p")
              (let ((current-prefix-arg nil))
                (cond
                 ((equal arg 4) (malb/helm-mu-contacts 4))
                 (t (helm-mu)))))

            (add-to-list 'helm-commands-using-frame 'helm-mu)
            (add-to-list 'helm-commands-using-frame 'malb/helm-mu-contacts)

            (fset 'mu4e-main-mode-map mu4e-main-mode-map) ;; this seems to have been forgotten in mu4e

            (dolist (mode-map '(mu4e-main-mode-map mu4e-headers-mode-map mu4e-view-mode-map mu4e-search-minor-mode-map))
              (unbind-key "s" mode-map)
              (bind-key "ss" #'mu4e-query-fragments-search mode-map)
              (bind-key "sm" #'mu4e-query-fragments-search mode-map)
              (bind-key "sl" #'mu4e-jump-to-list mode-map)
              (bind-key "sh" #'malb/helm-mu mode-map)
              (bind-key "sc" (defun malb/helm-mu-contacts-messages ()
                               (interactive)
                               (malb/helm-mu-contacts 4))
                        mode-map))))
#+end_src

[[http://puntoblogspot.blogspot.de/2016/02/with-this-little-trick-helm-dash-gets.html][Tip:]] =C-c C-f= aka =helm-follow-mode= is your friend.

** Viewing

Visual-line mode all the way.

#+begin_src emacs-lisp
(bind-key "<home>" #'beginning-of-visual-line mu4e-view-mode-map)
(bind-key "<end>" #'end-of-visual-line mu4e-view-mode-map)
#+end_src

Use ace-link for links as it is compatible with gnus.

#+begin_src emacs-lisp
(bind-key "g" #'ace-link mu4e-view-mode-map)
#+end_src

Dropping =[mouse-1]= otherwise I end up with links being clicked twice.

#+begin_src emacs-lisp
(setq mu4e-view-active-urls-keymap
      (let ((map (make-sparse-keymap)))
        (define-key map [down-mouse-1] 'mu4e--view-browse-url-from-binding)
        (define-key map (kbd "M-<return>") 'mu4e--view-browse-url-from-binding)
        map))
#+end_src

Headers to show in header view.

#+begin_src emacs-lisp
(add-to-list 'mu4e-header-info-custom
             '(:empty . (:name "Empty"
                               :shortname ""
                               :function (lambda (msg) "  "))))

(setq mu4e-headers-fields '((:empty . 2)
                            (:human-date . 12)
                            (:flags . 6)
                            (:mailing-list . 16)
                            (:from-or-to . 32)
                            (:subject . nil)))
#+end_src

#+begin_src emacs-lisp
(defun malb/mu4e-view-mode-hook ()
  "View e-mails with width restriction, but wider for HTML."
  (set-fill-column 80)
  (visual-line-mode 1))

(add-hook 'gnus-article-mode-hook #'malb/mu4e-view-mode-hook)
#+end_src

Discourage HTML rendering in GNUS:

#+begin_src emacs-lisp
(with-eval-after-load "mm-decode"
  (add-to-list 'mm-discouraged-alternatives "text/html")
  (add-to-list 'mm-discouraged-alternatives "text/richtext"))
#+end_src

Gnus formatting

#+begin_src emacs-lisp
(setq gnus-article-date-headers '(original))
#+end_src

** Attachments

#+begin_src emacs-lisp
(setq mu4e-attachment-dir (expand-file-name "incoming" malb/sync-dir))
(setq-default mu4e-save-multiple-attachments-without-asking t)
#+end_src

Put attachments at end of my writing ([[http://mbork.pl/2015-11-28_Fixing_mml-attach-file_using_advice][source]])

#+begin_src emacs-lisp
(defun malb/mml-attach-file--go-to-eob (orig-fun &rest args)
  "Go to the end of my message before attaching files."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-min))
      (let ((point (re-search-forward "^.*wrote:$" nil t)))
        (if point
            (progn
              (goto-char point)
              (previous-line))
          (goto-char (point-max))))
      (newline)
      (apply orig-fun args))))

(advice-add 'mml-attach-file :around #'malb/mml-attach-file--go-to-eob)
#+end_src

*** Attach from Dired buffers and of the current buffer

Attachments are mostly handled using the helm baloo interface, but sometimes we want to send files from a directory: =C-c C-m C-a= ([[https://writequit.org/eos/eos-mail.html][source]])

#+begin_src emacs-lisp
(add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)

(use-package gnus-dired
  :ensure nil
  :after mu4e
  :config
  (progn
    (malb/defadvice! malb/gnus-dired-mail-buffers ()
      "Return a list of active message buffers."
      :override #'gnus-dired-mail-buffers

      ;; make the `gnus-dired-mail-buffers' function also work on
      ;; message-mode derived modes, such as mu4e-compose-mode

      (let (buffers)
        (save-current-buffer
          (dolist (buffer (buffer-list t))
            (set-buffer buffer)
            (when (and (derived-mode-p 'message-mode)
                       (null message-sent-message-via))
              (push (buffer-name buffer) buffers))))
        (nreverse buffers)))

    (setq gnus-dired-mail-mode 'mu4e-user-agent)

    (defun malb/attach-current-buffer ()
      "Attach the file visited by the current buffer to an e-mail."
      (interactive)
      (if (buffer-file-name)
          (cl-letf (((symbol-function 'yes-or-no-p) (lambda (prompt) t))
                    ((symbol-function 'y-or-n-p) (lambda (prompt) t)))
            (save-mark-and-excursion
              (gnus-dired-attach (list (buffer-file-name)))))
        (error "Buffer is not visiting a file")))))
#+end_src

*** Form filling

Automate standard “form filling“ workflow

1. save attachment
2. edit attachment
3. reply
4. attach attachment

#+begin_src emacs-lisp
(defun malb/mu4e-form-turnaround (&optional msg)
  (interactive)
  ;; spreadsheets and word documents
  (let ((mimetypes '("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                     "application/vnd.openxmlformats-officedocument.wordprocessingml.document"))
        files)
    ;; 1. save
    (dolist (part (mu4e-view-mime-parts))
      (let* ((filename (plist-get part :filename))
             (path (concat "/tmp/" filename)))
        (when (member (plist-get part :mime-type) mimetypes)
          (mm-save-part-to-file (plist-get part :handle) path)
          (add-to-list 'files path))))
    ;; 3. reply
    (with-current-buffer (mu4e-compose-reply)
      (dolist (file files)
        ;; 4. attach
        (cl-letf (((symbol-function 'yes-or-no-p) (lambda (prompt) t))
                  ((symbol-function 'y-or-n-p) (lambda (prompt) t)))
          (gnus-dired-attach (list file)))
        ;; 2. edit
        (helm-open-file-with-default-tool file)))))
#+end_src

*** Save all

Save all attachments at once ([[https://github.com/sje30/emacs/blob/master/mu4e-view-save-all-attachments.el][source]])

#+begin_src emacs-lisp
(defun malb/mu4e-view-save-all-attachments (&optional msg)
  "Save all MIME parts from current mu4e gnus view buffer.
If MSG is given use that instead."
  (interactive "P")
  (cl-assert (eq major-mode 'mu4e-view-mode))
  (let* ((msg (or msg (mu4e-message-at-point)))
         (id (replace-regexp-in-string "[^A-Z0-9]+" "-"
                                       (downcase (mu4e-message-field msg :subject))))
         (dir (concat (read-directory-name "Save to directory: ") "/" id)))
    (mkdir dir t)
    (dolist (part (mu4e-view-mime-parts))
      (let ((filename (plist-get part :filename)))
        (when (and (plist-get part :attachment-like)
                   filename)
          (mm-save-part-to-file (plist-get part :handle)
		                        (malb/next-free-filename
                                 (expand-file-name filename dir))))))))

(defun malb/next-free-filename (file)
  "Return name of next unique 'free' FILE.
If /tmp/foo.txt and /tmp/foo-1.txt exist, when this is called
with /tmp/foo.txt, return /tmp/foo-2.txt. This is not very
efficient if there are a large number of files already in the
directory with the same base name, as it simply starts searching
from 1 each time until it finds a gap. An alternative might be to
do a wildcard search for all the filenames, extract the highest
number and then increment it."
  ;; base case is easy; does file exist already?
  (if (not (file-exists-p file))
      file
    ;; othwerwise need to iterate through f-1.pdf
    ;; f-2.pdf, f-3.pdf ... until we no longer find a file.
    (let ((prefix (file-name-sans-extension file))
	      (suffix (file-name-extension file))
	      (looking t)
	      (n 0)
          f)
      (while looking
        (setq n (1+ n))
        (setq f (concat prefix "-" (number-to-string n) "." suffix))
        (setq looking (file-exists-p f)))
      f)))
#+end_src

** Actions

Action to save e-mail to PDF.

#+begin_src emacs-lisp
;;  from mu4e-view-old.el
(defun malb/mu4e--write-body-to-html (msg)
  "Write MSG's body to a temporary file;
return the filename."
  (let* ((browse-url-browser-function (lambda (url &optional _rest)))
         (tmpfile (mu4e-make-temp-file "html")))

    (with-temp-buffer
      (insert-file-contents-literally
       (mu4e-message-readable-path msg) nil nil nil t)
      (run-hooks 'gnus-article-decode-hook)
      (let ((header (cl-loop for field in '("from" "to" "cc" "date" "subject")
			                 when (message-fetch-field field)
			                 concat (format "<b>%s</b> : %s<br/>"
                                            (capitalize field)
                                            (htmlize-escape-or-link it))))
            (gnus-visible-headers "Z")
	        (parts (mm-dissect-buffer t t)))
        (message "HEADER: %s" header)
        ;; If singlepart, enforce a list.
        (when (and (bufferp (car parts))
		           (stringp (car (mm-handle-type parts))))
	      (setq parts (list parts)))
        (article-hide-headers)
        (insert header)
        (unless (gnus-article-browse-html-parts parts nil)
          (progn ;; fall back to plain
            (erase-buffer)
            (insert "<head><meta charset=\"UTF-8\"></head>\n")
            (insert (concat "<pre>" (mu4e-view-message-text msg) "</pre>"))))
        (mm-destroy-parts parts)
        (write-file tmpfile)
        tmpfile))))

(defun malb/mu4e-action-save-to-pdf (msg)
  (let* ((date (mu4e-message-field msg :date))
         (infile (malb/mu4e--write-body-to-html msg))
         (outfile (format-time-string "%Y-%m-%d%H%M%S.pdf" date)))
    (with-temp-buffer
      (shell-command
       (format "wkhtmltopdf %s ~/Downloads/%s" infile outfile) t))))

(add-to-list 'mu4e-view-actions '("save to pdf" . malb/mu4e-action-save-to-pdf) t)
#+end_src

#+begin_src emacs-lisp
(delete '("show this thread" . mu4e-action-show-thread) mu4e-view-actions)
#+end_src

#+begin_src emacs-lisp
(delete '("view as pdf" . mu4e-action-view-as-pdf) mu4e-view-actions)
#+end_src

#+begin_src emacs-lisp
(delete '("xview in xwidget" . mu4e-action-view-in-xwidget) mu4e-view-actions)
#+end_src

#+begin_src emacs-lisp
(add-to-list 'mu4e-view-actions '("Save all attachments" . malb/mu4e-view-save-all-attachments) t)
#+end_src

Action to search messages by/to sender.

#+begin_src emacs-lisp
(use-package mu4e-message
  :ensure nil
  :defer t
  :config
  (defun malb/search-for-sender (msg)
    "Search for messages sent by the sender of the message at point."
    (mu4e-headers-search
     (concat "from:" (cdar (mu4e-message-field msg :from)))))

  (defun malb/search-for-sender-extended (msg)
    "Search for messages sent by the sender of the message at point."
    (mu4e-headers-search
     (concat "from:"  (mu4e-headers-search (cdar (mu4e-message-field msg :from)))
             "OR to:" (mu4e-headers-search (cdar (mu4e-message-field msg :from)))
             "OR cc:" (mu4e-headers-search (cdar (mu4e-message-field msg :from))))))

  (add-to-list 'mu4e-view-actions
               '("from 🔍" . malb/search-for-sender) t)
  (add-to-list 'mu4e-headers-actions
               '("from 🔍" . malb/search-for-sender) t))
#+end_src

Action to search messages involving all correspondents.

#+begin_src emacs-lisp
(use-package mu4e-message
  :ensure nil
  :after helm
  :defer t
  :config
  (progn
    (require 'mu4e-search)
    (defun malb/find-correspondence (msg)
      "Find messages involving all correspondents."
      (let* ((addresses (append (mapcar (lambda (x) (downcase (plist-get x :email)))
                                        (mu4e-message-field msg :to))
                                (mapcar (lambda (x) (downcase (plist-get x :email)))
                                        (mu4e-message-field msg :cc))
                                (mapcar (lambda (x) (downcase (plist-get x :email)))
                                        (mu4e-message-field msg :from))))
             (addresses (cl-remove-if (lambda (x)
                                        (member x (mu4e-personal-addresses)))
                                      addresses))
             (selected-addresses (helm :sources
                                       (helm-build-sync-source "Filter candidates:"
                                         :candidates addresses
                                         :after-init-hook (lambda ()
                                                            (with-helm-buffer
                                                              (run-at-time 0.25 nil #'helm-mark-all)))
                                         :action '(("Filter" . (lambda (x)
                                                                 (helm-marked-candidates))))))))
        (mu4e-search (mapconcat (lambda (x) (format "contact:%s" x))
                                selected-addresses" AND ")))))

  (add-to-list 'mu4e-view-actions    '("interaction 🔍" . malb/find-correspondence) t)
  (add-to-list 'mu4e-headers-actions '("interaction 🔍" . malb/find-correspondence) t))
#+end_src

DWIM action. ~malb/mu4e-dwim-actions~ is a list of triples ~("from regexp" "subject regexp" (lambda (msg) …))~ where the lambda is executed whenever both regexps match. Processing does not stop after the first match.

#+begin_src emacs-lisp
(setq malb/mu4e-dwim-actions nil)

(defun malb/mu4e-dwim-action (msg)
  (let  ((from (plist-get (car (mu4e-message-field msg :from)) :email))
         (subject (mu4e-message-field msg :subject))
         (triggered nil))
    (dolist (action malb/mu4e-dwim-actions)
      (let ((from-regexp (car action))
            (subject-regexp (cadr action))
            (f (caddr action)))
        (when (and
               (not triggered)
               (string-match from-regexp from)
               (string-match subject-regexp subject))
          (setq triggered t)
          (funcall f msg))))))

(add-to-list 'mu4e-view-actions
             '("dwim" . malb/mu4e-dwim-action) t)
(add-to-list 'mu4e-headers-actions
             '("dwim" . malb/mu4e-dwim-action) t)
#+end_src

This can be useful for writing DWIM actions: ([[https://etienne.depar.is/emacs.d/mu4e.html][source]])

#+begin_src emacs-lisp
(defun malb/get-mail-header (header-name path)
  (replace-regexp-in-string
   "[ \t\n]*$"
   ""
   (shell-command-to-string
    (concat "sed -n '/^"
            header-name
            ":/I{:loop t;h;n;/^ /{H;x;s/\\n//;t loop};x;p}' '"
            path
            "' | sed -n 's/^"
            header-name
            ": \\(.*\\)$/\\1/Ip'"))))
#+end_src

#+begin_src emacs-lisp
(defun malb/edit-raw-email (msg)
  (find-file (plist-get msg :path)))

(add-to-list 'mu4e-view-actions '("Edit raw" . malb/edit-raw-email) t)
(add-to-list 'mu4e-headers-actions '("Edit raw" . malb/edit-raw-email) t)
#+end_src

#+begin_src emacs-lisp
(defun malb/mail-summarize (msg)
  (let ((display-buffer-alist nil))
    (malb/register-popup-window (rx bos "ellama-session"))
    (malb/summarize-llm)))

(add-to-list 'mu4e-view-actions '("/summarise" . malb/mail-summarize) t)
#+end_src

** Composing

Don’t break long lines manually.

#+begin_src emacs-lisp
(setq mu4e-compose-format-flowed t)

(defun malb/no-hard-newlines ()
  (setq use-hard-newlines nil))

(add-hook 'mu4e-compose-mode-hook #'malb/no-hard-newlines)
#+end_src

#+begin_src emacs-lisp
(add-hook 'message-mode-hook #'flyspell-mode)
(add-hook 'message-mode-hook #'typo-mode)
#+end_src

#+begin_src emacs-lisp
(defun malb/mu4e-compose-mode-hook ()
  (set-fill-column 80))

(add-hook 'mu4e-compose-mode-hook #'malb/mu4e-compose-mode-hook)
#+end_src

Don’t add an empty line after “On bla” line but add one before.

#+begin_src emacs-lisp
(require 'message)

(malb/defadvice! malb/message-insert-formatted-citation-line (fn &rest args)
  :around 'message-insert-formatted-citation-line
  (insert "\n\n")
  (insert (with-temp-buffer
            (apply fn args)
            (goto-char (- (point-max) 1))
            (delete-char 1)
            (buffer-substring-no-properties (point-min) (point-max)))))

(setq message-citation-line-function #'message-insert-formatted-citation-line)
#+end_src

Various shortcuts to jump to/create headers.

#+begin_src emacs-lisp
(bind-key "C-c g t" #'message-goto-to mu4e-compose-mode-map)
(bind-key "C-c g c" #'message-goto-cc mu4e-compose-mode-map)
(bind-key "C-c g b" #'message-goto-bcc mu4e-compose-mode-map)
(bind-key "C-c g f" #'message-goto-from mu4e-compose-mode-map)
(bind-key "C-c g s" #'message-goto-subject mu4e-compose-mode-map)
(bind-key "C-c g s" #'message-goto-subject mu4e-compose-mode-map)
(bind-key "C-c z" #'malb/fixup-email mu4e-compose-mode-map)
#+end_src

Don’t ask me to remove the backup file, I do want to remove the backup file, too.

#+begin_src emacs-lisp
(defun malb/yes-no-skip-remove-backup (orig-fn &rest args)
  (if (string-prefix-p "Remove the backup file" (car args))
      t
    (apply orig-fn args)))

(advice-add #'yes-or-no-p :around #'malb/yes-no-skip-remove-backup)
#+end_src

#+begin_src emacs-lisp
(defun malb/fixup-email (&optional formalize)
  (interactive "P")
  (save-excursion
    (let ((beg (save-excursion
                 (message-goto-body)
                 (when (or (looking-at-p (rx bol "Hi"))
                           (looking-at-p (rx bol "Dear")))
                   (forward-line))
                 (insert "\n")
                 (point)))
          (end (save-excursion
                 (message-goto-body)
                 (while (not (or (looking-at-p (rx bol "On .* wrote:" eol))
                                 (looking-at-p (rx bol "Cheers," eol))
                                 (looking-at-p (rx bol "Best," eol))
                                 (looking-at-p (rx bol "Martin" eol))
                                 (looking-at-p message-signature-separator)))
                   (forward-line))
                 (forward-line -1)
                 (point))))
      (push-mark beg)
      (goto-char end)
      (insert "\n")
      (goto-char end)
      (setq mark-active t)
      (if formalize
          (malb/formalize-email-llm)
        (malb/fix-grammar-llm)))))
#+end_src

([[https://github.com/djcb/mu/issues/2665#issuecomment-2016826822][source]])

#+begin_src emacs-lisp
(defun malb/supersede-or-compose-reply-ask-wide ()
  "Supersede own messages or ask whether to reply-to-all."
  (interactive)
  (if (mu4e-message-contact-field-matches-me (mu4e-message-at-point) :from)
      (mu4e-compose-wide-reply)
    (let ((tos (length (mu4e-message-field-at-point :to)))
          (ccs (length (mu4e-message-field-at-point :cc))))
      (mu4e-compose-reply
       (and (> (+ tos ccs) 1)
            (yes-or-no-p "Reply to all?"))))))

(bind-key "R" #'malb/supersede-or-compose-reply-ask-wide 'mu4e-compose-minor-mode-map)
#+end_src

Do not restore window configuration (not necessary) or kill frame (handled by dedicated buffers)

#+begin_src emacs-lisp
(setq mu4e-compose-post-hook nil)
#+end_src

** Context Switching

Update "From:" and signature on context switch.

([[https://github.com/djcb/mu/issues/776][source]])

#+begin_src emacs-lisp
(defun malb/mu4e-compose-context-switch (&rest _ignore)
  "When switching context in a compose buffer, switch “from” and signature."
  (when (eq major-mode 'mu4e-compose-mode)
    (message-replace-header "From" (mu4e-contact-full (mu4e-contact-make
                                                       user-full-name
                                                       user-mail-address)))
    (setq malb/message-sig-cycle 0)
    (malb/message-remove-signature)
    (save-excursion (message-insert-signature))))

(advice-add 'mu4e-context-switch :after #'malb/mu4e-compose-context-switch)

(defun malb/message-remove-signature ()
  "Find and remove signature."
  (save-excursion
    (when (message-goto-signature)
      (forward-line -1)
      (delete-region (1- (point)) (point-max)))))

(defun malb/message-send-check-context ()
  "Check that from address and context matches, and ask to change if required.

This is to avoid making mistakes in trying to send the current
message from the wrong account"
  ;; this may be a too strict check
  (when (not (string= (message-fetch-field "from")
                      (mu4e-contact-full (mu4e-contact-make
                                          user-full-name
                                          user-mail-address))))
    (let ((context (mu4e-context-determine nil nil)))
      (cond ((and context
                  (yes-or-no-p
                   (format
                    "Attempt to send via mismatching context. Switch to [%s] and send? "
                    (mu4e-context-name context))))
             (mu4e-context-switch t (mu4e-context-name context)))
            ((not context)
             (mu4e-context-switch
              t
              (mu4e-context-name  ; throws an error if no context found:
               (mu4e--context-ask-user
                "Attempt to send via mismatching context! Send after switching to: "))))
            (t (signal 'quit nil))))))


(malb/defadvice! malb/message-generate-date (&rest args)
  "Always generate date before sending"
  :before 'message-send
  (save-restriction
    (message-narrow-to-headers)
    (message-remove-header "Date")))

(add-hook 'message-send-hook #'malb/message-send-check-context)
#+end_src

#+begin_src emacs-lisp
(defun malb/mu4e-cycle-contexts ()
  "Cycle through `mu4e-contexts'."
  (interactive)
  (when mu4e-contexts
    (let* ((names (mapcar #'mu4e-context-name mu4e-contexts))
           (currentname (ignore-errors (mu4e-context-name mu4e--context-current))))
      (mu4e-context-switch t
                           (nth
                            (mod (if currentname
                                     (1+ (cl-position currentname names :test #'equal))
                                   0)
                                 (length names))
                            names)))))

(bind-key "C-c C-i" #'malb/mu4e-cycle-contexts mu4e-compose-mode-map)
#+end_src

** Window Management

We allow helm buffers in the mu4e frame, e.g. to pick attachments.

#+begin_src emacs-lisp
(defvar malb/mu4e-buffer-allowed-regexps `(,(rx bos "*helm" (zero-or-more any) "*" eos)
                                           ,(rx bos "ellama-session"))
  "Buffer names allowed in mu4e frame.")
#+end_src

#+begin_src emacs-lisp
(defun malb/switch-to-mu4e ()
  (let ((other-frame (malb/mu4e-frame)))
    (if other-frame
        (select-frame-set-input-focus other-frame)
      (progn
        (select-frame (make-frame '((malb/special-frame . t))))
        (set-frame-name "*mu4e*")))))

(defun malb/switch-to-mu4e-advice (old-function &rest arguments)
  (malb/switch-to-mu4e)
  (apply old-function arguments))

;; TODO: It is not clear why this is needed
(advice-add #'mu4e-view :around  #'malb/switch-to-mu4e-advice)
#+end_src

Find a frame which is the mu4e frame or create a fresh one.

#+begin_src emacs-lisp
(defun malb/mu4e-frame ()
  "Return mu4e main frame if any."
  (catch 'other-frame
    (dolist (frame (frame-list))
      (if (string-match "\\*mu4e\\*" (frame-parameter frame 'name))
          (progn
            (dolist (window (window-list frame))
              (with-current-buffer (window-buffer window)
                (when (or (eq major-mode 'mu4e-headers-mode)
                          (eq major-mode 'mu4e-main-mode))
                  (throw 'other-frame frame))))
            nil)
        nil))))
#+end_src

Kill the mu4e frame.

#+begin_src emacs-lisp
(defun malb/mu4e-quit-session ()
  (interactive)
  (kill-buffer)
  (delete-frame))

(bind-key "q" #'malb/mu4e-quit-session mu4e-main-mode-map)
#+end_src


#+begin_src emacs-lisp
(defun malb/mu4e-view-quit ()
  (interactive)
  (when (not (malb/quit-bottom-disposable-windows))
    (mu4e-view-quit)))

(bind-key "q" #'malb/mu4e-view-quit mu4e-view-mode-map)
#+end_src

We dispatch to our own display function in =malb/frame-dispatch=.

#+begin_src emacs-lisp
(defun malb/display-mu4e-draft-buffer (buffer alist)
  (display-buffer-pop-up-frame buffer
                               '((window-parameters . ((no-other-window . t)))
                                 (dedicated . t)
                                 (pop-up-frame-parameters . ((width . 82)
                                                             (malb/special-frame . t))))))
#+end_src

Update buffer treatment:

#+begin_src emacs-lisp
(add-to-list 'display-buffer-alist
             `(,(regexp-quote mu4e--update-name)
               (display-buffer-reuse-window
                display-buffer-below-selected)
               (reusable-frames . nil)
               (dedicated . t)
               (window-parameters
                (no-other-window . t)
                (no-delete-other-windows . t))
               (window-height   . 0.2)))
#+end_src

Open raw view in message view or below.

#+begin_src emacs-lisp
(add-to-list 'display-buffer-alist
             `(,(rx "*mu4e-raw-view*")
               (display-buffer-reuse-window
                display-buffer-below-selected)))
#+end_src

** PGP / GnuPG

#+begin_src emacs-lisp
(setq mml2015-encrypt-to-self t)
(define-key mu4e-compose-mode-map (kbd "C-c s") 'mml-secure-message-sign-pgpmime)
(define-key mu4e-compose-mode-map (kbd "C-c e") 'mml-secure-message-encrypt-pgpmime)
(setq epg-gpg-program "gpg")
#+end_src

** iCal

#+begin_src emacs-lisp
(use-package gnus-icalendar
  :ensure nil
  :config (gnus-icalendar-setup))
#+end_src

** Mu4e 🖤 Org

Link to mu4e messages and threads.

#+begin_src emacs-lisp
(use-package mu4e-org
  :ensure nil
  :config (setq mu4e-org-link-query-in-headers-mode t))
#+end_src

** Mail merge
:PROPERTIES:
:BCC:       Eve <eve@example.com>
:END:

Given a table called =mm-data= and a source code block called =mm-template= this function composes e-mails by rendering the =mm-template= using the =mm-data=. Special fields: =TO=, =CC=, =BCC=. The subject is taking from the heading. Inspired by [[https://github.com/jkitchin/scimax/blob/68aaf5f0685a23c3ae60b16613c5bcd20e8a158b/scimax-email.el][scimax-email.el]].

Uses [[https://github.com/clarete/templatel][templatel]] for … templates.

#+begin_src emacs-lisp
(use-package templatel)
#+end_src

*Example:*

#+name: mm-data
| TO                        | CC                            | name  | foo |
|---------------------------+-------------------------------+-------+-----|
| <10>                      |                               |       |     |
| Alice <alice@example.com> |                               | Alice |  32 |
| Bob <bob@example.com>     | Charley <charley@example.com> | Bob   |  42 |


#+name: mm-template
#+begin_src markdown
Hi {{ name }},

Here's a number {{ foo }}, it's, like, secret.

{% if foo == "42" %}Whoah, it is 42.{% else %}It is, however, not 42.{% endif %}

Best,
Martin
#+end_src

#+begin_src emacs-lisp
(defun malb/mail-merge (&optional just-send)
  "Mail merge data table named `data' and template named `template'."
  (interactive "P")
  (save-excursion
    (save-restriction
      (org-narrow-to-subtree)
      (goto-char (point-min))

      (let ((data (malb/org-table-to-alist "mm-data"))
            (template (malb/org-src-to-string "mm-template"))
            (to  (org-entry-get (point) "TO"))
            (cc  (org-entry-get (point) "CC"))
            (bcc (org-entry-get (point) "BCC"))
            (subject (nth 4 (org-heading-components)))
            (context-set-p nil))

        (dolist (entry data)
          (let  ((body (templatel-render-string template entry))
                 (subject (templatel-render-string subject entry))
                 (mu4e-compose-context-policy (if context-set-p
                                                  'ask-if-none
                                                mu4e-compose-context-policy))
                 (to (if (assoc "TO" entry) (cdr (assoc "TO" entry)) to))
                 (cc (if (assoc "CC" entry) (cdr (assoc "CC" entry)) cc))
                 (bcc (if (assoc "BCC" entry) (cdr (assoc "BCC" entry)) bcc)))

            (when (and (> (length to) 0) (string-match-p "@" to))
              (with-current-buffer (mu4e-compose-new to subject)
                (message-goto-body)
                (insert body)

                (when (and cc (> (length cc) 0))
                  (message-goto-cc)
                  (insert cc))

                (when (and bcc (> (length bcc) 0))
                  (message-goto-bcc)
                  (insert bcc))

                ;; move point back to the top
                (message-goto-to)

                ;; we assume all e-mails should be sent from the same context
                (setq context-set-p t)

                (when just-send
                  (message-send-and-exit)))))))))

  (let ((display-buffer-alist nil))
    (when (and (nth 2 (org-heading-components)) just-send)
      (org-todo "DONE"))))
#+end_src

** Debugging

#+begin_src shell :tangle no
emacs -Q -l ~/.emacs.d/mu4e-test.el
#+end_src

#+begin_src emacs-lisp :tangle mu4e-test.el
(package-initialize)
(add-to-list 'load-path "~/.emacs.d/local/mu4e/")
(require 'mu4e)

(setq mu4e-headers-skip-duplicates t
      mu4e-view-show-images t
      message-kill-buffer-on-exit t
      mu4e-hide-index-messages t
      mu4e-auto-retrieve-keys t
      message-dont-reply-to-names #'mu4e-personal-or-alternative-address-p
      mu4e-completing-read-function 'completing-read
      mu4e-compose-switch 'display-buffer
      mu4e-split-view 'vertical
      mu4e-headers-visible-columns 134
      mu4e-headers-visible-lines 16
      mu4e-context-policy 'pick-first
      mu4e-compose-context-policy 'ask
      mu4e-change-filenames-when-moving t
      mu4e-confirm-quit nil
      mu4e-index-cleanup t
      mu4e-view-show-addresses t
      mu4e-headers-precise-alignment t
      mu4e-compose-complete-only-after nil
      mu4e-index-lazy-check nil
      mu4e-headers-auto-update nil
      mu4e-org-link-query-in-headers-mode t
      mu4e-eldoc-support t
      mu4e-modeline-support nil)

(setq mu4e-contexts
      `( ,(make-mu4e-context
           :name "Google Mail"
           :vars `((user-mail-address . "martinralbrecht@googlemail.com")
                   (send-mail-function . sendmail-send-it)
                   (sendmail-program . "/usr/sbin/sendmail")
                   (message-send-mail-function . message-send-mail-with-sendmail)
                   (mu4e-drafts-folder . "/gmail/[Google Mail]/Drafts")
                   (mu4e-sent-folder   . "/gmail/[Google Mail]/Sent Mail")
                   (mu4e-trash-folder  . "/gmail/[Google Mail]/Bin")
                   (mu4e-sent-messages-behavior . delete)))))
#+end_src

* Blogging

We change the default template to not include the title which is filled in by deft. We also query the user for a date/time for the blog post.

#+begin_src emacs-lisp
(use-package org2blog
  :config (progn
            (let ((credentials (auth-source-user-and-password "martinralbrecht.wordpress.com")))
              (setq org2blog/wp-blog-alist
                    `(("martinralbrecht"
                       :url "https://martinralbrecht.wordpress.com/xmlrpc.php"
                       :username ,(car credentials)
                       :password ,(cadr credentials)))))
            (setq org2blog/wp-track-posts (list malb/work-org "Bloglog"))

            (defun malb/org2blog/wp-format-buffer (buffer-template)
              "Buffer formatting function without title."
              (format buffer-template
                      (format-time-string "[%Y-%m-%d %a %H:%M]" (org-read-date t t))
                      (mapconcat
                       (lambda (cat) cat)
                       (or (plist-get (cdr org2blog/wp-blog) :default-categories)
                           org2blog/wp-default-categories)
                       ", ")))

            (setq org2blog/wp-use-sourcecode-shortcode nil
                  org2blog/wp-image-upload t
                  org2blog/wp-show-post-in-browser nil
                  org2blog/wp-default-categories '("cryptography")
                  org2blog/wp-buffer-format-function #'malb/org2blog/wp-format-buffer
                  org2blog/wp-buffer-template "#+DATE: %s
,#+OPTIONS: toc:nil num:nil todo:nil pri:nil tags:nil ^:nil
,#+CATEGORY: %s
,#+TAGS:
,#+DESCRIPTION:
\n")
            ;; https://github.com/org2blog/org2blog/issues/193
            (malb/defadvice! malb/org2blog--upload-files-replace-urls (orig-function text)
              :around #'org2blog-buffer-post-save
              (let ((org-export-show-temporary-export-buffer nil))
                (apply orig-function (list text))))))
#+end_src

https://github.com/org2blog/org2blog/wiki/Debugging-Stories

* PDF Viewer

[[https://github.com/politza/pdf-tools][PDF tools]] is a nice PDF viewer for Emacs.

We also add support to extract PDF annotations to a temporary org-mode/markdown buffer, based on [[https://github.com/machc/pdf-tools-org][pdf-tools-org]], and calling [[https://github.com/tabulapdf/tabula-java][tabular]] or [[https://en.wikipedia.org/wiki/Pdftotext][pdftotext]].

#+begin_src emacs-lisp
(use-package pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :after (org tex)
  :config (progn
            (pdf-tools-install)
            (setq-default pdf-view-display-size 'fit-page)

            (require 'pdf-annot)

            (setq pdf-annot-default-annotation-properties
                  `((t (label . "M"))
                    (text (icon . "Note")
                          (color . "#dc322f"))
                    (highlight (color . "#fef3d5"))
                    (squiggly (color . "#dc322f"))
                    (strike-out(color . "#dc322f"))
                    (underline (color . "#268bd2"))))

            (setq pdf-view-resize-factor 1.1
                  pdf-annot-activate-created-annotations t
                  pdf-view-midnight-invert nil
                  pdf-misc-print-programm "gtklp")

            (add-hook 'pdf-annot-list-mode-hook #'pdf-annot-list-follow-minor-mode)

            (defun malb/pdf-extract-table (&optional format)
              (let* ((format- (upcase (or format "CSV")))
                     (pdf-filename (buffer-file-name))
                     (txt-filename (make-temp-name "/tmp/tabula-"))
                     (buffer (generate-new-buffer
                              (generate-new-buffer-name (format "*tabular<%s>*"
                                                                (file-name-base pdf-filename))))))
                (shell-command (format "java -jar %s -f %s -p %d -o \"%s\" \"%s\""
                                       malb/tabular-jar
                                       format-
                                       (pdf-view-current-page)
                                       txt-filename
                                       pdf-filename)
                               nil)
                (pop-to-buffer buffer)
                (insert-file-contents txt-filename)
                (cond
                 ((eq format nil) (progn
                                    (org-mode)
                                    (call-interactively 'mark-whole-buffer)
                                    (call-interactively 'org-table-convert-region)))
                 ((string-equal format "JSON") (progn
                                                 (json-mode)
                                                 (json-pretty-print-buffer))))
                (delete-file txt-filename)))

            (defun malb/pdf-extract-text ()
              (let* ((pdf-filename (buffer-file-name))
                     (txt-filename (make-temp-name "/tmp/tabula-"))
                     (buffer (generate-new-buffer
                              (generate-new-buffer-name (format "*pdftotext<%s>*"
                                                                (file-name-base pdf-filename))))))
                (shell-command (format "pdftotext -layout -nopgbrk \"%s\" \"%s\""
                                       pdf-filename txt-filename)
                               nil)
                (pop-to-buffer buffer)
                (insert-file-contents txt-filename)
                (delete-file txt-filename)))

            (defun malb/pdf-view-llncs-from-bounding-box (arg &optional window)
              "Set the height from the page's bounding-box."
              (interactive "P")
              (let* ((bb (pdf-cache-boundingbox (pdf-view-current-page window)))
                     (h-margin (max (if arg 0.35 0.28) (or pdf-view-bounding-box-margin 0.0)))
                     (w-margin (max 0.05 (or pdf-view-bounding-box-margin 0.0)))
                     (slice (list (- (nth 0 bb)
                                     (/ h-margin 2.0))
                                  (- (nth 1 bb)
                                     (/ w-margin 2.0))
                                  (+ (- (nth 2 bb) (nth 0 bb))
                                     h-margin)
                                  (+ (- (nth 3 bb) (nth 1 bb))
                                     w-margin))))
                (apply 'pdf-view-set-slice
                       (append slice (and window (list window))))))

            (defun pdf-tools-org-edges-to-region (edges)
              "Attempt to get 4-entry region \(LEFT TOP RIGHT BOTTOM\) from several EDGES.
We need this to import annotations and to get marked-up text, because
annotations are referenced by its edges, but functions for these tasks
need region."
              (let ((left0 (nth 0 (car edges)))
                    (top0 (nth 1 (car edges)))
                    (bottom0 (nth 3 (car edges)))
                    (top1 (nth 1 (car (last edges))))
                    (right1 (nth 2 (car (last edges))))
                    (bottom1 (nth 3 (car (last edges))))
                    (n (safe-length edges)))
                ;; we try to guess the line height to move
                ;; the region away from the boundary and
                ;; avoid double lines
                (list left0
                      (+ top0 (/ (- bottom0 top0) 3))
                      right1
                      (- bottom1 (/ (- bottom1 top1) 3)))))

            (defun malb/pdf-annot-export-as-org (compact)
              "Export annotations to Org Buffer."
              (interactive "P")
              (let* ((annots (sort (pdf-annot-getannots) 'pdf-annot-compare-annotations))
                     (source-buffer (current-buffer))
                     (source-buffer-name (file-name-sans-extension (buffer-name)))
                     (source-file-name (buffer-file-name source-buffer))
                     (target-buffer-name (format "*Notes for %s*" source-buffer-name))
                     (target-buffer (get-buffer-create target-buffer-name)))

                (with-current-buffer target-buffer
                  (org-mode)
                  (erase-buffer)
                  (visual-fill-column-mode)

                  (insert (format "#+title: Notes for %s\n" source-buffer-name))
                  (insert (format "#+startup: indent\n\n"))
                  (insert (format "source: [[%s][%s]]\n\n" source-file-name source-buffer))

                  (mapc (lambda (annot) ;; traverse all annotations
                          (progn
                            (let ((page (cdr (assoc 'page annot)))
                                  (highlighted-text
                                   (if (pdf-annot-get annot 'markup-edges)
                                       (let ((highlighted-text
                                              (with-current-buffer source-buffer
                                                (pdf-info-gettext (pdf-annot-get annot 'page)
                                                                  (pdf-tools-org-edges-to-region
                                                                   (pdf-annot-get annot 'markup-edges))))))
                                         (replace-regexp-in-string "\n" " " highlighted-text))
                                     nil))
                                  (note (pdf-annot-get annot 'contents)))

                              (when (or highlighted-text (> (length note) 0))
                                (insert (if compact "- " "* "))
                                (insert (format "page %s" page))

                                (when highlighted-text
                                  (insert (if compact (format ": “%s” " highlighted-text)
                                            (concat "\n\n#+begin_quote\n"
                                                    highlighted-text
                                                    "\n#+end_quote"))))
                                (if (> (length note) 0)
                                    (insert (if compact (format " %s\n" note)
                                              (format "\n\n%s\n\n" note)))
                                  (insert (if compact "\n" "\n\n")))))))
                        (cl-remove-if
                         (lambda (annot) (member (pdf-annot-get-type annot) (list 'link)))
                         annots))
                  )
                (pop-to-buffer target-buffer '(display-buffer-pop-up-window))))

            (defun malb/pdf-annot-export-as-md (compact)
              "Export annotations to Makrdown buffer."
              (interactive "P")
              (let* ((annots (sort (pdf-annot-getannots) 'pdf-annot-compare-annotations))
                     (source-buffer (current-buffer))
                     (source-buffer-name (file-name-sans-extension (buffer-name)))
                     (source-file-name (buffer-file-name source-buffer))
                     (target-buffer-name (format "*Notes for %s*" source-buffer-name))
                     (target-buffer (get-buffer-create target-buffer-name)))
                (with-current-buffer target-buffer
                  (markdown-mode)
                  (erase-buffer)
                  (visual-fill-column-mode)

                  (insert (format "---\ntitle: Notes for %s\n---\n\n" source-buffer-name))
                  (insert (format "source: [%s](%s)\n\n" source-buffer source-file-name))
                  (mapc (lambda (annot) ;; traverse all annotations
                          (progn
                            (let ((page (cdr (assoc 'page annot)))
                                  (highlighted-text
                                   (if (pdf-annot-get annot 'markup-edges)
                                       (let ((highlighted-text
                                              (with-current-buffer source-buffer
                                                (pdf-info-gettext (pdf-annot-get annot 'page)
                                                                  (pdf-tools-org-edges-to-region
                                                                   (pdf-annot-get annot 'markup-edges))))))
                                         (replace-regexp-in-string "\n" " " highlighted-text))
                                     nil))
                                  (note (pdf-annot-get annot 'contents)))

                              (when (or highlighted-text (> (length note) 0))
                                (insert (if compact "- " "On "))
                                (insert (format "page %s" page))

                                (when highlighted-text
                                  (insert (if compact (format ": “%s” " highlighted-text)
                                            (concat ":  \n> "
                                                    (replace-regexp-in-string "\n" "\n> " highlighted-text)
                                                    "\n"))))
                                (if (> (length note) 0)
                                    (insert (if compact (format " %s\n" note)
                                              (format "\n\n%s\n\n" note)))
                                  (insert (if compact "\n" "\n\n")))))))
                        (cl-remove-if
                         (lambda (annot) (member (pdf-annot-get-type annot) (list 'link)))
                         annots)))
                (pop-to-buffer target-buffer '(display-buffer-pop-up-window))))

            (defhydra malb/hydra-pdf-extract (:color blue)
              "
Org:       _o_ compact  _O_ normal     _t_ table
Markdown:  _m_ compact  _M_ normal
Other:     _p_ plain    _c_ csv table  _j_ json table _x_ ocr
"
              ("o" (lambda () (interactive) (malb/pdf-annot-export-as-org 1)))
              ("O" malb/pdf-annot-export-as-org)
              ("m" (lambda () (interactive) (malb/pdf-annot-export-as-md  1)))
              ("M" malb/pdf-annot-export-as-md)
              ("c" (lambda () (interactive) (malb/pdf-extract-table "CSV")))
              ("j" (lambda () (interactive) (malb/pdf-extract-table "JSON")))
              ("t" (lambda () (interactive) (malb/pdf-extract-table)))
              ("p" (lambda () (interactive) (malb/pdf-extract-text)))
              ("x" (lambda () (interactive) (start-process (format "ocr %s" buffer-file-name)
                                                           nil "ocrmypdf" buffer-file-name buffer-file-name)))
              ("q" nil "cancel"))

            (bind-key "s h" #'malb/pdf-view-llncs-from-bounding-box pdf-view-mode-map)
            (bind-key "D" #'dedicated-mode pdf-view-mode-map)
            (bind-key "x" #'malb/hydra-pdf-extract/body pdf-view-mode-map)

            (defun malb/pdf-annot-move (forward)
              (let ((annot-list (with-current-buffer
                                    (pdf-annot-get-buffer pdf-annot-edit-contents--annotation)
                                  pdf-annot-list-buffer)))
                (if annot-list
                    (progn
                      (pdf-annot-edit-contents-commit)
                      (if forward
                          (call-interactively 'tablist-next-line)
                        (call-interactively 'tablist-previous-line))
                      (call-interactively 'tablist-find-entry))
                  (let ((this nil)
                        (next nil)
                        (annotations
                         (sort (pdf-annot-getannots
                                nil nil
                                (cdar pdf-annot-edit-contents--annotation))
                               'pdf-annot-compare-annotations)))
                    (dolist (annot (if forward annotations (reverse annotations)))
                      (when (equal this t)
                        (setq next annot)
                        (setq this nil))
                      (when (equal (pdf-annot-get-id annot)
                                   (pdf-annot-get-id pdf-annot-edit-contents--annotation))
                        (setq this t)))
                    (pdf-annot-edit-contents-finalize t)
                    (when next
                      (pdf-view-goto-page (pdf-annot-get next 'page))
                      (pdf-annot-edit-contents next))))))

            (defun malb/pdf-annot-next ()
              (interactive)
              (malb/pdf-annot-move t))

            (defun malb/pdf-annot-prev ()
              (interactive)
              (malb/pdf-annot-move nil))

            (defun malb/pdf-annot-yank-highlight ()
              (interactive)
              (let* ((a pdf-annot-edit-contents--annotation)
                     (text
                      (replace-regexp-in-string
                       "\n" " "
                       (pdf-info-gettext
                        (pdf-annot-get a 'page)
                        (pdf-tools-org-edges-to-region (pdf-annot-get a 'markup-edges))
                        0
                        (pdf-annot-get a 'buffer)))))
                (insert (format "\"%s\"" text))))

            (bind-key "C-c C-n" 'malb/pdf-annot-next pdf-annot-edit-contents-minor-mode-map)
            (bind-key "C-c C-p" 'malb/pdf-annot-prev pdf-annot-edit-contents-minor-mode-map)
            (bind-key "C-c C-y" 'malb/pdf-annot-yank-highlight pdf-annot-edit-contents-minor-mode-map)

            (defun malb/do-to-pdf-view-buffer (fn)
              (let ((cur-window (get-buffer-window)))
                (dolist (window (window-list))
                  (let ((buffer (window-buffer window)))
                    (with-current-buffer buffer
                      (when (eq major-mode 'pdf-view-mode)
                        (select-window window)
                        (call-interactively fn)
                        (select-window cur-window)
                        ))))))

            (defun malb/other-pdf-view-next-page ()
              (interactive)
              (malb/do-to-pdf-view-buffer #'pdf-view-next-page))

            (defun malb/other-pdf-view-prev-page ()
              (interactive)
              (malb/do-to-pdf-view-buffer #'pdf-view-previous-page))

            (bind-key "C->" #'malb/other-pdf-view-next-page org-mode-map)
            (bind-key "C-<" #'malb/other-pdf-view-prev-page org-mode-map)
            (bind-key "C->" #'malb/other-pdf-view-next-page LaTeX-mode-map)
            (bind-key "C-<" #'malb/other-pdf-view-prev-page LaTeX-mode-map)))
#+end_src

* Directories
** Dired

=dired-listing-switches= explained:

- =l=: Is the only mandatory one.
- =a=: Means to list invisible files.
- =G=: Don't show group information.
- =h=: Human readable sizes, such as M for megabytes.
- =1v=: Affects the sorting of digits, hopefully in a positive way.
- =--group-directories-first=: self-explanatory

Note, you can use =dired-toggle-read-only= (=C-x C-q=) to make a Dired buffer editable to batch-rename.

#+begin_src emacs-lisp
(use-package dired
  :ensure nil
  :commands dired
  :custom ((dired-recursive-copies 'always)
           (dired-recursive-deletes 'always)
           (dired-dwim-target t)
           (dired-vc-rename-file t)
           (dired-omit-verbose nil)
           (dired-auto-revert-buffer t)
           (dired-listing-switches "-laGh1v --group-directories-first")
           (wdired-allow-to-change-permissions t)
           (wdired-use-dired-vertical-movement 'sometimes))
  :bind (:map dired-mode-map
              ("a"   . dired-find-file-other-window)
              ("RET" . dired-find-alternate-file)
              ("^"   . (lambda () (interactive) (find-alternate-file "..")))
              ("q"   . (lambda () (interactive) (find-alternate-file "..")))
              ("Q"   . quit-window)
              ("C-s" . dired-isearch-filenames)
              ("C-c C-o" . malb/dired-xdg-open-file))
  :config (progn
            (require 'dired-x)

            (defvar malb/unimportant-files
              (rx (or (seq "." (or "aux"
                                   "bak"
                                   "bcf"
                                   "bib.backup"
                                   "blg"
                                   "dvi"
                                   "fdb_latexmk"
                                   "fls"
                                   "idx"
                                   "log"
                                   "nav"
                                   "orig"
                                   "out"
                                   "pyg"
                                   "rej"
                                   "run.xml"
                                   "snm"
                                   "synctex.gz"
                                   "tex.backup"
                                   "toc"
                                   "vrb")
                           eos)
                      (seq bos "autosaves#")
                      (seq bos (opt ".") "#")
                      (seq bos "." (one-or-more nonl) eos))))

            (setq dired-garbage-files-regexp malb/unimportant-files)
            (setq dired-omit-files malb/unimportant-files)

            (dolist (ext  '(".brf" ".bmt" ".out" ".nav" ".snm" ".vrb" ".synctex.gz"))
              (push ext dired-latex-unclean-extensions))

            (defun malb/enable-dired-omit-mode ()
              (dired-omit-mode))

            (add-hook 'dired-mode-hook #'malb/enable-dired-omit-mode)

            (defun malb/dired-layout ()
              (setq-local tab-width 1)
              (toggle-truncate-lines 1))

            (add-hook 'dired-mode-hook #'malb/dired-layout)

            (defun malb/dired-xdg-open-file ()
              "In dired, open the file named on this line."
              (interactive)
              (let* ((file (dired-get-filename nil t)))
                (call-process "xdg-open" nil 0 nil file)))

            (dired-async-mode)

            (put 'dired-find-alternate-file 'disabled nil)

            ;; https://www.reddit.com/r/emacs/comments/u2lf9t/weekly_tips_tricks_c_thread/
            (defun dired-dim-git-ignores ()
              "Dim out .gitignore contents"
              (when-let ((foo (require 'vc))
                         (ignores (vc-default-ignore-completion-table 'git ".gitignore"))
                         (exts (make-local-variable 'completion-ignored-extensions)))
                (dolist (item ignores)
                  (add-to-list exts item))))

            (add-hook 'dired-mode-hook #'dired-dim-git-ignores)))
#+end_src

#+begin_src emacs-lisp
(use-package image-dired
  :ensure nil
  :config (setq image-dired-thumbnail-storage 'standard-x-large
                image-dired-thumb-margin 16))
#+end_src

[[https://github.com/Fuco1/dired-hacks][dired-collapse]] renders directories with just one file like GitHub does.

#+begin_src emacs-lisp
(use-package dired-collapse
  :after dired)
#+end_src

[[https://github.com/Fuco1/dired-hacks#dired-narrow][dired-narrow]] to … narrow down dired buffers, undo with =g=.

#+begin_src emacs-lisp
(use-package dired-narrow
  :after dired
  :bind (:map dired-mode-map ("/" . dired-narrow)))
#+end_src

[[https://github.com/Fuco1/dired-hacks#dired-subtree][dired-subtree]] to insert subtrees.

#+begin_src emacs-lisp
(use-package dired-subtree
  :after all-the-icons
  :config (progn
            (defun malb/dired-subtree-all-the-icons ()
              (when all-the-icons-dired-mode (revert-buffer)))
            (advice-add 'dired-subtree-toggle :after #'malb/dired-subtree-all-the-icons))
  :bind (:map dired-mode-map
              ("TAB" . dired-subtree-toggle)
              ("<backtab>" . dired-subtree-cycle)))
#+end_src

[[https://github.com/Fuco1/dired-hacks/blob/master/dired-ranger.el][dired-ranger]] for easy copy’n’pasting.

#+begin_src emacs-lisp
(use-package dired-ranger
  :after dired
  :bind (:map dired-mode-map
              ("C-w" . (lambda (arg)
                         (interactive "P")
                         (dired-ranger-copy arg)
                         (bind-key "C-y" #'dired-ranger-move dired-mode-map)))
              ("M-w" . (lambda (arg)
                         (interactive "P")
                         (dired-ranger-copy arg)
                         (bind-key "C-y" #'dired-ranger-paste dired-mode-map)))))
#+end_src

[[https://github.com/yqrashawn/fd-dired][fd-dired]] run =fd= to produce dired buffers.

#+begin_src emacs-lisp
(use-package fd-dired
  :ensure-system-package (fdfind . fd-find)
  :config  (setq fd-dired-program "fdfind"
                 fd-dired-ls-option '("| xargs -0 ls -Nld" . "-Nld")))
#+end_src

[[https://github.com/jtbm37/all-the-icons-dired][all-the-icons-dired]] for eye candy.

#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :defer t
  :after all-the-icons
  :init (add-hook 'dired-mode-hook  #'all-the-icons-dired-mode)
  ;; https://github.com/jtbm37/all-the-icons-dired/pull/31/files
  :config (malb/defadvice! malb/all-the-icons-dired--put-icon (pos)
            "Propertize POS with icon."
            :override #'all-the-icons-dired--put-icon
            (let* ((file (dired-get-filename 'relative 'noerror))
                   (icon (all-the-icons-dired--icon file))
                   (image (get-text-property 0 'display icon)))
              (if (or (not (eq (car image) 'image)) (member file '("." "..")))
                  (put-text-property (1- pos) pos 'display
                                     (if (member file '("." ".."))
                                         "\t"
                                       (concat " " icon "\t")))
                (setf (image-property image :margin)
                      (cons (/ (window-text-width nil t) (window-text-width)) 0))
                (put-text-property (1- pos) pos 'display image)))))
#+end_src

[[https://github.com/asok/peep-dired][peep-dired]] for previewing files.

#+begin_src emacs-lisp
(use-package peep-dired
  :defer t
  :config (setq peep-dired-cleanup-eagerly nil
                peep-dired-cleanup-on-disable t
                peep-dired-enable-on-directories t)
  :bind (:map dired-mode-map
              ("P" . peep-dired)))
#+end_src

** Directory Trees (Dired Sidebar)

[[https://raw.githubusercontent.com/jojojames/dired-sidebar/master/screenshots/vscode.png]]

[[https://github.com/jojojames/dired-sidebar/][dired-sidebar]]

#+begin_src emacs-lisp
(use-package dired-sidebar
  :commands (dired-sidebar-toggle-sidebar)
  :init (progn (add-hook 'dired-sidebar-mode-hook
                         (defun malb/auto-revert-local ()
                           (unless (file-remote-p default-directory)
                             (auto-revert-mode)))))
  :config (progn (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
                 (push 'rotate-windows dired-sidebar-toggle-hidden-commands)
                 (setq dired-sidebar-theme 'icons
                       dired-sidebar-should-follow-file t
                       dired-sidebar-use-term-integration t
                       dired-sidebar-width malb/left-side-window-width
                       dired-sidebar-display-alist '((side . left)
                                                     (slot . -1)
                                                     (window-parameters
                                                      (no-other-window . t)
                                                      (no-delete-other-windows . t))))
                 ;; (defun malb/dired-sidebar-drop-icons (orig-fun &rest args)
                 ;;   (if (member 'all-the-icons-dired-mode dired-mode-hook)
                 ;;       (progn
                 ;;         (remove-hook 'dired-mode-hook 'all-the-icons-dired-mode)
                 ;;         (let ((r (apply orig-fun args)))
                 ;;           (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
                 ;;           r))
                 ;;     (apply orig-fun args)))
                 ;; (advice-add #'dired-sidebar-get-or-create-buffer :around #'malb/dired-sidebar-drop-icons)
                 ))
#+end_src

** Tramp

=.ssh/config= already contains the appropriate config for persistent sessions so we ask tramp to respect it.

#+begin_src emacs-lisp
(use-package tramp
  :ensure nil
  :config (progn
            (setq tramp-use-ssh-controlmaster-options nil
                  remote-file-name-inhibit-locks t
                  tramp-verbose 1
                  vc-ignore-dir-regexp (format "%s\\|%s"
                                               vc-ignore-dir-regexp
                                               tramp-file-name-regexp))))
#+end_src

[[https://github.com/masasam/emacs-helm-tramp/blob/master/image/helm-tramp.gif]]

#+begin_src emacs-lisp
(use-package helm-tramp
  :after (helm tramp)
  :config (progn
            (add-to-list 'helm-commands-using-frame 'helm-tramp)

            (malb/defadvice! malb/switch-tab-by-remote (orig-function path)
              "Remote hosts get their own tab."
              :around 'helm-tramp-open
              :around 'helm-tramp-open-shell
              (let ((tab-created nil)
                    (tab-name (concat "@" (tramp-file-name-host (tramp-dissect-file-name path)))))
                (if (member tab-name (mapcar (lambda (tab) (cdr (assq 'name tab)))
                                             (tab-bar-tabs)))
                    (tab-bar-switch-to-tab tab-name)
                  (progn
                    (tab-new)
                    (setq tab-created t)
                    (tab-rename tab-name)))

                (apply orig-function (list path))

                (when tab-created
                  (delete-other-windows))))


            (defun helm-tramp-open-vterm (path)
              "Open Vterm on remote"
              (let ((server-name (tramp-file-name-host (tramp-dissect-file-name path))))
                (funcall (malb/make-toggle-shell
                          (format "*mosh:%s*" server-name)
                          `(progn
                             (let ((vterm-shell (format "mosh %s -- tmux a" ,server-name)))
                               (vterm (format "*mosh:%s*" server-name))))))))

            (setq helm-tramp--source
                  (helm-build-sync-source "Tramp"
                    :candidates #'helm-tramp--candidates
                    :volatile t
                    :action (helm-make-actions
                             "Tramp" #'helm-tramp-open
                             "Term"  #'helm-tramp-open-vterm
                             "Shell" #'helm-tramp-open-shell)))))
#+end_src

* Diff

#+begin_src emacs-lisp
(use-package ediff
  :config (progn
            (setq ediff-window-setup-function 'ediff-setup-windows-plain
                  ediff-split-window-function 'split-window-horizontally
                  ediff-diff-options "-w")
            (setq-default ediff-auto-refine 'on
                          ediff-highlighting-style 'face
                          ediff-highlight-all-diffs t)
            (add-hook 'ediff-after-quit-hook-internal 'winner-undo)

            (malb/defadvice! malb/ignore-window-parameters (orig-function &rest args)
              :around #'ediff-regions-wordwise
              (let ((ignore-window-parameters t))
                (apply orig-function args)))))
#+end_src

#+begin_src emacs-lisp
(setq diff-switches "-u")
#+end_src

** Smerge

#+begin_src emacs-lisp
(use-package smerge-mode
  :config
  (defhydra unpackaged/smerge-hydra
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("RET" smerge-keep-current)
    ("\C-m" smerge-keep-current)
    ("<" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    (">" smerge-diff-base-lower)
    ("R" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("k" smerge-kill-current)
    ("ZZ" (lambda ()
            (interactive)
            (save-buffer)
            (bury-buffer))
     "Save and bury buffer" :color blue)
    ("q" nil "cancel" :color blue))
  :hook (magit-diff-visit-file . (lambda ()
                                   (when smerge-mode
                                     (unpackaged/smerge-hydra/body)))))
#+end_src

** PDF Diff

#+begin_src emacs-lisp
(defun malb/diff-pdf (arg)
  "Run pdftotext on two PDFs and open ediff buffer on texts.

Uses baloo to find files."
  (interactive "P")
  (let*  ((baloofn (helm-build-async-source "Baloo"
                     :candidates-process #'helm-baloo-search
                     :candidate-transformer '(helm-baloo-transform helm-skip-boring-files)
                     :keymap helm-generic-files-map
                     :help-message #'helm-generic-file-help-message))

          (left (if arg
                    (read-file-name "Original: ")
                  (helm :sources baloofn :prompt "Original: ")))
          (right (if arg
                     (read-file-name "New: ")
                   (helm :sources baloofn :prompt "New: ")))
          (left-tmp (make-temp-name "/tmp/left"))
          (right-tmp (make-temp-name "/tmp/right")))

    (shell-command (format "pdftotext -layout -nopgbrk \"%s\" \"%s\"" left left-tmp) nil)
    (shell-command (format "pdftotext -layout -nopgbrk \"%s\" \"%s\"" right right-tmp) nil)
    (ediff-files left-tmp right-tmp)))
#+end_src

* Diagrams
** [[http://plantuml.com/][PlantUML]]

#+begin_src emacs-lisp
(use-package plantuml-mode
  :commands (plantuml-mode)
  :init (progn
          (setq plantuml-jar-path "/usr/share/plantuml/plantuml.jar"
                plantuml-default-exec-mode 'jar)))
#+end_src

*Example*

#+begin_src plantuml :file plantuml-example.svg :tangle no
skinparam monochrome true
skinparam dpi 150
skinparam backgroundColor transparent
skinparam classBackgroundColor transparent
skinparam style strictuml
skinparam handwritten true

title Example Sequence Diagram
activate Client
Client -> Server: Session Initiation
note right: Client requests new session
activate Server
Client <-- Server: Authorization Request
note left: Server requires authentication
Client -> Server: Authorization Response
note right: Client provides authentication
Server --> Client: Session Token
note left: Session established
deactivate Server
Client -> Client: Saves token
deactivate Client
#+end_src

#+RESULTS:
[[file:plantuml-example.svg]]

Note that PlantUML supports [[http://plantuml.com/latex.html][TikZ export]].

* Calendar

[[https://github.com/kiwanami/emacs-calfw][calfw]] for displaying calendars, because why not.

#+begin_src emacs-lisp
(use-package calfw
  :commands (malb/calendar cfw:open-calendar-buffer)
  :bind (:map cfw:calendar-mode-map ("q" . kill-this-buffer))
  :config (progn
            (setq calendar-week-start-day 1)
            (use-package calfw-cal :ensure t)
            (use-package calfw-ical :ensure t)
            (use-package calfw-org :ensure t)

            ;; Those "" make everything kaputt
            (defun malb/cfw:ical-url-to-buffer (orig-fun &rest args)
              (let ((buf (apply orig-fun args)))
                (with-current-buffer buf
                  (while (search-forward "" nil t)
                    (replace-match "" nil t)))
                buf))
            (setq cfw:org-agenda-schedule-args '(:timestamp :scheduled))
            (advice-add 'cfw:ical-url-to-buffer :around #'malb/cfw:ical-url-to-buffer)))
#+end_src

* File Sharing
** Transfer.sh

[[https://github.com/Brillow/transfer-sh.el][transfer.sh]] for interfacing with https://transfer.sh.

#+begin_src emacs-lisp
(use-package transfer-sh)
#+end_src

** Pastebin/ix.io

Interfacing with http://ix.io/, run =ix=.

#+begin_src emacs-lisp
(use-package ix)
#+end_src

** Gists

To list [[https://github.com/defunkt/gist.el][gists]], run ~gist-list~:

- =g= - reload the gist list from server
- =e= - edit current gist description
- =k= - delete current gist
- =+= - add a file to the current gist
- =–= - remove a file from the current gist

- =C-x C-s= - save a new version of the gist
- =C-x C-w= - rename some file

From a dired buffer, you can: =@= - make a gist out of marked files (with a prefix, make it private)

~gist-region-or-buffer~ - Post either the current region, or if mark is not set, the current buffer as a new paste at https://gist.github.com . Copies the URL into the kill ring. With a prefix argument, makes a private paste.

#+begin_src emacs-lisp
(use-package gist
  :commands (gist-list gist-buffer malb/update-gist)
  :config (progn

            (defcustom gist-id
              :safe 'stringp)

            (defun malb/update-gist ()
              "Push to gist-id given as local variable `gist-id'."
              (interactive)
              (let ((bf-string (buffer-string)))
                (save-window-excursion (gist-fetch gist-id)
                                       (erase-buffer)
                                       (insert bf-string)
                                       (gist-mode-edit-buffer))))

            (setq gist-ask-for-description t)))
#+end_src

** Copy as

Copy source code marked up in various ways.

#+begin_src emacs-lisp
(use-package copy-as-format
  :commands (copy-as-format-github
             copy-as-format-jira
             copy-as-format-markdown
             copy-as-format-org-mode
             copy-as-format-slack))
#+end_src

* Manage Local Services (Prodigy)

[[https://github.com/rejeep/prodigy.el][Prodigy]] is a way of managing services from Emacs. Use it for IMAP idle via [[https://www.npmjs.com/package/imapnotify][imapnotify]]. For completeness here’s a matching imapnotify config.

#+begin_src js :tangle no
var child_process = require('child_process');

function getStdout(cmd) {
  var stdout = child_process.execSync(cmd);
  return stdout.toString().trim();
}

exports.host = "imap.gmail.com";
exports.port = 993;
exports.tls = true;
exports.tlsOptions = { servername: "imap.gmail.com" };
exports.username = "martinralbrecht@gmail.com";
exports.password = // whatever needs doing
exports.onNewMail = "mbsync googlemail-default";
exports.onNewMailPost = "emacsclient  -e '(mu4e-update-index)'";
exports.boxes = [ "INBOX"];
#+end_src

#+begin_src emacs-lisp
(use-package prodigy
  :hook ((prodigy-view-mode . toggle-truncate-lines))
  :init (progn
          (prodigy-define-tag
            :name 'email
            :ready-message "Checking E-mail using IMAP IDLE. Ctrl-C to shutdown.")

          (prodigy-define-service
            :name "imapnotify-gmail"
            :command "imapnotify"
            :args (list "-c" (expand-file-name ".config/imapnotify.gmail.js" (getenv "HOME")))
            :tags '(email)
            :kill-signal 'sigkill)

          (prodigy-define-service
            :name "imapnotify-kcl"
            :command "goimapnotify"
            :args (list "-conf" (expand-file-name ".config/imapnotify.kcl.json" (getenv "HOME")))
            :tags '(email)
            :kill-signal 'sigkill)

          (prodigy-define-service
            :name "malb.io"
            :cwd (expand-file-name "web/malb.io" malb/projects-dir)
            :command "jekyll"
            :args '("serve" "-P" "4001")
            :port 4001
            :tags '(web))

          (malb/register-wide-popup-window (rx (seq bos "*prodigy-" (zero-or-more nonl) "*" eos)))

          ;; start some services
          (when (and (daemonp) (not malb/startup-quick))
            (prodigy-start-service (prodigy-find-service "imapnotify-gmail"))
            (prodigy-start-service (prodigy-find-service "imapnotify-kcl")))))
#+end_src

* Media Players
** EMMS

#+begin_src emacs-lisp
(use-package emms-setup
  :ensure emms)

(use-package emms-player-mplayer
  :ensure nil
  :after emms-setup
  :config (progn (emms-standard)
                 (emms-default-players)))
#+end_src


** Kodi

#+begin_src emacs-lisp
(use-package kodi
  :ensure nil
  :commands malb/ambient/body
  :after all-the-icons
  :ensure-system-package (brightnessctl . brightnessctl)
  :config (progn
            ;;  adjust brightenss of external monitor
            ;; this isn't kodi related but fits with the hydra below
            (defvar malb/external-brightness-delta 10)

            (defun malb/external-brightness-device ()
              (with-temp-buffer
                (call-process "brightnessctl" nil t nil "-l" "-m")
                (goto-char (point-min))
                (re-search-forward "^\\(ddcci[0-9]+\\),backlight" nil :noerror)
                (match-string 1)))

            (defun malb/external-brightness ()
              (let ((device (malb/external-brightness-device)))
                (with-temp-buffer
                  (call-process "brightnessctl" nil t nil "-d" device "g")
                  (string-to-number (string-trim (buffer-substring-no-properties (point-min) (point-max)))))))

            (defun malb/external-brightness-up ()
              (interactive)
              (let ((device (malb/external-brightness-device)))
                (let* ((brightness-old (malb/external-brightness))
                       (brightness-new (min (+ brightness-old malb/external-brightness-delta) 100)))
                  (call-process "brightnessctl" nil nil nil "-d" device "s" (format "%d" brightness-new))
                  (message "brightness %d" (malb/external-brightness)))))

            (defun malb/external-brightness-down ()
              (interactive)
              (let ((device (malb/external-brightness-device)))
                (let* ((brightness-old (malb/external-brightness))
                       (brightness-new (max (- brightness-old malb/external-brightness-delta) 0)))
                  (call-process "brightnessctl" nil nil nil "-d" device "s" (format "%d" brightness-new))
                  (message "brightness %d" (malb/external-brightness)))))

            (defhydra malb/ambient nil
              "ambient"
              ("<up>" kodi-volume-up (concat
                                      (all-the-icons-faicon "music" :face 'all-the-icons :v-adjust 0.01)
                                      " "
                                      (all-the-icons-faicon "volume-up" :face 'all-the-icons :v-adjust 0.01)))
              ("<down>" kodi-volume-down (concat
                                          (all-the-icons-faicon "music" :face 'all-the-icons :v-adjust 0.01)
                                          " "
                                          (all-the-icons-faicon "volume-down" :face 'all-the-icons :v-adjust 0.01)))
              ("<left>" kodi-prev (concat
                                   (all-the-icons-faicon "music" :face 'all-the-icons :v-adjust 0.01)
                                   " "
                                   (all-the-icons-faicon "backward" :face 'all-the-icons :v-adjust 0.01))
               :color blue)
              ("<right>" kodi-next (concat
                                    (all-the-icons-faicon "music" :face 'all-the-icons :v-adjust 0.01)
                                    " "
                                    (all-the-icons-faicon "forward" :face 'all-the-icons :v-adjust 0.01))
               :color blue)
              ("<RET>" kodi-now-playing (concat
                                         (all-the-icons-faicon "music" :face 'all-the-icons :v-adjust 0.01)
                                         " "
                                         (all-the-icons-faicon "info" :face 'all-the-icons :v-adjust 0.01))
               :color blue)
              ("SPC" kodi-play-pause (concat
                                      (all-the-icons-faicon "music" :face 'all-the-icons :v-adjust 0.01)
                                      " "
                                      (all-the-icons-faicon "play" :face 'all-the-icons :v-adjust 0.01))
               :color blue)
              ("'" malb/external-brightness-up (concat
                                                (all-the-icons-faicon "desktop" :face 'all-the-icons :v-adjust 0.01)
                                                " "
                                                (all-the-icons-faicon "sun-o" :face 'all-the-icons :v-adjust 0.01)))
              (";" malb/external-brightness-down (concat
                                                  (all-the-icons-faicon "desktop" :face 'all-the-icons :v-adjust 0.01)
                                                  " "
                                                  (all-the-icons-faicon "moon-o" :face 'all-the-icons :v-adjust 0.01)))
              ("q" nil))

            (advice-add #'malb/ambient/body :around  #'malb/switch-away-from-special-advice)))
#+end_src

* Browsing

([[https://github.com/baron42bba/.emacs.d/blob/master/bba.org#browser-switch][source]])

#+begin_src emacs-lisp
(defun malb/switch-default-browser ()
  "switch between default browser and eww"
  (interactive)
  (if (string-equal "browse-url-default-browser" browse-url-browser-function)
      (setq browse-url-browser-function 'eww-browse-url)
    (setq browse-url-browser-function 'browse-url-default-browser))
  (message "%s" browse-url-browser-function))
#+end_src

Set Firefox directly because using =xdg-open= can lead to weird redirect on load.

#+begin_src emacs-lisp
(setq browse-url-browser-function 'browse-url-firefox)
#+end_src

** Pocket

#+begin_quote
This is a client for Pocket (getpocket.com). It allows you to manage your reading list: add, remove, delete, tag, view, favorite, etc. Doing so in Emacs with the keyboard is fast and efficient. Links can be opened in Emacs with any function, or in external browsers, and specific sites/URLs can be opened with specific browser functions. Views can be sorted by date, title, domain, tags, favorite, etc, and “limited” mutt-style. Items can be searched for using keywords, tags, favorite status, unread/archived status, etc. Items can optionally be colorized by site, making it easy to tell which items come from different sites. Items are grouped depending on the sort column.
#+end_quote

#+begin_src emacs-lisp
(use-package pocket-reader
  :config (progn
            (setq pocket-reader-archive-on-open nil
                  pocket-reader-color-title nil
                  pocket-reader-color-site t)))
#+end_src

* Chat
** Tracking

#+begin_src emacs-lisp
(use-package tracking
  :bind (
         ("<f2> <right>" . tracking-next-buffer)
         ("<f2> <left>" . tracking-previous-buffer))
  :config (progn
            (unbind-key "C-c C-SPC" tracking-mode-map)
            (unbind-key "C-c C-@" tracking-mode-map)))
#+end_src

** COMMENT Weechat

Run [[https://weechat.org/][weechat]] for chatting through [[https://github.com/the-kenny/weechat.el][weechat.el]] to get [[https://matrix.org/docs/projects/client/weechat-matrix/][matrix]], [[https://github.com/wee-slack/wee-slack][slack]] and [[https://github.com/mbologna/docker-bitlbee][skype]].

#+begin_src emacs-lisp
(use-package weechat
  :commands (weechat-connect malb/weechat weechat-switch-buffer)
  :bind (:map weechat-mode-map
              ("M-<up>" .  weechat-previous-input)
              ("C-<up>" .  weechat-previous-input)
              ("M-<down>" . weechat-next-input)
              ("C-<down>" . weechat-next-input))
  :after prodigy
  :config (progn
            (require 'weechat-notifications)
            (require 'weechat-tracking)
            (require 'weechat-latex)
            (require 'weechat-spelling)
            (require 'weechat-image)

            (setq weechat-completing-read-function #'completing-read
                  weechat-auto-monitor-buffers nil
                  weechat-auto-close-buffers t
                  weechat-max-nick-length 32
                  weechat-notification-mode t
                  weechat-notification-types '(:highlight :message :disconnect :query)
                  weechat-tracking-types     '(:highlight :message :query)
                  weechat-buffer-kill-buffers-on-disconnect t)

            (defun weechat-tracking-handle-query ()
              (when (weechat-tracking-show-buffer? :query (current-buffer))
                (tracking-add-buffer (current-buffer))))

            (add-hook 'weechat-buffer-background-message-hook  'weechat-tracking-handle-query)

            (add-hook 'weechat-mode-hook #'turn-on-visual-line-mode)
            (add-hook 'weechat-mode-hook #'visual-fill-column-mode)

            (defun malb/weechat ()
              (interactive)
              (weechat-connect "localhost" 9000 nil 'plain)
              (run-at-time 10 nil #'weechat-monitor-all-buffers))

            ;; run it on startup
            ;; (when (daemonp)
            ;;   (run-at-time  60 nil #'weechat-connect "localhost" 9000 nil 'plain)
            ;;   (run-at-time 180 nil #'weechat-monitor-all-buffers))
            ))
#+end_src

*** Notes

#+begin_src sh
/set matrix.print_unconfirmed_messages = off # https://github.com/the-kenny/weechat.el/issues/89
/set matrix.human_buffer_names = on
#+end_src

* X11 Integration

#+begin_src emacs-lisp
(setq select-enable-clipboard t                  ; use clipboard for copy and paste
      save-interprogram-paste-before-kill t      ; keep a copy of clipboard stuff around
      mouse-yank-at-point t
      mouse-drag-copy-region t
      select-enable-primary t
      x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

Use GTK printing interface.

#+begin_src emacs-lisp
(setq lpr-command "gtklp")
#+end_src

* Autosave & Backups

Put autosave files (ie =#foo#=) in one place, not scattered across the file system.

#+begin_src emacs-lisp
(defvar malb/autosave-dir
  (expand-file-name "autosaves" user-emacs-directory))

(make-directory malb/autosave-dir t)

(defun auto-save-file-name-p (filename)
  (string-match "^#.*#$" (file-name-nondirectory filename)))

(defun make-auto-save-file-name ()
  (concat malb/autosave-dir
          (if buffer-file-name
              (concat "#" (file-name-nondirectory buffer-file-name) "#")
            (expand-file-name
             (concat "#%" (buffer-name) "#")))))
#+end_src

Put backup files (ie =foo~=) in one place too. The ~backup-directory-alist~ list contains regexp → directory mappings. Filenames matching a regexp are backed up in the corresponding directory. Emacs will mkdir it if necessary.

#+begin_src emacs-lisp
(defvar backup-dir (expand-file-name "autosaves" user-emacs-directory))
(setq backup-directory-alist (list (cons "." backup-dir)))
#+end_src

* UTF-8 Everywhere

#+begin_src emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)

(setq current-language-environment "UTF-8")
(setq default-input-method "rfc1345")

(prefer-coding-system 'utf-8)
#+end_src

Use [[https://gitlab.com/matsievskiysv/insert-char-preview][insert-char-preview]] for handling unicode character insertion.

#+begin_src emacs-lisp
(use-package insert-char-preview
    :commands insert-char-preview
    :bind ("C-x 8 RET" . insert-char-preview))
#+end_src

* Large Files

A file is large if it is 32MB in my world.

#+begin_src emacs-lisp
(setq large-file-warning-threshold 33554432)
#+end_src

[[https://github.com/m00natic/vlfi][vlf]] for large files.

#+begin_src emacs-lisp
(use-package vlf-setup
  :ensure vlf)
#+end_src

* Scratch

We don’t want the *scratch* buffer to be killed ever.

#+begin_src emacs-lisp
(use-package unkillable-scratch
  :config (progn
            (unkillable-scratch 1)))
#+end_src

Get a [[https://github.com/ieure/scratch-el][scratch]] for every mode quickly

#+begin_src emacs-lisp
(use-package scratch)
#+end_src

Make scratch buffer an org-mode buffer.

#+begin_src emacs-lisp
(setq initial-major-mode 'org-mode
      initial-scratch-message "\
This buffer is for notes you don't want to save, and for Lisp evaluation.
If you want to create a file, visit that file with C-x C-f,
then enter the text in that file's own buffer.

,#+begin_src emacs-lisp

,#+end_src

,#+begin_src python

,#+end_src

")
#+end_src

* Emacs from Elsewhere

[[https://github.com/alpha22jp/atomic-chrome][atomic-chrome]]

#+begin_src emacs-lisp
(use-package atomic-chrome
  :config (progn
            (setq atomic-chrome-buffer-open-style 'frame
                  atomic-chrome-default-major-mode 'markdown-mode
                  atomic-chrome-buffer-frame-width 160
                  atomic-chrome-buffer-frame-height 25)

            (atomic-chrome-start-server)))
#+end_src

[[https://github.com/xuchunyang/grab-x-link][Grab the link]] in the current browser tab

#+begin_src emacs-lisp
(use-package grab-x-link
  :bind (("C-c i l" . grab-x-link-firefox-insert-link)
         ("C-c i o" . grab-x-link-firefox-insert-org-link)
         ("C-c i m" . grab-x-link-firefox-insert-markdown-link))
  :config (progn
            (malb/defadvice! malb/grab-x-link-firefox ()
              :override #'grab-x-link-firefox
              (let ((emacs-window
                     (grab-x-link--shell-command-to-string
                      "xdotool getactivewindow"))
                    (firefox-window
                     (or (car (split-string (grab-x-link--shell-command-to-string
                                             "xdotool search --classname Navigator")
                                            "\n"))
                         (error "Can't detect Firfox Window -- is it running?"))))
                (shell-command (format "xdotool windowactivate --sync %s key ctrl+l ctrl+c" firefox-window))
                (shell-command (format "xdotool windowactivate %s" emacs-window))
                (sit-for 0.2)
                (let ((url (substring-no-properties (grab-x-link--get-clipboard)))
                      (title (grab-x-link--title-strip
                              (grab-x-link--shell-command-to-string
                               (concat "xdotool getwindowname " firefox-window))
                              " — Mozilla Firefox"))) ;; malb: changed
                  (cons url title))))))
#+end_src

** Org-protocol entpoints for bookmarklets

Load a URL in EWW

~javascript:location.href='org-protocol://eww?url='+encodeURIComponent(location.href)~

#+begin_src emacs-lisp
(defun malb/start-eww-for-url (plist)
  "Raise Emacs and call eww with the url in PLIST."
  (raise-frame)
  (eww (plist-get plist :url))
  nil)

(add-to-list 'org-protocol-protocol-alist
             '("eww"
               :protocol "eww"
               :function malb/start-eww-for-url))
#+end_src

Load URL as org-mode file

~javascript:location.href='org-protocol://read-url-as-org?url='+encodeURIComponent(location.href)~

#+begin_src emacs-lisp
(defun malb/read-url-as-org (plist)
  "Raise Emacs and readl url in PLIST as org-mode buffer."
  (raise-frame)
  (org-web-tools-read-url-as-org (plist-get plist :url))
  nil)

(add-to-list 'org-protocol-protocol-alist
             '("read-url-as-org"
               :protocol "read-url-as-org"
               :function malb/read-url-as-org))

#+end_src

Store URL as org link

~javascript:location.href='org-protocol://org-store-link?url='+encodeURIComponent(location.href)~

#+begin_src emacs-lisp
(defun malb/org-store-link-for-url (plist)
  "Raise Emacs and store url in PLIST as org-link."
  (raise-frame)
  (org-web-tools-insert-link-for-url (plist-get plist :url))
  nil)

(add-to-list 'org-protocol-protocol-alist
             '("org-store-link"
               :protocol "org-store-link"
               :function malb/org-store-link-for-url))
#+end_src

* SSH Servers

Create convenience functions to open a shell on my servers and “cd” into them in eshell.

#+begin_src emacs-lisp
(dolist (server-name malb/server-names)
  (fset (intern (format "mosh/%s" server-name))
        (malb/make-toggle-shell
         (format "*mosh:%s*" server-name)
         `(progn
            (let ((vterm-shell (format "mosh %s -- tmux a" ,server-name)))
              (vterm (format "*mosh:%s*" server-name))))))

  (fset (intern (format "eshell/%s" server-name))
        `(lambda ()
           (insert ,(format "cd /ssh:%s:" server-name))
           (eshell-send-input))))

(malb/register-popup-window (rx "*mosh:" (one-or-more any) "*") t)
#+end_src

* ISearch

#+begin_quote
In Emacs 25, Isearch can find a wide range of Unicode characters (like á, ⓐ, or 𝒶) when you search
for ASCII characters (a in this example). To enable this feature, set the variable
=search-default-mode= to =char-fold-to-regexp=. ([[http://endlessparentheses.com/new-in-emacs-25-1-easily-search-non-ascii-characters.html][source]])
#+end_quote

Also https://zck.org/improved-emacs-search

#+begin_src emacs-lisp
(setq search-default-mode 'char-fold-to-regexp
      replace-char-fold t
      isearch-lazy-count t
      lazy-count-prefix-format nil
      lazy-count-suffix-format "   (%s/%s)")
#+end_src

* Timezones

#+begin_src emacs-lisp
(use-package tzc
  :config (setq tzc-favourite-time-zones '("Europe/London")))
#+end_src

* Messages Mode

#+begin_src emacs-lisp
(use-package simple
  :ensure nil
  :bind (:map messages-buffer-mode-map
              ("/" . isearch-backward)))
#+end_src

* Proced (Top)

([[https://laurencewarne.github.io/emacs/programming/2022/12/26/exploring-proced.html][source]])

#+begin_src emacs-lisp
(use-package proced
  :ensure nil
  :commands proced
  :config (progn
            (setq-default proced-auto-update-flag t)
            (setq proced-auto-update-interval 1
                  proced-goal-attribute nil
                  proced-enable-color-flag t
                  proced-show-remote-processes t)
            (add-to-list
             'proced-format-alist
             '(custom user pid ppid sess tree pcpu pmem rss start time state (args comm)))
            (setq-default proced-format 'custom)))
#+end_src

* Misc
** Settings

Characterise files with the same name by their path.

#+begin_src emacs-lisp
(use-package uniquify
  :ensure nil
  :config (setq uniquify-buffer-name-style 'forward))
#+end_src

I hate tabs …

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

but if they happen to be there (I’m looking at you Go)

#+begin_src emacs-lisp
(setq-default tab-width 4)
#+end_src

Pressing =y= or =n= is sufficient.

#+begin_src emacs-lisp
(setopt use-short-answers t)
#+end_src

Kill whole line not just content on =C-k=.

#+begin_src emacs-lisp
(setq kill-whole-line t)
#+end_src

In emacs minibuffer prompt, when you press the left arrow key, the cursor will move back all the way
over the prompt text. This is annoying because user often will hold down ~Alt+b~ to move back by
word to edit, and when user starts to type something, emacs will say ’This is read-only’. Then you
have to manually move cursor out of the prompt. You can try it now by calling query-replace or
shell-command. Here's how to set the cursor not going into prompt. ([[http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html][source]])

#+begin_src emacs-lisp
(setq minibuffer-prompt-properties
      (quote
       (read-only
        t
        point-entered minibuffer-avoid-prompt
        face minibuffer-prompt)))
#+end_src

Smoother scrolling.

#+begin_src emacs-lisp
(setq scroll-conservatively 10000
      scroll-preserve-screen-position t
      fast-but-imprecise-scrolling t
      auto-window-vscroll nil)
#+end_src

Smoother mouse scrolling.

#+begin_src emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)) ; one line at a time
      mouse-wheel-progressive-speed nil            ; don't accelerate scrolling
      mouse-wheel-follow-mouse 't)                 ; scroll window under mouse
#+end_src

Use ~kill -pUSR1~ to kill Emacs. ([[https://github.com/wasamasa/dotemacs/blob/master/init.org][source]])

#+begin_src emacs-lisp
(defun malb/quit-emacs-unconditionally ()
  (interactive)
  (save-some-buffers t t)
  (kill-emacs))

(define-key special-event-map (kbd "<sigusr1>") #'malb/quit-emacs-unconditionally)
#+end_src

Show key combos

#+begin_src emacs-lisp
(setq echo-keystrokes 0.1)
#+end_src

Diminish ~eldoc-mode~

#+begin_src emacs-lisp
(blackout 'eldoc-mode)
#+end_src

When saving a file that starts with =#!=, make it executable.

#+begin_src emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+end_src

=C-u C-SPC C-SCP= pops the mark twice

#+begin_src emacs-lisp
(setq set-mark-command-repeat-pop t)
#+end_src

Skip over duplicates ([[http://endlessparentheses.com/faster-pop-to-mark-command.html][source]]):

#+begin_src emacs-lisp
(defun malb/multi-pop-to-mark (orig-fun &rest args)
  "Call ORIG-FUN until the cursor moves.
Try the repeated popping up to 10 times. ARGS is passed through."
  (let ((p (point)))
    (dotimes (i 10)
      (when (= p (point))
        (apply orig-fun args)))))

(advice-add 'pop-to-mark-command :around #'malb/multi-pop-to-mark)
#+end_src

Diminish =abbrev-mode=

#+begin_src emacs-lisp
(blackout 'abbrev-mode)
#+end_src

Don’t error when killing read-only text.

#+begin_src emacs-lisp
(setq kill-read-only-ok t)
#+end_src

#+begin_src emacs-lisp
(add-hook 'profiler-report-mode-hook #'hl-line-mode)
#+end_src

Allow pixel-wise scaling

#+begin_src emacs-lisp
(setq frame-resize-pixelwise t)
#+end_src

Don’t yank syntax highlighting etc.

#+begin_src emacs-lisp
(add-to-list 'yank-excluded-properties 'font)
(add-to-list 'yank-excluded-properties 'font-lock-face)
#+end_src

Increase resolution for Excel files etc.

#+begin_src emacs-lisp
(setq doc-view-resolution 300)
#+end_src

Open man pages with focus set

#+begin_src emacs-lisp
(setq Man-notify-method 'aggressive)
#+end_src

Use =xdg-open= by default.

#+begin_src emacs-lisp
(setq mailcap-user-mime-data '(((viewer . "xdg-open %s") (type . ".*/.*"))))
#+end_src

Make long lines kinda work ([[https://200ok.ch/posts/2020-09-29_comprehensive_guide_on_handling_long_lines_in_emacs.html][source]])

#+begin_src emacs-lisp
(setq bidi-paragraph-direction 'left-to-right)
(when (version<= "27.1" emacs-version)
  (setq bidi-inhibit-bpa t)
  (global-so-long-mode 1))
#+end_src

Don’t prompt to save passwords.

#+begin_src emacs-lisp
(setq auth-source-save-behavior nil)
#+end_src

Use ~(copyright-update)~ to update copyright info

#+begin_src emacs-lisp
(setq copyright-names-regexp "Martin Albrecht\\|Martin R. Albrecht")
#+end_src

** Async

#+begin_src emacs-lisp
(use-package async
  :custom (async-prompt-for-password nil "Otherwise: Stack overflow in regexp matcher"))
#+end_src

** Functions

Add a function for renaming the file being edited ([[https://github.com/bodil/ohai-emacs][source]])

#+begin_src emacs-lisp
(defun malb/rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))
#+end_src

Copy filename to clipboard

#+begin_src emacs-lisp
(defun malb/kill-buffer-file-name ()
  "Show current buffer's filename in the echo area and add it to the kill ring."
  (interactive)
  (let ((buffer-file-name (buffer-file-name)))
    (if (null buffer-file-name)
        (message "Buffer %s is not associated with a file." (buffer-name))
      (message "%s" (kill-new buffer-file-name)))))

(defun malb/kill-buffer-file-basename ()
  "Show the buffers base name in the echo area and add it to the kill ring."
  (interactive)
  (let ((bufer-file-name (buffer-file-name)))
    (if (not (null buffer-file-name))
        (message "%s" (kill-new (file-name-nondirectory buffer-file-name)))
      (error "Buffer %s is not associated with a file" (buffer-name)))))
#+end_src

#+begin_src emacs-lisp
(defun malb/delete-file-and-buffer ()
  "Kill the current buffer and deletes the file it is visiting."
  (interactive)
  (let ((filename (buffer-file-name)))
    (when filename
      (delete-file filename)
      (message "Deleted file %s" filename)
      (kill-buffer))))
#+end_src

Edit files as root ([[http://emacsredux.com/blog/2013/04/21/edit-files-as-root/][source]])

#+begin_src emacs-lisp
(defun malb/sudo-edit (&optional arg)
  "Edit currently visited file as root.

With a prefix ARG prompt for a file to visit.
Will also prompt for a file to visit if current
buffer is not visiting a file."
  (interactive "P")
  (if (or arg (not buffer-file-name))
      (find-file (concat "/sudo:root@localhost:"
                         (ido-read-file-name "Find file(as root): ")))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
#+end_src

Run a command in a named compile buffer ([[https://ivanmalison.github.io/dotfiles/#namedcompile][source]])

#+begin_src emacs-lisp
(defun malb/named-compile (command)
  (interactive
   (list
    (let ((command (eval compile-command)))
      (if (or compilation-read-command current-prefix-arg)
          (compilation-read-command command)
        command))))
  (compilation-start command nil (lambda (&rest args)
                                   (format "*compilation %s*" command))))
#+end_src

Generate new random URLs for some commonly used online services.

#+begin_src emacs-lisp
(defun malb/new-hedgedoc-url ()
  (interactive)

  (let ((url (shell-command-to-string
              "curl -Ls -o /dev/null -w %{url_effective} https://md.kif.rocks/new")))
    (when (called-interactively-p 'any)
      (kill-new url)
      (insert url))
    url))
#+end_src

#+begin_src emacs-lisp
(defun malb/new-jitsi-url (&optional prefix)
  (interactive)
  (let ((url (concat "https://meet.jit.si/"
                     prefix
                     (replace-regexp-in-string "\n" ""
                                               (shell-command-to-string "diceware -n 4")))))
    (when (called-interactively-p 'any)
      (kill-new url)
      (insert url))
    url))
#+end_src

4 + 3

#+begin_src emacs-lisp
(defun malb/calc-eval-region (beg end)
  "Calculate the region and display the result in the echo area.
If i is pressed after, insert the result at the end of region. If r is pressed replace the text with the result"
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (list (save-excursion (thing-at-point--beginning-of-sexp)
                           (point))
           (save-excursion (thing-at-point--beginning-of-sexp)
                           (thing-at-point--end-of-sexp)
                           (point)))))
  (let* ((expr (buffer-substring-no-properties beg end))
         (result (calc-eval expr))
         (my-beg beg)
         (my-end end) map)
    (message "%s = %s" expr result)
    (when (not (listp result))
      (setq map (make-sparse-keymap))
      (define-key map "i" (lambda () (interactive)
                            (goto-char my-end)
                            (insert " = " result)))
      (define-key map "r" (lambda () (interactive)
                            (kill-region my-beg my-end)
                            (goto-char my-beg)
                            (insert result)))
      (set-transient-map map))))
#+end_src

** Clickable URLs

Make links in comments and string clickable

#+begin_src emacs-lisp
(use-package goto-addr
  :hook ((compilation-mode . goto-address-mode)
         (prog-mode . goto-address-prog-mode)
         (markdown-mode . goto-address-mode)
         (eshell-mode . goto-address-mode)
         (shell-mode . goto-address-mode))

  :bind (:map goto-address-highlight-keymap
              ("C-c C-o" . goto-address-at-point)
              ("<RET>" . newline))

  :commands (goto-address-prog-mode goto-address-mode))
#+end_src

** Encryption

Transparent encryption and decryption.

#+begin_src emacs-lisp
(use-package epa-file
  :ensure nil
  :config (progn
            (setq epa-armor t)
            (epa-file-enable)))
#+end_src

** Memory Usage

#+begin_src emacs-lisp
(use-package memory-usage)
#+end_src


** Gnuplot

#+begin_src emacs-lisp
(use-package gnuplot)
#+end_src

*Example*

#+plot: title:"Weight" ind:1 deps:(2) type:2d with:linespo set:"xdata time" set:"yrange [90:]"
| Date             |   Kg |
|------------------+------|
| <2010-02-21 Sun> | 95.0 |
| <2010-02-22 Mon> | 93.0 |
| <2010-02-23 Tue> | 92.0 |
| <2010-02-24 Wed> | 91.5 |
| <2010-02-25 Thu> | 91.0 |
| <2010-02-26 Fri> | 92.0 |

** Alert

#+begin_src emacs-lisp
(use-package alert
  :config (setq alert-default-style 'libnotify))
#+end_src

** Upcase, Downcase, Capitalise

#+begin_src emacs-lisp
(bind-key "M-l" #'downcase-dwim)
(bind-key "M-c" #'capitalize-dwim)
(bind-key "M-u" #'upcase-dwim)
#+end_src

** unset SESSION_MANAGER

#+begin_src emacs-lisp
(setenv "SESSION_MANAGER" nil)
#+end_src

* LLM

#+begin_src emacs-lisp
(use-package ellama
  :config (progn
            (require 'llm-ollama)

            (defun malb/ellama-static-name (_provider _action _prompt)
              "Generate name for ellama session by current time."
              "ellama-session")

            (setopt ellama-language "German"
                    ellama-provider (apply #'make-llm-ollama malb/ollama-default)
                    ellama-long-lines-length 1000000
                    ellama-fill-paragraphs nil
                    ellama-enable-keymap nil
                    ellama-naming-scheme #'malb/ellama-static-name)

            (malb/defadvice! malb/make-llm-ollama-parameters (old-function &rest args)
              "Pass in parameters."
              :around 'make-llm-ollama
              (apply old-function
                     (append args
                             `(:default-chat-non-standard-params
                               ,(cdr (assoc (plist-get args :chat-model) malb/ollama-parameters))))))

            (defun malb/translate-llm (&optional change)
              "Translate selected region or sentence at point and replace."
              (interactive "P")
              (let* ((beg (if (not (use-region-p))
                              (save-excursion (backward-paragraph) (+ (point) 1))
                            (region-beginning)))
                     (end (if (not (use-region-p))
                              (save-excursion (forward-paragraph) (- (point) 1))
                            (region-end)))
                     (filter (lambda (text) (concat
                                             (string-trim
                                              (replace-regexp-in-string
                                               (rx bol "Sure, here is the translated text in" (one-or-more any) ":" eol)
                                               "" text))
                                             "\n")))
                     (text (buffer-substring-no-properties beg end))
                     (from-language (with-temp-buffer
                                      (insert text)
                                      (nth 2 (assq
                                              (guess-language-buffer)
                                              guess-language-langcodes))))
                     (to-language (if (s-equals-p from-language ellama-language)
                                      "British English"
                                    ellama-language))
                     (task (format (concat "Translate the following text to %s. "
                                           "Output only the text and nothing else, do not chat, no preamble:\n%s")
                                   to-language text))
                     (ollama-service (prodigy-find-service "ollama"))
                     (ellama-provider (apply #'make-llm-ollama malb/ollama-translate-default)))

                (when (not (prodigy-service-started-p ollama-service))
                  (prodigy-start-service ollama-service)
                  (sit-for 2))

                (if change
                    (progn
                      (progn
                        (kill-region beg end)
                        (ellama-stream task :point beg :filter filter)))
                  (ellama-instant task))))

            (defmacro malb/llm-do-task (cmd task &rest args)
              `(defun ,(intern (concat "malb/" cmd "-llm")) (arg)
                 ,(plist-get args :docstring)
                 (interactive "P")

                 (let* ((beg (cond ((use-region-p) (region-beginning))
                                   ((eq ,(plist-get args :scope) 'paragraph)
                                    (save-excursion (backward-paragraph) (+ (point) 1)))
                                   ((eq ,(plist-get args :scope) 'section)
                                    (cond ((eq major-mode 'org-mode)
                                           (save-restriction (org-narrow-to-subtree) (point-min)))
                                          ((eq major-mode 'markdown-mode)
                                           (save-restriction (markdown-narrow-to-subtree) (point-min)))
                                          (t (save-excursion (backward-paragraph) (+ (point) 1)))))
                                   (t (point-min))))
                        (end (cond ((use-region-p) (region-end))
                                   ((eq ,(plist-get args :scope) 'paragraph)
                                    (save-excursion (forward-paragraph) (- (point) 1)))
                                   ((eq ,(plist-get args :scope) 'section)
                                    (cond ((eq major-mode 'org-mode)
                                           (save-restriction (org-narrow-to-subtree) (point-max)))
                                          ((eq major-mode 'markdown-mode)
                                           (save-restriction (markdown-narrow-to-subtree) (point-max)))
                                          (t (save-excursion (forward-paragraph) (- (point) 1)))))
                                   (t (point-max))))
                        (filter (lambda (txt) (string-trim txt)))
                        (ollama-service (prodigy-find-service "ollama")))

                   ;; NOTE: hack to exclude my signatures in e-mail
                   (when (and (eq major-mode #'mu4e-compose-mode)
                              (eq end (point-max)))
                     (setq end (save-excursion (message-goto-signature) (point))))

                   (setq task (templatel-render-string
                               (apply 'concat (mapcar (lambda (str) (concat str "\n")) ,task))
                               (list (cons "context" (if ,(plist-get args :format)
                                                         (malb/pandoc-convert
                                                          (prin1-to-string ,(plist-get args :format))
                                                          (current-buffer) beg end)
                                                       (buffer-substring-no-properties beg end))))))

                   (when (not (prodigy-service-started-p ollama-service))
                     (prodigy-start-service ollama-service)
                     (sit-for 2))

                   (when arg
                     (setq ellama-provider (ellama-get-ollama-local-model))
                     (setq ellama--current-session-id nil))

                   (cond ((and (equal ,(plist-get args :mode) 'insert) (not buffer-read-only))
                          (progn
                            (ellama-stream task :point (point) :filter filter)))
                         ((and (equal ,(plist-get args :mode) 'change) (not buffer-read-only))
                          (progn
                            (kill-region beg end)
                            (ellama-stream task :point beg :filter filter)))
                         ((and (equal ,(plist-get args :mode) 'append) (not buffer-read-only))
                          (progn
                            (goto-char end)
                            (insert "\n\n-----\n\n")
                            (sit-for 1)
                            (ellama-stream task :point (+ end 9) :filter filter)))
                         (t
                          (ellama-instant task))))))

            (require 'llm-prompts)
            (bind-key "C-c w t l" #'malb/translate-llm)
            (malb/register-right-side-window (rx bos "ellama-session") t)))
#+end_src

#+begin_src emacs-lisp
(use-package shell-maker
  :after ellama
  :custom ((shell-maker-prompt-before-killing-buffer . nil))
  :config (progn

            (defconst ollama-shell-api-url "http://localhost:11434/api/generate")

            (defvar ollama-shell-streaming t)

            (defun ollama-base64-images-maybe (shell-prompt)
              "Check if image paths are present in PROMPT and return list of images if true."
              (let (images)
                (with-temp-buffer
                  (insert shell-prompt)
                  (goto-char 0)
                  (while (re-search-forward
                          (rx (seq "/" (1+ (not whitespace)) "/" (1+ (not whitespace)) (or ".png" ".jpg" ".jpeg")))
                          nil t)
                    (let ((filename (match-string 0)))
                      (if (file-exists-p filename)
                          (add-to-list 'images (with-temp-buffer
                                                 (insert-file-contents filename)
                                                 (base64-encode-string (buffer-string) t))
                                       t)
                        (message "ollama: file not found: %s" filename)))))
                images))

            (defun ollama-shell-make-payload (shell-prompt model)
              "Create elisp object encoding PROMPT and MODEL."
              (let* ((ollama-buffer (current-buffer))
                     (images (if (s-starts-with-p "llava" model)
                                 (ollama-base64-images-maybe shell-prompt)
                               nil)))
                (when images (message "ollama: added %d pictures" (length images)))
                `(
                  :model ,model
                  :prompt ,shell-prompt
                  :images ,images
                  :context ,ollama-shell-context
                  :options ,(cdr (assoc model malb/ollama-parameters))
                  :stream ,(if ollama-shell-streaming t json-false))))

            (defun ollama-shell-callback-curl (blob)

              (let ((json (cond
                           ((eq (type-of blob) 'cons) blob)
                           (t (ignore-errors (shell-maker--json-parse-string blob)))))
                    (response ""))
                (when (assoc 'response json)
                  (setq response (cdr (assoc 'response json))))
                (when (assoc 'context json)
                  ;; (message "updating context")
                  (setq-local ollama-shell-context (cdr (assoc 'context json))))
                response))

            (defun ollama-shell-call-api-curl (object)
              (let ((json (json-encode object))
                    (json-path (make-temp-file "ollama-shell-request" nil ".json")))
                (with-temp-file json-path (insert json))
                (append (list "curl" ollama-shell-api-url) `("--data" ,(format "@%s" json-path)))))

            (defun ollama-shell-callback-elisp (status ollama-buffer shell-maker-callback)
              (goto-char url-http-end-of-headers)
              (let* ((response (split-string
                                (decode-coding-string
                                 (buffer-substring-no-properties (point) (point-max))
                                 'utf-8)
                                "\n"))
                     fragments
                     context)

                (dolist (part response)
                  (when (not (string-empty-p part))
                    (let ((parsed (json-read-from-string part)))
                      (push (cdr (assoc 'response parsed)) fragments)
                      (setq context (cdr (assoc 'context parsed))))))

                (with-current-buffer ollama-buffer
                  (setq ollama-shell-context context)
                  (funcall shell-maker-callback
                           (mapconcat #'identity (nreverse fragments) "")
                           nil))))

            (defun ollama-shell-call-api-elisp (shell-prompt model shell-maker-callback)
              (let* ((ollama-buffer (current-buffer))
                     (url-request-method "POST")
                     (url-request-extra-headers '(("Content-Type" . "application/json")))
                     (url-request-data (encode-coding-string
                                        (json-encode (ollama-shell-make-payload shell-prompt model))
                                        'utf-8)))
                (url-retrieve ollama-shell-api-url
                              #'ollama-shell-callback-elisp
                              `(,ollama-buffer ,shell-maker-callback)
                              t t)))

            (defun ollama-shell (&optional arg)
              "Start an ollama shell."
              (interactive "P")

              (let ((ollama-service (prodigy-find-service "ollama")))
                (when (not (prodigy-service-started-p ollama-service))
                  (prodigy-start-service ollama-service)
                  (sit-for 2)))

              (when arg
                (setq ellama-provider (ellama-get-ollama-local-model))
                (setq ellama--current-session-id nil))

              (let ((initial-prompt
                     (if (use-region-p)
                         (buffer-substring-no-properties (region-beginning) (region-end))
                       nil)))

                (shell-maker-start
                 (make-shell-maker-config
                  :name "ollama"
                  :prompt (format "ollama(%s)> "
                                  (car (s-split ":" (cl-struct-slot-value 'llm-ollama
                                                                          'chat-model
                                                                          ellama-provider))))
                  :execute-command
                  (lambda (command _history callback error-callback)
                    (let ((model (cl-struct-slot-value 'llm-ollama 'chat-model ellama-provider)))
                      (shell-maker-async-shell-command
                       (ollama-shell-call-api-curl (ollama-shell-make-payload command model))
                       ollama-shell-streaming
                       #'ollama-shell-callback-curl
                       callback
                       error-callback)))
                  ;; (lambda (command _history callback error-callback)
                  ;;   (let ((model (cl-struct-slot-value 'llm-ollama 'chat-model ellama-provider)))
                  ;;     (ollama-shell-call-api-elisp command model callback)))
                  ))

                (setq-local ollama-shell-context nil)
                (when initial-prompt
                  (insert initial-prompt))))

            (defun ollama-shell-context-length (&optional print-message)
              (interactive "p")
              (let ((len (length ollama-shell-context)))
                (when print-message (message "ollama-context length %d" len))
                len))

            (defun ollama-shell-reset-context (&optional print-message)
              (interactive "p")
              (when print-message (message "ollama-context reset."))
              (setq-local ollama-shell-context nil))

            (malb/register-right-side-window (rx bos "*ollama*" eos) t)))
#+end_src

* File Types
** CMake Files

#+begin_src emacs-lisp
(use-package cmake-mode)
#+end_src

** PCAP Files

Wireshark et al. outputs ([[https://github.com/orgcandman/pcap-mode][source]])

#+begin_src emacs-lisp
(use-package pcap-mode)
#+end_src

** ELF Files

List symbols in =.so= and =.a= files ([[https://github.com/abo-abo/elf-mode][source]])

#+begin_src emacs-lisp
(use-package elf-mode
  :mode (("\\.so$"  . elf-mode)
         ("\\.a$"   . elf-mode)))
#+end_src

** Log Files

Using [[https://github.com/doublep/logview][logview]] mode.

#+begin_src emacs-lisp
(use-package logview
  :commands (logview-mode)
  :config (setq logview-auto-revert-mode 'auto-revert-tail-mode))
#+end_src

** JSON

#+begin_src emacs-lisp
(use-package json-mode)
#+end_src

** YaML Files

#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src

** CSV

#+begin_src emacs-lisp
(use-package csv-mode
  :hook (csv-mode . hl-line-mode)
  :hook (csv-mode . toggle-truncate-lines)
  :hook (csv-mode . (lambda ()  (call-interactively #'csv-align-fields))))
#+end_src

** Docker Filers

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode ("Dockerfile\\." . dockerfile-mode))
#+end_src

** ePub

[[https://github.com/wasamasa/nov.el][Nov.el]] is surprisingly useful.

#+begin_src emacs-lisp
(use-package nov
  :mode ("\\.epub$" . nov-mode)
  :bind (:map nov-mode-map
              ("<end>" . forward-paragraph)
              ("<home>" . backward-paragraph)
              ("B" . nov-history-back)
              ("F" . nov-history-forward))
  :hook ((nov-mode turn-on-visual-fill-column-mode)
         (nov-mode turn-on-visual-line-mode))
  :custom ((nov-variable-pitch nil "Don't use variable pitch font")
           (nov-text-width t))
  :config (progn
            ;; https://codereview.stackexchange.com/questions/282497/nov-el-function-to-search-the-entire-epub-ebook
            (defun nov-search (pattern)
              (interactive "sEnter search pattern: ")
              (let ((version nov-epub-version)
                    (index 1)
                    results)
                (while (< index (1- (length nov-documents)))
                  (seq-let (id &rest path) (aref nov-documents index)
                    (let (;; HACK: this should be looked up in the manifest
                          (imagep (seq-find (lambda (item) (string-match-p (car item) path))
                                            image-type-file-name-regexps))
                          ;; NOTE: allows resolving image references correctly
                          (default-directory (file-name-directory path)))
                      (unless imagep
                        (with-temp-buffer
                          (if (and (version< version "3.0") (eq id nov-toc-id))
                              (insert (nov-ncx-to-html path))
                            (insert (nov-slurp path)))
                          (goto-char (point-min))
                          (when (search-forward pattern nil t)
                            (nov-render-html)
                            (goto-char (point-min))
                            (while (search-forward pattern nil t)
                              (push (list (format "%d %s" index
                                                  (replace-regexp-in-string "\n" " "
                                                                            (thing-at-point 'line)))
                                          index (point))
                                    results)))))
                      (setq index (1+ index)))))
                (seq-let (index point) (alist-get (completing-read "Jump to: " (reverse results)) results
                                                  nil nil #'string=)
                  (nov-goto-document index)
                  (goto-char point))))))
#+end_src

** MailRC

#+begin_src emacs-lisp
(use-package conf-mode
  :ensure nil
  :mode (("\\.mailrc$" . conf-mode)))
#+end_src

** HotCRP Reviews

#+begin_src emacs-lisp
(use-package hotcrp-mode
  :ensure nil
  :mode (("-reviews\\.txt$" . hotcrp-mode))
  :hook ((hotcrp-mode . visual-fill-column-mode)
         (hotcrp-mode . adaptive-wrap-prefix-mode)
         (hotcrp-mode . flyspell-mode))
  :config (progn
            (defun malb/be-american ()
              (ispell-change-dictionary "american"))
            ;; Her Majesty's English de-anonymises me
            (add-hook 'hotcrp-mode-hook #'malb/be-american)))
#+end_src

** CryptoVerif

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.cv[l]?$"  . cryptoverif-mode))
(add-to-list 'auto-mode-alist '("\\.ocv[l]?$" . cryptoverifo-mode))
(autoload 'cryptoverif-mode  "cryptoverif" "Major mode for editing CryptoVerif code." t)
(autoload 'cryptoverifo-mode "cryptoverif" "Major mode for editing CryptoVerif code." t)
#+end_src

* Theme & Look

** Frame Title

Display buffer name in frame titles ([[https://github.com/wasamasa/dotemacs/blob/master/init.org#display-buffer-name-in-frame-titles][source]])

#+begin_src emacs-lisp
(setq frame-title-format
      '("" (:eval (replace-regexp-in-string "^ +" "" (buffer-name)))
        " - " invocation-name))
#+end_src

** Stripe Buffer                                                                                                :patch:

[[https://github.com/sabof/stripe-buffer/raw/master/screenshot.png]] ([[https://github.com/sabof/stripe-buffer/raw/master/screenshot.png][source]])

[[https://github.com/sabof/stripe-buffer][Stripe Buffer]] makes it vastly easier to read tables and dired buffers. We apply this [[https://github.com/sabof/stripe-buffer/pull/14][patch]] for performance.

#+begin_src diff
@@ -141,7 +141,7 @@ Used by `stripe-table-mode' Only the first matching group will be painted."
                  (push overlay sb/overlays)))))
          ( goto-start-pos
            (lambda ()
-             (let (( start-offset (mod (1- (line-number-at-pos)) interval)))
+             (let (( start-offset (mod (1- (string-to-number (format-mode-line "%l"))) interval)))
                (if (< start-offset stripe-height) ; in first part
                    (progn
                      (forward-line (- stripe-height start-offset))
#+end_src

#+begin_src emacs-lisp
(use-package stripe-buffer
  :config (progn

            (malb/defadvice! malb/org-ctrl-c-ctrl-c-no-stripe-table-mode (old-function &rest args)
              :around #'org-ctrl-c-ctrl-c
              (let ((is-on stripe-table-mode))
                (stripe-table-mode -1)
                (apply old-function args)
                (stripe-table-mode (if is-on 1 0))))

            (add-hook 'dired-mode-hook #'turn-on-stripe-buffer-mode)))
#+end_src

** Modeline

([[https://github.com/seagle0128/doom-modeline][source]])

[[https://user-images.githubusercontent.com/140797/49694189-6913d480-fbc0-11e8-93ae-9578455dcd2c.png]]

#+begin_src emacs-lisp
(use-package doom-modeline
  :after all-the-icons
  :config (progn
            (require 'doom-modeline-segments)
            (doom-modeline-def-segment conda-env
              "The current conda environment.  Works with `conda'."
              (when (bound-and-true-p conda-env-current-name)
                (propertize (format " |%s|" conda-env-current-name)
                            ;; 'face (doom-modeline-face)
                            'help-echo (format "Conda environment: %s"
                                               conda-env-current-name))))
            (setq doom-modeline-icon t
                  doom-modeline-major-mode-icon t
                  doom-modeline-major-mode-color-icon t
                  doom-modeline-buffer-file-name-style 'truncate-upto-project
                  doom-modeline-buffer-state-icon t
                  doom-modeline-github nil
                  doom-modeline-buffer-encoding nil
                  doom-modeline-minor-modes nil)

            (doom-modeline-def-modeline 'main
              '(eldoc
                bar
                workspace-name
                window-number
                modals
                matches
                follow
                buffer-info
                remote-host
                buffer-position
                word-count
                parrot
                selection-info
                conda-env)
              '(compilation
                objed-state
                misc-info
                grip
                github
                debug
                repl
                lsp
                minor-modes
                input-method
                indent-info
                buffer-encoding
                major-mode
                process
                vcs
                check
                time))

            (doom-modeline-def-modeline 'pdf
              '(bar workspace-name window-number modals matches buffer-info pdf-pages)
              '(compilation misc-info major-mode process vcs time))


            (doom-modeline-def-modeline 'project
              '(bar workspace-name window-number modals buffer-default-directory remote-host buffer-position)
              '(compilation misc-info github debug minor-modes input-method major-mode process time))

            (if (bound-and-true-p imenu-list-mode-line-format)
                (setq imenu-list-mode-line-format
                      '((:eval
                         (doom-modeline-segment--bar))
                        (:propertize "%b" face mode-line-buffer-id)
                        " "
                        (:eval (buffer-name imenu-list--displayed-buffer))
                        " "
                        (:eval
                         (doom-modeline-segment--matches))))) )
  :custom (doom-modeline-project-detection 'projectile))
#+end_src

** Theme

Use both [[https://github.com/bbatsov/solarized-emacs][solarized]] and [[https://github.com/bbatsov/zenburn-emacs][zenburn]]. But use a solarized patched to be less yellow by changing

| color     | original  | malb      |
| ~s-base2~ | ~#eee8d5~ | ~#eeedea~ |
| ~s-base3~ | ~#fdf6e3~ | ~#fdfcf9~ |

#+RESULTS:

The result looks like this:

[[./screenshot.png]]


#+begin_src emacs-lisp
(use-package solarized
  :ensure solarized-theme
  :config (progn
            (setq solarized-use-variable-pitch nil
                  solarized-high-contrast-mode-line nil
                  solarized-height-minus-1 1.0
                  solarized-height-plus-1  1.0
                  solarized-height-plus-2  1.0
                  solarized-height-plus-3  1.0
                  solarized-height-plus-4  1.0
                  solarized-use-less-bold nil
                  solarized-emphasize-indicators t
                  solarized-scale-org-headlines nil
                  solarized-scale-outline-headlines nil
                  x-underline-at-descent-line t)))
#+end_src

*** High Contrast/Bright

#+begin_src emacs-lisp
(use-package one-themes
  :disabled)
#+end_src

*** Switch between Light and Dark Theme

#+begin_src emacs-lisp
(defun malb/toggle-light-dark ()
  "Switch between light and dark theme"
  (interactive)
  (if (custom-theme-enabled-p 'solarized-light-malb)
      (progn
        (disable-theme 'solarized-light-malb)
        (load-theme 'solarized-zenburn-malb)
        (add-hook 'pdf-view-mode-hook #'pdf-view-midnight-minor-mode))
    (progn
      (disable-theme 'solarized-zenburn-malb)
      (load-theme 'solarized-light-malb)
      (remove-hook 'pdf-view-mode-hook #'pdf-view-midnight-minor-mode)))
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (cond ((eq major-mode 'org-mode)
             ;; nicked from org-ctrl-c-ctrl-c
             (let ((org-inhibit-startup-visibility-stuff t)
	               (org-startup-align-all-tables nil))
	           (when (boundp 'org-table-coordinate-overlays)
	             (mapc #'delete-overlay org-table-coordinate-overlays)
	             (setq org-table-coordinate-overlays nil))
	           (org-save-outline-visibility 'use-markers (org-mode-restart)))))
      (cond ((eq major-mode 'org-agenda-mode)
             (org-agenda-redo-all)))
      (cond ((eq major-mode 'pdf-view-mode)
             (if (custom-theme-enabled-p 'solarized-light-malb)
                 (pdf-view-midnight-minor-mode -1)
               (pdf-view-midnight-minor-mode 1))
             )))))
#+end_src

*** Load Theme

#+begin_src emacs-lisp
(defvar malb/theme-loaded nil)

(defun malb/load-theme (frame)
  (when (not malb/theme-loaded)
    (select-frame frame)
    (load-theme 'solarized-light-malb)
    ;; (eval-after-load "unicode-fonts"
    ;;   '(unicode-fonts-setup))
    (doom-modeline-mode t)
    (setq malb/theme-loaded t)))

(if (daemonp)
    (add-hook 'after-make-frame-functions #'malb/load-theme)
  (malb/load-theme (selected-frame)))
#+end_src

** Fonts

[[https://raw.githubusercontent.com/domtronn/all-the-icons.el/master/logo.png]]

([[https://github.com/domtronn/all-the-icons.el][source]])

#+begin_src emacs-lisp
(use-package all-the-icons
  :init (setq all-the-icons-color-icons nil)
  :config
  (set-fontset-font t 'unicode (font-spec :family "Weather Icons") nil)
  (set-fontset-font t 'unicode (font-spec :family "all-the-icons") nil 'append)
  (set-fontset-font t 'unicode (font-spec :family "file-icons") nil 'append)
  (set-fontset-font t 'unicode (font-spec :family "Material Icons") nil 'append)
  (set-fontset-font t 'unicode (font-spec :family "github-octicons") nil 'append)
  (set-fontset-font t 'unicode (font-spec :family "FontAwesome") nil 'append))
#+end_src

Better unicode font support.

#+begin_src emacs-lisp
;; (use-package unicode-fonts)
#+end_src

- [[https://fonts.google.com/specimen/Cousine][Cousine]] is wide font which means glyphs rendered in different fonts (when Cousine doesn’t have the matching glyph) are too high. Thus, we scale those other fonts down when Cousine is the default face.
- We use [[https://www.google.com/get/noto/][Noto Sans Mono]] in condensed form which means some other glyphs can be too wide.

Note that =face-font-rescale-alist= is frame specific, thus the hook.

#+begin_src emacs-lisp
(defun malb/fonts (frame)
  (set-face-font 'default malb/font)
  (set-face-font 'fixed-pitch malb/font)
  (with-selected-frame frame
    (setq face-font-rescale-alist nil)
    (when (string-match "Cousine" (alist-get 'font default-frame-alist))
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "DejaVu Sans Mono") 0.9) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "FontAwesome") 0.85) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Material Icons") 0.7) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "all-the-icons") 0.95) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "github-octicons") 0.85) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Symbola") 0.9) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "file-icons") 0.75) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Asana Math") 0.7) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Noto Sans Symbols") 0.7) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Noto Sans Mono CJK SC") 0.7) t))

    (when (string-match "Noto Sans Mono" (alist-get 'font default-frame-alist))

      (set-fontset-font "fontset-default" #x22c5 "DejaVu Sans Mono") ;; otherwise ⋅ is too narrow

      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "FontAwesome") 0.8) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "all-the-icons") 0.85) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "file-icons") 0.7) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "github-octicons") 0.75) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Noto Sans Mono CJK SC") 0.95) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Noto Serif CJK TC") 0.85) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Symbola") 0.9) t)
      ;; (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Material Icons") 0.75) t)
      )
    (when (string-match "Iosevka Term" (alist-get 'font default-frame-alist))

      ;; (set-fontset-font "fontset-default" #x22c5 "DejaVu Sans Mono")
      ;; otherwise ⋅ is too narrow

      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "FontAwesome") 0.8) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Material Icons") 0.8) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "all-the-icons") 0.85) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "file-icons") 0.8) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "github-octicons") 0.8) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Noto Sans Mono CJK SC") 0.95) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Noto Serif CJK TC") 0.85) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Noto Sans Symbols") 0.7) t)
      (add-to-list 'face-font-rescale-alist (cons (font-spec :family "Symbola") 0.85) t)
      )))

(add-hook 'after-make-frame-functions #'malb/fonts)
(malb/fonts (selected-frame)) ;; initial frame
#+end_src

** SHR (EWW et al)

#+begin_quote
[[https://github.com/chenyanming/shrface/][shrface]] is a shr faces package that helps you apply your favourite org faces to shr, dash-docs, eww, nov.el, mu4e, and more!
#+end_quote

#+begin_src emacs-lisp
(use-package shr
  :ensure nil
  :config (setq shr-use-fonts nil
                shr-use-colors nil))
#+end_src

#+begin_src emacs-lisp
(use-package shrface
  :after shr
  :config (progn
            (shrface-basic)
            (shrface-trial)
            (setq shrface-paragraph-indentation 0
                  shrface-href-versatile t)

            (with-eval-after-load 'nov
              ;; reset nov-shr-rendering-functions, in case of the list get bigger and bigger
              (setq nov-shr-rendering-functions '((img . nov-render-img)
                                                  (title . nov-render-title)))
              (setq nov-shr-rendering-functions (append nov-shr-rendering-functions
                                                        shr-external-rendering-functions))
              (add-hook 'nov-mode-hook #'shrface-mode))))
#+end_src

#+begin_src emacs-lisp
(use-package eww
  :ensure nil
  :after shrface
  :bind (:map eww-mode-map
              ("TAB" .  org-cycle)
              ("<backtab>" . org-shifttab))
  :config (progn
            (add-hook 'eww-mode-hook #'turn-on-visual-fill-column-mode)
            (add-hook 'eww-after-render-hook 'shrface-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package shr-tag-pre-highlight
  :after shr
  :config (progn
            (add-to-list 'shr-external-rendering-functions '(pre . shr-tag-pre-highlight))

            (defun shrface-shr-tag-pre-highlight (pre)
              "Highlighting code in PRE."
              (let* ((shr-folding-mode 'none)
                     (shr-current-font 'default)
                     (code (with-temp-buffer
                             (shr-generic pre)
                             (setq-local fill-column 120)
                             (indent-rigidly (point-min) (point-max) 2)
                             (if (eq "" (dom-texts pre))
                                 nil
                               (progn
                                 (setq-local fill-column shrface-paragraph-fill-column)
                                 (indent-rigidly (point-min) (point-max) shrface-paragraph-indentation)))
                             (buffer-string)))
                     (lang (or (shr-tag-pre-highlight-guess-language-attr pre)
                               (let ((sym (language-detection-string code)))
                                 (and sym (symbol-name sym)))))
                     (mode (and lang
                                (shr-tag-pre-highlight--get-lang-mode lang))))
                (shr-ensure-newline)
                (insert (make-string shrface-paragraph-indentation ?\ )) ; make indent string
                (insert (propertize (concat "#+begin_src " lang) 'face 'org-block-begin-line))
                (shr-ensure-newline)
                (insert
                 (or (and (fboundp mode)
                          (with-demoted-errors "Error while fontifying: %S"
                            (shr-tag-pre-highlight-fontify code mode)))
                     code))
                (shr-ensure-newline)
                (insert (make-string shrface-paragraph-indentation ?\ )) ; make indent string
                (insert (propertize "#+end_src" 'face 'org-block-end-line ) )
                (shr-ensure-newline)))))
#+end_src

Set higher contrast.

#+begin_src emacs-lisp
(setq shr-color-visible-luminance-min 80)
#+end_src

([[https://github.com/alphapapa/unpackaged.el/blob/3b46f9c0e0195d78df8c4ca6e1953b69539e2844/unpackaged.el][source]])

#+begin_src emacs-lisp
(defun malb/imenu-eww-headings ()
  "Return alist of HTML headings in current EWW buffer for Imenu.
Suitable for `imenu-create-index-function'."
  (let ((faces '(shr-h1 shr-h2 shr-h3 shr-h4 shr-h5 shr-h6 shr-heading)))
    (save-excursion
      (save-restriction
        (widen)
        (goto-char (point-min))
        (cl-loop for next-pos = (next-single-property-change (point) 'face)
                 while next-pos
                 do (goto-char next-pos)
                 for face = (get-text-property (point) 'face)
                 when (cl-typecase face
                        (list (cl-intersection face faces))
                        (symbol (member face faces)))
                 collect (cons (buffer-substring (point-at-bol) (point-at-eol)) (point))
                 and do (forward-line 1))))))

(add-hook 'eww-mode-hook (lambda () (setq-local imenu-create-index-function #'malb/imenu-eww-headings)))
#+end_src

** Rainbow Mode

Colourise colours or names in buffers ([[http://git.savannah.gnu.org/cgit/emacs/elpa.git/tree/packages/rainbow-mode][source]])

#+begin_src emacs-lisp
(use-package rainbow-mode
  :custom ((rainbow-x-colors nil "don't colorise the word 'red' etc."))
  :config (progn (add-hook 'emacs-lisp-mode-hook #'rainbow-mode))
  :blackout rainbow-mode)
#+end_src

** Vim-like Empty Line Indicator

([[https://www.reddit.com/r/emacs/comments/2kdztw/emacs_in_evil_mode_show_tildes_for_blank_lines/][source]])

#+begin_src emacs-lisp
(define-fringe-bitmap 'tilde [0 0 0 113 219 142 0 0] nil nil 'center)
(setcdr (assq 'empty-line fringe-indicator-alist) 'tilde)
(set-fringe-bitmap-face 'tilde 'font-lock-comment-face)
(setq-default indicate-empty-lines t)
#+end_src

** Text Size

Easily change the text size:

#+begin_src emacs-lisp
(defun malb/global-text-scale-increase ()
  "Globally increase font size."
  (interactive)
  (set-face-attribute 'default nil :height (+ (face-attribute 'default :height) 5)))

(defun malb/global-text-scale-decrease ()
  "Globally decrease font size."
  (interactive)
  (set-face-attribute 'default nil :height (- (face-attribute 'default :height) 5)))

(bind-key "C-=" #'text-scale-increase)
(bind-key "C--" #'text-scale-decrease)
(bind-key "C-M-=" #'malb/global-text-scale-increase)
(bind-key "C-M--" #'malb/global-text-scale-decrease)
(bind-key "C-<mouse-4>" #'text-scale-increase)
(bind-key "C-<mouse-5>" #'text-scale-decrease)
(bind-key "C-M-<mouse-4>" #'malb/global-text-scale-increase)
(bind-key "C-M-<mouse-5>" #'malb/global-text-scale-decrease)
#+end_src

** Bell

#+begin_src emacs-lisp :tangle no
(setq visible-bell t)
#+end_src

** Dim other Buffers

#+begin_src emacs-lisp
(use-package dimmer
  :commands dimmer-mode
  :config (progn
            (dimmer-configure-which-key)
            (dimmer-configure-helm)
            (dimmer-configure-posframe)
            (dimmer-configure-company-box)
            (setq dimmer-percent 0.25)))
#+end_src

** Hide Mode Line

#+begin_src emacs-lisp
(use-package hide-mode-line)
#+end_src

* Key Bindings

#+begin_src emacs-lisp
(malb/set-menu-key "<f2>" #'malb/hydra-window/body)
(malb/set-menu-key "A" #'malb/imenu-anywhere)
(malb/set-menu-key "a" #'piper-region)
(malb/set-menu-key "B" #'malb/helm-mu-contacts)
(malb/set-menu-key "b" #'helm-bookmarks)
(malb/set-menu-key "C" #'malb/calc-eval-region)
(malb/set-menu-key "c" #'mu4e-compose-new)
(malb/set-menu-key "e" #'malb/toggle-eshell)
(malb/set-menu-key "i" #'malb/helm-in-buffer)
(malb/set-menu-key "j" #'avy-goto-char-timer)
(malb/set-menu-key "k" #'helm-baloo)
(malb/set-menu-key "l" #'helm-bibtex-with-local-bibliography)
(malb/set-menu-key "L" #'pix2tex-screenshot)
(malb/set-menu-key "K" #'org-download-screenshot)
(malb/set-menu-key "m" #'mu4e)
(malb/set-menu-key "M" #'malb/helm-mu)
(malb/set-menu-key "/" #'malb/helm-ag-projects)
(malb/set-menu-key "o" #'malb/helm-org-ql-agenda-files)
(malb/set-menu-key "p" #'prodigy)
(malb/set-menu-key "P" #'malb/toggle-latexmk)
(malb/set-menu-key "Q" #'malb/toggle-llm-chat)
(malb/set-menu-key "q" #'ollama-shell)
(malb/set-menu-key "S" #'malb/toggle-sage-jupyter)
(malb/set-menu-key "s" #'malb/switch-tab)
(malb/set-menu-key "t" #'helm-tramp)
(malb/set-menu-key "r" #'spray-mode)
(malb/set-menu-key "z" #'malb/toggle-vterm)
(malb/set-menu-key "Z" #'malb/ykcd)
(malb/set-menu-key "<f3>" #'malb/ambient/body)
(malb/set-menu-key "<f4>" #'emms-previous)
(malb/set-menu-key "<f5>" #'emms-pause)
(malb/set-menu-key "<f6>" #'emms-next)
(malb/set-menu-key "<up>" #'drag-stuff-up)
(malb/set-menu-key "<down>" #'drag-stuff-down)
(malb/set-menu-key "#" #'jupyter-org-hydra/body)
#+end_src

Remap join-line to ~M-j~ where it's easier to get to. ~join-line~ will join the line you're on with the line above it in a reasonable manner for the type of file you're editing.

#+begin_src emacs-lisp
(bind-key "M-j" #'join-line)
#+end_src

=C-z= only annoys me, use =C-x C-z= when you need it

#+begin_src emacs-lisp
(bind-key "C-z" nil)
#+end_src

I never use ~list-directory~, I only mistype it.

#+begin_src emacs-lisp
(unbind-key "C-x C-d")
#+end_src

I hardly use it but my fat fingers hit it on some keyboards.

#+begin_src emacs-lisp
(unbind-key "<insert>")
#+end_src

** Toggle Map

([[http://endlessparentheses.com/the-toggle-map-and-wizardry.html][source]])

#+begin_src emacs-lisp
(define-prefix-command 'malb/toggle-map)
(define-key ctl-x-map "t" 'malb/toggle-map)

(bind-key "e" #'toggle-debug-on-error        malb/toggle-map)
(bind-key "f" #'malb/toggle-fold             malb/toggle-map)
(bind-key "l" #'malb/toggle-light-dark       malb/toggle-map)
(bind-key "t" #'toggle-truncate-lines        malb/toggle-map)
(bind-key "q" #'toggle-debug-on-quit         malb/toggle-map)
(bind-key "i" #'imenu-list-smart-toggle      malb/toggle-map)
(bind-key "d" #'dired-sidebar-toggle-sidebar malb/toggle-map)
(bind-key "D" #'dedicated-mode               malb/toggle-map)
(bind-key "c" #'visual-fill-column-mode      malb/toggle-map)
#+end_src

** Learn Key Bindings

#+begin_src emacs-lisp
(use-package which-key
  :blackout which-key-mode
  :config (which-key-mode 1))
#+end_src

* Technical Artefacts

# Local Variables:
# eval: (when (fboundp 'ws-butler-mode) (ws-butler-mode 1))
# org-cycle-separator-lines: 0
# eval: (when (fboundp 'stripe-table-mode) (stripe-table-mode 1))
# fill-column: 158
# End:
